// Helper functions and page-specific initializer for Vulnerability Details (details.html)
// These are intentionally lightweight and dependency-free.

(function () {
  function initTabNavigation() {
    const tabsContainer = document.querySelector('.tech-tabs');
    const panelsContainer = document.querySelector('.tech-panels');
    if (!tabsContainer || !panelsContainer) return;

    const tabs = Array.from(tabsContainer.querySelectorAll('.tab-item'));
    const panels = Array.from(panelsContainer.querySelectorAll('.tab-panel'));
    const getTargetId = (tab) => tab.dataset.tab || tab.getAttribute('aria-controls');

    const setActive = (targetId) => {
      tabs.forEach(t => {
        const isActive = getTargetId(t) === targetId;
        t.classList.toggle('active', isActive);
        t.setAttribute('aria-selected', String(isActive));
        t.setAttribute('tabindex', isActive ? '0' : '-1');
      });
      panels.forEach(p => {
        const isTarget = p.id === targetId;
        p.classList.toggle('active', isTarget);
        if (isTarget) {
          p.removeAttribute('hidden');
        } else {
          p.setAttribute('hidden', '');
        }
      });
    };

    // Default to first tab if none active
    const initialTab = tabs.find(t => t.classList.contains('active')) || tabs[0];
    const initial = initialTab ? getTargetId(initialTab) : null;
    if (initial) setActive(initial);

    tabs.forEach(tab => {
      tab.addEventListener('click', (e) => {
        e.preventDefault();
        const target = getTargetId(tab);
        if (!target) return;
        setActive(target);
      });
      tab.addEventListener('keydown', (e) => {
        // Arrow key navigation for accessibility
        const idx = tabs.indexOf(tab);
        if (e.key === 'ArrowRight') {
          tabs[Math.min(idx + 1, tabs.length - 1)]?.focus();
        } else if (e.key === 'ArrowLeft') {
          tabs[Math.max(idx - 1, 0)]?.focus();
        } else if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          const target = getTargetId(tab);
          if (target) setActive(target);
        }
      });
    });
  }

  function initReferenceSearch() {
    const input = document.querySelector('#refSearch');
    const chips = Array.from(document.querySelectorAll('.filter-chip'));
    const cards = Array.from(document.querySelectorAll('.reference-card'));
    const countEl = document.querySelector('#refCount');
    if (!cards.length) return; // no references to search

    const getActiveFilters = () => chips
      .filter(c => c.classList.contains('active'))
      .map(c => c.dataset.filter)
      .filter(f => f !== 'all'); // 'all' não é filtro

    const applyFilter = () => {
      const term = (input?.value || '').toLowerCase().trim();
      const activeFilters = new Set(getActiveFilters());
      let visible = 0;
      cards.forEach(card => {
        const text = card.textContent.toLowerCase();
        const hasTerm = !term || text.includes(term);
        const hasPatch = card.dataset.patch === 'true';
        const matchesFilter = activeFilters.size === 0 || (activeFilters.has('patch') && hasPatch);
        const show = hasTerm && matchesFilter;
        card.style.display = show ? '' : 'none';
        if (show) visible++;
      });
      if (countEl) countEl.textContent = String(visible);
    };

    input?.addEventListener('input', applyFilter);
    chips.forEach(chip => {
      chip.addEventListener('click', () => {
        const isAll = chip.dataset.filter === 'all';
        if (isAll) {
          // 'Todas' é exclusivo
          chips.forEach(c => c.classList.toggle('active', c === chip));
        } else {
          chip.classList.toggle('active');
          // Se nenhum filtro estiver ativo, voltar para 'Todas'
          const anyActive = chips.some(c => c.classList.contains('active') && c.dataset.filter !== 'all');
          const allChip = chips.find(c => c.dataset.filter === 'all');
          if (!anyActive && allChip) allChip.classList.add('active');
          if (anyActive && allChip) allChip.classList.remove('active');
        }
        applyFilter();
      });
    });

    applyFilter();
  }

  function initScrollProgress() {
    const progressFill = document.querySelector('.vuln-nav-unified .nav-progress .progress-fill');
    if (!progressFill) return;

    const onScroll = () => {
      const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
      const scrollHeight = document.documentElement.scrollHeight || document.body.scrollHeight;
      const clientHeight = document.documentElement.clientHeight || window.innerHeight;
      const max = Math.max(scrollHeight - clientHeight, 1);
      const pct = Math.min((scrollTop / max) * 100, 100);
      progressFill.style.width = pct.toFixed(1) + '%';
    };

    window.addEventListener('scroll', onScroll, { passive: true });
    onScroll();
  }

  function toggleSection(sectionId) {
    const section = document.getElementById(sectionId);
    const toggleBtn = document.querySelector(`[data-toggle-section="${sectionId}"]`);
    if (!section) return;
    const isHidden = section.hasAttribute('hidden');
    if (isHidden) {
      section.removeAttribute('hidden');
      section.dispatchEvent(new CustomEvent('section:show', { bubbles: true }));
    } else {
      section.setAttribute('hidden', '');
      section.dispatchEvent(new CustomEvent('section:hide', { bubbles: true }));
    }
    if (toggleBtn) {
      toggleBtn.setAttribute('aria-expanded', String(isHidden));
    }
  }

  async function copyToClipboard(text) {
    try {
      if (navigator.clipboard?.writeText) {
        await navigator.clipboard.writeText(text);
        return true;
      }
    } catch (_) {}

    // Fallback
    try {
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.setAttribute('readonly', '');
      ta.style.position = 'absolute';
      ta.style.left = '-9999px';
      document.body.appendChild(ta);
      ta.select();
      const ok = document.execCommand('copy');
      document.body.removeChild(ta);
      return ok;
    } catch (_) {
      return false;
    }
  }

  async function shareVulnerability(opts = {}) {
    const url = opts.url || window.location.href;
    const title = opts.title || document.title || 'Vulnerability';
    const text = opts.text || 'Check out this vulnerability';

    if (navigator.share) {
      try {
        await navigator.share({ title, text, url });
        return true;
      } catch (_) {
        // fall through to clipboard
      }
    }

    const ok = await copyToClipboard(url);
    if (ok) {
      // Simple, non-blocking toast
      const toast = document.createElement('div');
      toast.textContent = 'Link copied to clipboard';
      toast.style.position = 'fixed';
      toast.style.bottom = '1rem';
      toast.style.right = '1rem';
      toast.style.background = '#0d6efd';
      toast.style.color = '#fff';
      toast.style.padding = '0.5rem 0.75rem';
      toast.style.borderRadius = '0.35rem';
      toast.style.boxShadow = '0 6px 20px rgba(0,0,0,0.15)';
      toast.style.zIndex = '1090';
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 1800);
      return true;
    }
    return false;
  }

  function initNavigationTracking() {
    // Track section headings intersecting viewport to set active nav item
    const items = Array.from(document.querySelectorAll('.vuln-nav-unified .nav-item'));
    if (!items.length) return;
    const map = new Map();
    items.forEach(it => {
      const target = document.querySelector(it.getAttribute('href'));
      if (target) map.set(it, target);
    });

    let active = null;
    const setActive = (item) => {
      if (active === item) return;
      items.forEach(i => i.classList.toggle('active', i === item));
      active = item;
    };

    const observer = new IntersectionObserver((entries) => {
      // Pick the most visible entry
      const visible = entries
        .filter(e => e.isIntersecting)
        .sort((a, b) => b.intersectionRatio - a.intersectionRatio)[0];
      if (!visible) return;
      const target = visible.target;
      const item = [...map.entries()].find(([, el]) => el === target)?.[0];
      if (item) setActive(item);
    }, { rootMargin: '-20% 0px -70% 0px', threshold: [0.1, 0.25, 0.5, 0.75, 1] });

    map.forEach(section => observer.observe(section));
  }

  function initDetailsPage() {
    initTabNavigation();
    initReferenceSearch();
    initScrollProgress();
    initNavigationTracking();

    // Wire share buttons if present
    document.querySelectorAll('[data-share="vulnerability"]').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.preventDefault();
        const ok = await shareVulnerability({
          title: btn.dataset.title || document.title,
          text: btn.dataset.text || 'Vulnerability details',
        });
        btn.classList.toggle('shared-ok', !!ok);
      });
    });

    // Wire section toggles if present
    document.querySelectorAll('[data-toggle-section]').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        const id = btn.dataset.toggleSection;
        if (id) toggleSection(id);
      });
    });
  }

  // Expose functions for inline script calls in template
  window.initTabNavigation = initTabNavigation;
  window.initReferenceSearch = initReferenceSearch;
  window.initScrollProgress = initScrollProgress;
  window.toggleSection = toggleSection;
  window.copyToClipboard = copyToClipboard;
  window.shareVulnerability = shareVulnerability;

  document.addEventListener('DOMContentLoaded', initDetailsPage, { once: true });
})();