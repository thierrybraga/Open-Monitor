/**
 * Vulnerability Details Page JavaScript
 * Handles interactive charts and data visualization
 */

class VulnerabilityDetailsCharts {
    constructor() {
        this.charts = {};
        this.colors = {
            primary: '#007bff',
            secondary: '#6c757d',
            success: '#28a745',
            danger: '#dc3545',
            warning: '#ffc107',
            info: '#17a2b8',
            light: '#f8f9fa',
            dark: '#343a40'
        };
        this.severityColors = {
            'critical': '#dc3545',
            'high': '#fd7e14',
            'medium': '#ffc107',
            'low': '#28a745'
        };
    }
    
    /**
     * Show error message when chart cannot be loaded
     * @param {HTMLElement} ctx - Canvas element
     * @param {string} message - Error message to display
     */
    showChartError(ctx, message) {
        const wrapper = ctx.parentElement;
        if (wrapper) {
            const msg = document.createElement('div');
            msg.className = 'chart-empty-message';
            msg.textContent = message;
            wrapper.innerHTML = '';
            wrapper.appendChild(msg);
        }
    }

    /**
     * Initialize all charts
     */
    init() {
        this.initDailyDistributionChart();
        this.initCvssDistributionChart();
        this.initTopProductsChart();
    }

    /**
     * Initialize daily distribution chart
     */
    initDailyDistributionChart() {
        const ctx = document.getElementById('dailyChart');
        if (!ctx) return;
        
        try {
            // Guard: Chart.js not loaded
            if (typeof window.Chart === 'undefined') {
                this.showChartError(ctx, 'Gráfico indisponível (biblioteca não carregada)');
                return;
            }
        } catch (error) {
            this.showChartError(ctx, 'Erro ao inicializar gráfico');
            return;
        }

        // Obter dados do template ou do atributo data (fallback para CSP)
        let dailyData = [];
        try {
            dailyData = (window.chartData && Array.isArray(window.chartData.daily))
                ? window.chartData.daily
                : (ctx.dataset.daily ? JSON.parse(ctx.dataset.daily) : []);
        } catch (e) {
            dailyData = [];
        }

        // Se não houver dados, exibir mensagem amigável
        if (!Array.isArray(dailyData) || dailyData.length === 0) {
            const wrapper = ctx.parentElement;
            if (wrapper) {
                const msg = document.createElement('div');
                msg.className = 'chart-empty-message';
                msg.textContent = 'Sem dados para o período selecionado';
                wrapper.innerHTML = '';
                wrapper.appendChild(msg);
            }
            return;
        }
        
        // Labels com parsing robusto (YYYY-MM-DD -> Date(year, month-1, day))
        const labels = dailyData.map(item => {
            const parts = String(item.date).split('-').map(Number);
            const dateObj = (parts.length === 3 && parts.every(function(n){ return !isNaN(n); }))
                ? new Date(parts[0], parts[1] - 1, parts[2])
                : new Date(item.date);
            if (typeof window.Utils !== 'undefined' && typeof window.Utils.formatDate === 'function') {
                return window.Utils.formatDate(dateObj, { weekday: 'short', day: '2-digit', month: '2-digit' });
            }
            var locale = (typeof window.Utils !== 'undefined' && typeof window.Utils.getLocale === 'function')
                ? window.Utils.getLocale() : 'pt-BR';
            return dateObj.toLocaleDateString(locale, { weekday: 'short', day: '2-digit', month: '2-digit' });
        });
        
        const data = dailyData.map(item => Number(item.count) || 0);

        this.charts.dailyDistribution = new window.Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Vulnerabilidades por Dia',
                    data: data,
                    borderColor: this.colors.primary,
                    backgroundColor: this.colors.primary + '20',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.4,
                    pointBackgroundColor: this.colors.primary,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointRadius: 6,
                    pointHoverRadius: 8
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        titleColor: '#fff',
                        bodyColor: '#fff',
                        borderColor: this.colors.primary,
                        borderWidth: 1,
                        cornerRadius: 8,
                        displayColors: false,
                        callbacks: {
                            title: function(context) {
                                return context[0].label;
                            },
                            label: function(context) {
                                return `${context.parsed.y} vulnerabilidades`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            color: '#6c757d',
                            font: {
                                size: 12
                            }
                        }
                    },
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.1)',
                            drawBorder: false
                        },
                        ticks: {
                            color: '#6c757d',
                            font: {
                                size: 12
                            },
                            stepSize: 1
                        }
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                }
            }
        });
    }

    /**
     * Initialize CVSS distribution chart
     */
    initCvssDistributionChart() {
        const ctx = document.getElementById('cvssChart');
        if (!ctx) return;
        // Guard: Chart.js not loaded
        if (typeof window.Chart === 'undefined') {
            const wrapper = ctx.parentElement;
            if (wrapper) {
                const msg = document.createElement('div');
                msg.className = 'chart-empty-message';
                msg.textContent = 'Sem dados de CVSS para a última semana';
                wrapper.innerHTML = '';
                wrapper.appendChild(msg);
            }
            const sourceEl = document.getElementById('cvssChartSource');
            if (sourceEl) sourceEl.textContent = 'Sem dados';
            return;
        }

        const sourceEl = document.getElementById('cvssChartSource');
        const setSource = (text) => { if (sourceEl) sourceEl.textContent = text; };
        const toPtLabel = (key) => {
            const map = { critical: 'Crítica', high: 'Alta', medium: 'Média', low: 'Baixa' };
            return map[key] || key;
        };

        // Distribuição CVSS semanal (dados do template)
        const labels = ['Críticas', 'Altas', 'Médias', 'Baixas'];
        const colors = [
            this.severityColors.critical,
            this.severityColors.high,
            this.severityColors.medium,
            this.severityColors.low
        ];

        const renderDoughnut = (data) => {
            if (typeof window.Chart === 'undefined') return false;
            const total = data.reduce((a, b) => a + b, 0);
            if (total <= 0) return false;
            this.charts.cvssDistribution = new window.Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors,
                        borderColor: '#fff',
                        borderWidth: 2,
                        hoverBorderWidth: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { padding: 16 },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            fullSize: false,
                            labels: {
                                padding: 10,
                                boxWidth: 10,
                                usePointStyle: true,
                                font: { size: 10 },
                                color: '#495057'
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: 'rgba(255, 255, 255, 0.2)',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const value = context.parsed || 0;
                                    if (total > 0) {
                                        const percentage = ((value / total) * 100).toFixed(1);
                                        return `${context.label}: ${value} (${percentage}%)`;
                                    }
                                    return `${context.label}: ${value}`;
                                }
                            }
                        }
                    },
                    radius: '78%',
                    cutout: '62%'
                },
                plugins: [{
                    id: 'centerText',
                    afterDatasetsDraw(chart) {
                        try {
                            const { ctx } = chart;
                            const labels = chart.data.labels || [];
                            const dataArr = chart.data.datasets?.[0]?.data || [];
                            if (!Array.isArray(dataArr) || dataArr.length === 0) return;

                            const meta = chart.getDatasetMeta(0);
                            const firstArc = meta?.data?.[0];
                            if (!firstArc || typeof firstArc.x !== 'number' || typeof firstArc.y !== 'number') return;

                            const x = firstArc.x;
                            const y = firstArc.y;
                            const idx = labels.findIndex(l => typeof l === 'string' && l === 'Críticas');
                            const total = dataArr.reduce((a, b) => a + b, 0);
                            const criticalCount = idx >= 0 ? dataArr[idx] : 0;
                            const criticalPercent = total > 0 ? Math.round((criticalCount / total) * 100) : 0;

                            ctx.save();
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillStyle = '#343a40';
                            ctx.font = '600 16px Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial';
                            ctx.fillText(`${criticalPercent}%`, x, y);
                            ctx.font = '500 11px Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial';
                            ctx.fillStyle = '#6c757d';
                            ctx.fillText('Críticas', x, y + 16);
                            ctx.restore();
                        } catch (err) {
                            // Evitar que um erro no plugin quebre o gráfico
                        }
                    }
                }]

            });
            return true;
        };

        // Reordenar prioridade: quando vendors selecionados, priorizar dados escopados por vendor
        const hasVendorScope = (() => {
            const cfg = window.severityConfig || {};
            const ids = Array.isArray(cfg.vendorIds) ? cfg.vendorIds : [];
            const names = Array.isArray(cfg.vendorNames) ? cfg.vendorNames : [];
            return (ids.length > 0) || (names.length > 0);
        })();

        // 1) Prioridade: distribuição semanal da severidade desta página (escopada por vendor quando presente)
        let cvssRaw = window.chartData?.cvss;
        if (!cvssRaw && ctx.dataset.cvss) {
            try { cvssRaw = JSON.parse(ctx.dataset.cvss); } catch (e) { cvssRaw = null; }
        }
        const sev = { critical: 0, high: 0, medium: 0, low: 0 };
        if (cvssRaw) {
            if (Array.isArray(cvssRaw)) {
                cvssRaw.forEach(item => {
                    const range = (item.range || item.label || '').toString();
                    const count = Number(item.count ?? item.value ?? 0) || 0;
                    if (range.includes('9.0-10.0')) sev.critical += count;
                    else if (range.includes('7.0-8.9')) sev.high += count;
                    else if (range.includes('4.0-6.9')) sev.medium += count;
                    else if (range.includes('0.0-3.9')) sev.low += count;
                });
            } else if (typeof cvssRaw === 'object') {
                sev.low = Number(cvssRaw['0.0-3.9'] || 0);
                sev.medium = Number(cvssRaw['4.0-6.9'] || 0);
                sev.high = Number(cvssRaw['7.0-8.9'] || 0);
                sev.critical = Number(cvssRaw['9.0-10.0'] || 0);
            }
        }
        const weekArr = [sev.critical, sev.high, sev.medium, sev.low];
        if (renderDoughnut(weekArr)) {
            const sevLabel = (window.severityConfig?.display || ctx.dataset.severity || 'Desconhecida');
            setSource(`${hasVendorScope ? 'Vendor-escopado: ' : ''}Semana atual (${sevLabel})`);
            return;
        }

        // 2) Fallback com prioridade quando vendors: distribuição de TODAS as CVEs (sem janela) por severidade atual
        let cvssAllSeverity = window.chartData?.cvssAllSeverity;
        if (!cvssAllSeverity && ctx.dataset.cvssAllSeverity) {
            try { cvssAllSeverity = JSON.parse(ctx.dataset.cvssAllSeverity); } catch (e) { cvssAllSeverity = null; }
        }
        if (cvssAllSeverity) {
            const sevAll = { critical: 0, high: 0, medium: 0, low: 0 };
            if (Array.isArray(cvssAllSeverity)) {
                cvssAllSeverity.forEach(item => {
                    const range = (item.range || item.label || '').toString();
                    const count = Number(item.count ?? item.value ?? 0) || 0;
                    if (range.includes('9.0-10.0')) sevAll.critical += count;
                    else if (range.includes('7.0-8.9')) sevAll.high += count;
                    else if (range.includes('4.0-6.9')) sevAll.medium += count;
                    else if (range.includes('0.0-3.9')) sevAll.low += count;
                });
            } else if (typeof cvssAllSeverity === 'object') {
                sevAll.low = Number(cvssAllSeverity['0.0-3.9'] || 0);
                sevAll.medium = Number(cvssAllSeverity['4.0-6.9'] || 0);
                sevAll.high = Number(cvssAllSeverity['7.0-8.9'] || 0);
                sevAll.critical = Number(cvssAllSeverity['9.0-10.0'] || 0);
            }
            const allArr = [sevAll.critical, sevAll.high, sevAll.medium, sevAll.low];
            if (renderDoughnut(allArr)) {
                const sevLabel = (window.severityConfig?.display || ctx.dataset.severity || 'Desconhecida');
                setSource(`${hasVendorScope ? 'Vendor-escopado: ' : ''}Todas as CVEs (${sevLabel})`);
                return;
            }
        }

        // 3) Por fim: distribuição GLOBAL da última semana (todas as severidades)
        let cvssGlobal = window.chartData?.cvssGlobal;
        if (!cvssGlobal && ctx.dataset.cvssGlobal) {
            try { cvssGlobal = JSON.parse(ctx.dataset.cvssGlobal); } catch (e) { cvssGlobal = null; }
        }
        if (cvssGlobal) {
            const sevGlobal = { critical: 0, high: 0, medium: 0, low: 0 };
            if (Array.isArray(cvssGlobal)) {
                cvssGlobal.forEach(item => {
                    const range = (item.range || item.label || '').toString();
                    const count = Number(item.count ?? item.value ?? 0) || 0;
                    if (range.includes('9.0-10.0')) sevGlobal.critical += count;
                    else if (range.includes('7.0-8.9')) sevGlobal.high += count;
                    else if (range.includes('4.0-6.9')) sevGlobal.medium += count;
                    else if (range.includes('0.0-3.9')) sevGlobal.low += count;
                });
            } else if (typeof cvssGlobal === 'object') {
                sevGlobal.low = Number(cvssGlobal['0.0-3.9'] || 0);
                sevGlobal.medium = Number(cvssGlobal['4.0-6.9'] || 0);
                sevGlobal.high = Number(cvssGlobal['7.0-8.9'] || 0);
                sevGlobal.critical = Number(cvssGlobal['9.0-10.0'] || 0);
            }
            const globalArr = [sevGlobal.critical, sevGlobal.high, sevGlobal.medium, sevGlobal.low];
            if (renderDoughnut(globalArr)) { setSource('Global (última semana)'); return; }
        }

        // Último recurso: exibir donut com score único se presente
        const scoreAttr = ctx.dataset.cvssScore;
        if (scoreAttr) {
            const score = parseFloat(scoreAttr);
            if (!isNaN(score) && score >= 0) {
                const normalizeSeverityKey = (val) => {
                    const v = (val || '').toLowerCase();
                    const map = {
                        'critical': 'critical', 'crítica': 'critical', 'críticas': 'critical',
                        'high': 'high', 'alta': 'high', 'altas': 'high',
                        'medium': 'medium', 'média': 'medium', 'médias': 'medium',
                        'low': 'low', 'baixa': 'low', 'baixas': 'low'
                    };
                    return map[v] || '';
                };
                const severityRaw = window.severityConfig?.severity || ctx.dataset.cvssSeverity || '';
                const severityKey = normalizeSeverityKey(severityRaw);
                let color;
                if (severityKey) {
                    color = this.severityColors[severityKey];
                } else {
                    if (score >= 9.0) color = this.severityColors.critical;
                    else if (score >= 7.0) color = this.severityColors.high;
                    else if (score >= 4.0) color = this.severityColors.medium;
                    else color = this.severityColors.low;
                }

                this.charts.cvssDistribution = new window.Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Score CVSS', 'Restante'],
                        datasets: [{
                            data: [score, Math.max(10 - score, 0)],
                            backgroundColor: [color, '#e2e8f0'],
                            borderWidth: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        radius: '78%',
                        cutout: '62%'
                    }
                });
                const sevLabel = toPtLabel((severityKey || '').toLowerCase());
                setSource(`Score CVSS: ${score}${sevLabel ? ` (${sevLabel})` : ''}`);
                return;
            }
        }

        // Caso não haja dados para renderizar, exibir mensagem amigável
        const wrapper = ctx.parentElement;
        if (wrapper) {
            const msg = document.createElement('div');
            msg.className = 'chart-empty-message';
            msg.textContent = 'Sem dados de CVSS para a última semana';
            wrapper.innerHTML = '';
            wrapper.appendChild(msg);
        }
        setSource('Sem dados');
    }

    /**
     * Initialize top products chart
     */
    initTopProductsChart() {
        const ctx = document.getElementById('productsChart');
        if (!ctx) return;
        // Guard: Chart.js not loaded
        if (typeof window.Chart === 'undefined') {
            const wrapper = ctx.parentElement;
            if (wrapper) {
                const msg = document.createElement('div');
                msg.className = 'chart-empty-message';
                msg.textContent = 'Gráfico indisponível (biblioteca não carregada)';
                wrapper.innerHTML = '';
                wrapper.appendChild(msg);
            }
            return;
        }

        // Obter dados do template ou do atributo data (fallback para CSP)
        let rawProducts = [];
        try {
            rawProducts = (window.chartData && Array.isArray(window.chartData.products))
                ? window.chartData.products
                : (ctx.dataset.products ? JSON.parse(ctx.dataset.products) : []);
        } catch (e) {
            rawProducts = [];
        }

        // Normalizar itens para { name: string, count: number, vendorName?: string, vendorId?: number }
        const normalized = rawProducts.map(item => {
            if (Array.isArray(item) && item.length >= 2) {
                return { name: String(item[0]).trim(), count: Number(item[1]) || 0 };
            } else if (item && typeof item === 'object') {
                const name = String(item.product || item.name || item.label || '').trim();
                const count = Number(item.count ?? item.value ?? 0) || 0;
                const vendorName = String(item.vendor_name ?? item.vendorName ?? '').trim();
                const vendorIdRaw = item.vendor_id ?? item.vendorId;
                const vendorId = (vendorIdRaw === null || vendorIdRaw === undefined) ? undefined : Number(vendorIdRaw);
                return { name, count, vendorName, vendorId };
            }
            return { name: String(item || '').trim(), count: 0 };
        }).filter(p => p.name && p.count > 0);

        // Aplicar filtro por vendor selecionado (ID prioritário; fallback por nome)
        const vendorFilterEl = document.getElementById('vendorFilter');
        let filtered = normalized;
        try {
            const selectedRaw = (vendorFilterEl && vendorFilterEl.value) ? vendorFilterEl.value : 'all';
            if (selectedRaw && selectedRaw !== 'all') {
                const selectedId = Number(selectedRaw);
                if (!Number.isNaN(selectedId)) {
                    // Filtrar por vendorId quando disponível
                    filtered = filtered.filter(p => typeof p.vendorId === 'number' && p.vendorId === selectedId);
                } else {
                    // Fallback: filtrar por vendorName (case-insensitive)
                    const selectedName = String(selectedRaw).toLowerCase();
                    filtered = filtered.filter(p => String(p.vendorName || '').toLowerCase() === selectedName);
                }
            }
        } catch (_e) {
            // Silently ignore any filtering errors
        }

        // Se não houver dados, exibir mensagem amigável
        if (!Array.isArray(filtered) || filtered.length === 0) {
            const wrapper = ctx.parentElement;
            if (wrapper) {
                const msg = document.createElement('div');
                msg.className = 'chart-empty-message';
                msg.textContent = 'Sem dados de produtos afetados para o vendor selecionado';
                wrapper.innerHTML = '';
                wrapper.appendChild(msg);
            }
            return;
        }

        // Ordenar por count decrescente e limitar Top 10
        const top = filtered.sort((a, b) => b.count - a.count).slice(0, 10);

        const labels = top.map(item => item.name);
        const data = top.map(item => item.count);

        this.charts.topProducts = new window.Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Produtos Mais Afetados',
                    data: data,
                    backgroundColor: this.colors.info + '80',
                    borderColor: this.colors.info,
                    borderWidth: 2,
                    borderRadius: 6,
                    borderSkipped: false
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        titleColor: '#fff',
                        bodyColor: '#fff',
                        borderColor: this.colors.info,
                        borderWidth: 1,
                        cornerRadius: 8,
                        displayColors: false,
                        callbacks: {
                            title: function(context) {
                                return context[0].label;
                            },
                            label: function(context) {
                                return `${context.parsed.y} vulnerabilidades`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            color: '#6c757d',
                            font: {
                                size: 11
                            },
                            maxRotation: 45,
                            minRotation: 0
                        }
                    },
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.1)',
                            drawBorder: false
                        },
                        ticks: {
                            color: '#6c757d',
                            font: {
                                size: 12
                            },
                            stepSize: 1
                        }
                    }
                }
            }
        });
    }

    /**
     * Destroy all charts
     */
    destroy() {
        Object.values(this.charts).forEach(chart => {
            if (chart) {
                chart.destroy();
            }
        });
        this.charts = {};
    }

    /**
     * Resize all charts
     */
    resize() {
        Object.values(this.charts).forEach(chart => {
            if (chart) {
                chart.resize();
            }
        });
    }
}

/**
 * Vulnerability Details Page Controller
 */
class VulnerabilityDetailsPage {
    constructor() {
        this.charts = new VulnerabilityDetailsCharts();
        this.init();
    }

    init() {
        this.initCharts();
        this.initEventListeners();
        this.initTooltips();
    }

    initCharts() {
        // Wait for DOM to be ready, then ensure Chart.js is loaded before initializing charts
        const start = () => {
            const waitForChart = (attempts = 30) => {
                if (typeof window.Chart !== 'undefined') {
                    this.charts.init();
                    return;
                }
                if (attempts <= 0) {
                    this.showChartsUnavailableNotice();
                    return;
                }
                setTimeout(() => waitForChart(attempts - 1), 100);
            };

            this.loadChartJS()
                .then(() => {
                    waitForChart(30);
                })
                .catch((err) => {
                    try { console.warn('[vulnerability-charts] Chart.js failed to load:', err); } catch (_){}
                    // Provide a graceful message instead of empty canvases
                    this.showChartsUnavailableNotice();
                });
        };
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', start);
        } else {
            start();
        }
    }

    // Carrega Chart.js via utilitário centralizado, com fallback seguro
    loadChartJS() {
        return new Promise(function(resolve, reject) {
            if (typeof window.Chart !== 'undefined') { resolve(); return; }
            try {
                if (window.Utils && window.Utils.ChartLoader && typeof window.Utils.ChartLoader.ensure === 'function') {
                    window.Utils.ChartLoader.ensure().then(resolve).catch(reject);
                    return;
                }
            } catch (_) {}
            // Fallback mínimo caso ChartLoader não esteja disponível
            var existing = Array.prototype.slice.call(document.querySelectorAll('script[src]')).find(function(s){
                var src = s.getAttribute('src') || '';
                return /(?:\/|^)chart(?:\.umd)?(?:\.min)?\.js$/i.test(src) || src.indexOf('cdn.jsdelivr.net/npm/chart.js') !== -1;
            });
            if (existing) {
                if (typeof window.Chart !== 'undefined') { resolve(); return; }
                existing.addEventListener('load', function(){ resolve(); });
                existing.addEventListener('error', function(){ reject(new Error('Failed to load existing Chart.js')); });
                return;
            }
            var script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js';
            script.crossOrigin = 'anonymous';
            script.referrerPolicy = 'no-referrer';
            // Propaga nonce se existir (CSP)
            try {
                var inlineWithNonce = document.querySelector('script[nonce]');
                var nonce = inlineWithNonce && inlineWithNonce.getAttribute('nonce');
                if (nonce) script.setAttribute('nonce', nonce);
            } catch (_) {}
            script.onload = function(){ resolve(); };
            script.onerror = function(){ reject(new Error('Failed to load Chart.js')); };
            document.head.appendChild(script);
        });
    }

    // Replace chart canvases with an informative message when Chart.js is unavailable
    showChartsUnavailableNotice() {
        const ids = ['dailyChart', 'cvssChart', 'productsChart'];
        ids.forEach((id) => {
            const canvas = document.getElementById(id);
            const parent = canvas && canvas.parentElement;
            if (parent) {
                const msg = document.createElement('div');
                msg.className = 'chart-empty-message';
                msg.textContent = 'Gráfico indisponível (biblioteca não carregada)';
                parent.innerHTML = '';
                parent.appendChild(msg);
            }
        });
    }

    initEventListeners() {
        // Export functionality
        const exportBtn = document.getElementById('exportBtn');
        if (exportBtn) {
            exportBtn.addEventListener('click', this.exportData.bind(this));
        }

        // View all vulnerabilities
        const viewAllBtn = document.getElementById('viewAllBtn');
        if (viewAllBtn) {
            viewAllBtn.addEventListener('click', this.viewAllVulnerabilities.bind(this));
        }

        // Window resize handler
        window.addEventListener('resize', () => {
            this.charts.resize();
        });

        // Print handler
        window.addEventListener('beforeprint', () => {
            this.charts.resize();
        });

        // Vendor filter change should update Top Products chart
        const vendorFilter = document.getElementById('vendorFilter');
        if (vendorFilter) {
            vendorFilter.addEventListener('change', () => {
                try {
                    // Destroy existing chart instance to avoid overlay
                    if (this.charts && this.charts.charts && this.charts.charts.topProducts) {
                        this.charts.charts.topProducts.destroy();
                        this.charts.charts.topProducts = null;
                    }
                    // Re-render chart with current vendor selection
                    this.charts.initTopProductsChart();
                } catch (_e) {
                    // Silently ignore errors to avoid breaking the page
                }
            });
        }

        // Scrollspy and smooth anchor scrolling for quick nav
        this.initScrollSpy();

        // NOTE: Table filtering/search is handled by vulnerability-details-table.js
        // Removed duplicate simple filtering to avoid conflicts and double work.
    }

    initTooltips() {
        if (typeof bootstrap !== 'undefined' && bootstrap.Tooltip) {
            const tooltipEls = document.querySelectorAll('[data-bs-toggle="tooltip"]');
            tooltipEls.forEach(el => {
                if (!bootstrap.Tooltip.getInstance(el)) {
                    new bootstrap.Tooltip(el);
                }
            });
        }
    }

    exportData() {
        const severity = (document.querySelector('[data-severity]')?.dataset.severity || (window.severityConfig && window.severityConfig.severity) || 'all');
        const vendorIds = (window.severityConfig && Array.isArray(window.severityConfig.vendorIds)) ? window.severityConfig.vendorIds : [];
        const vendorParam = vendorIds && vendorIds.length ? `&vendor_ids=${encodeURIComponent(vendorIds.join(','))}` : '';
        const url = `/api/vulnerabilities/export?severity=${encodeURIComponent(severity)}&period=week${vendorParam}`;
        
        // Create a temporary link to download the file
        const link = document.createElement('a');
        link.href = url;
        link.download = `vulnerabilities_${severity}_${new Date().toISOString().split('T')[0]}.csv`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    viewAllVulnerabilities() {
        const severity = (document.querySelector('[data-severity]')?.dataset.severity || (window.severityConfig && window.severityConfig.severity) || 'all');
        const vendorIds = (window.severityConfig && Array.isArray(window.severityConfig.vendorIds)) ? window.severityConfig.vendorIds : [];
        const params = new URLSearchParams(window.location.search);
        const scope = params.get('vendor_scope');
        let scopeParam = '';
        let vendorParam = '';
        if (scope === 'all') {
            scopeParam = '&vendor_scope=all';
        } else if (vendorIds && vendorIds.length) {
            vendorParam = `&vendor_ids=${encodeURIComponent(vendorIds.join(','))}`;
        }
        window.location.href = `/vulnerabilities?severity=${encodeURIComponent(severity)}${scopeParam}${vendorParam}`;
    }

    /**
     * Update statistics with animation
     */
    updateStatistics(newStats) {
        Object.entries(newStats).forEach(([key, value]) => {
            const element = document.querySelector(`[data-stat="${key}"]`);
            if (element) {
                this.animateNumber(element, parseInt(element.textContent) || 0, value);
            }
        });
    }

    /**
     * Animate number changes
     */
    animateNumber(element, start, end, duration = 1000) {
        const range = end - start;
        const increment = range / (duration / 16);
        let current = start;

        const timer = setInterval(() => {
            current += increment;
            if ((increment > 0 && current >= end) || (increment < 0 && current <= end)) {
                current = end;
                clearInterval(timer);
            }
            element.textContent = Math.floor(current).toLocaleString('pt-BR');
        }, 16);
    }

    /**
     * Show loading state
     */
    showLoading() {
        const loadingOverlay = document.createElement('div');
        loadingOverlay.className = 'loading-overlay';
        loadingOverlay.innerHTML = `
            <div class="loading-spinner">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Carregando...</span>
                </div>
                <p class="mt-3">Carregando dados...</p>
            </div>
        `;
        document.body.appendChild(loadingOverlay);
    }

    /**
     * Hide loading state
     */
    hideLoading() {
        const loadingOverlay = document.querySelector('.loading-overlay');
        if (loadingOverlay) {
            loadingOverlay.remove();
        }
    }

    /**
     * Initialize scrollspy for quick page navigation
     */
    initScrollSpy() {
        const quickNav = document.querySelector('.page-quick-nav');
        const links = quickNav ? Array.from(quickNav.querySelectorAll('.nav-link[href^="#"]')) : [];
        if (!links.length) return;

        const targets = links
            .map(link => ({ link, id: link.getAttribute('href').split('#')[1] }))
            .map(({ link, id }) => ({ link, target: document.getElementById(id) }))
            .filter(item => !!item.target);

        // Smooth scroll with offset for sticky header
        const header = document.querySelector('.navbar') || document.querySelector('header');
        const offset = (header?.offsetHeight || 72) + 12;
        links.forEach(link => {
            link.addEventListener('click', function(e) {
                const hash = this.getAttribute('href');
                if (hash && hash.startsWith('#')) {
                    e.preventDefault();
                    const el = document.getElementById(hash.slice(1));
                    if (el) {
                        const top = el.getBoundingClientRect().top + window.scrollY - offset;
                        window.scrollTo({ top, behavior: 'smooth' });
                    }
                }
            });
        });

        const observer = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                const item = targets.find(t => t.target === entry.target);
                if (!item) return;
                if (entry.isIntersecting) {
                    links.forEach(l => l.classList.remove('active'));
                    item.link.classList.add('active');
                }
            });
        }, { root: null, threshold: 0.5, rootMargin: `-${offset}px 0px -40% 0px` });

        targets.forEach(({ target }) => observer.observe(target));
    }
}

// Initialize when DOM is ready
(function() {
  try {
    if (!window.vulnerabilityDetailsPage) {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
          if (!window.vulnerabilityDetailsPage) {
            window.vulnerabilityDetailsPage = new VulnerabilityDetailsPage();
          }
          try {
            const el = document.getElementById('last-update');
            if (el) {
              const dailyCanvas = document.getElementById('dailyChart');
              let ts = new Date();
              if (dailyCanvas) {
                const dataAttr = dailyCanvas.getAttribute('data-daily');
                if (dataAttr) {
                  const arr = JSON.parse(dataAttr);
                  const last = Array.isArray(arr) && arr.length ? arr[arr.length - 1] : null;
                  const d = last && (last.date || last.day || last.timestamp);
                  if (d) ts = new Date(d);
                }
              }
              el.textContent = ts.toLocaleString();
            }
          } catch (e) {}
        }, { once: true });
      } else {
        window.vulnerabilityDetailsPage = new VulnerabilityDetailsPage();
        try {
          const el = document.getElementById('last-update');
          if (el) {
            const dailyCanvas = document.getElementById('dailyChart');
            let ts = new Date();
            if (dailyCanvas) {
              const dataAttr = dailyCanvas.getAttribute('data-daily');
              if (dataAttr) {
                const arr = JSON.parse(dataAttr);
                const last = Array.isArray(arr) && arr.length ? arr[arr.length - 1] : null;
                const d = last && (last.date || last.day || last.timestamp);
                if (d) ts = new Date(d);
              }
            }
            el.textContent = ts.toLocaleString();
          }
        } catch (e) {}
      }
  } catch (e) {
    // Silently ignore to avoid breaking the page
  }
})();

// Global functions for template use
window.VulnerabilityDetailsCharts = VulnerabilityDetailsCharts;
window.VulnerabilityDetailsPage = VulnerabilityDetailsPage;
// Expose exportData as a global function for inline template handlers
// Safely delegates to the page controller if initialized
if (typeof window.exportData !== 'function') {
  window.exportData = function() {
    try {
      if (window.vulnerabilityDetailsPage && typeof window.vulnerabilityDetailsPage.exportData === 'function') {
        window.vulnerabilityDetailsPage.exportData();
      }
    } catch (e) {
      // Silently ignore to avoid breaking the page; controller sets up on DOM ready
    }
  };
}

// ==========================================================================
// UI Enhancements and Animations (formerly vulnerability-details-extra.js)
// ==========================================================================

// Scroll animations
(function() {
  const initScrollAnimations = function() {
    const observerOptions = {
        threshold: 0.1,
        rootMargin: '0px 0px -50px 0px'
    };

    const observer = new IntersectionObserver(function(entries) {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.style.opacity = '1';
                entry.target.style.transform = 'translateY(0)';
            }
        });
    }, observerOptions);

    document.querySelectorAll('.fade-in, .slide-in').forEach(el => {
        el.style.opacity = '0';
        el.style.transform = 'translateY(20px)';
        el.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
        observer.observe(el);
    });
  };
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initScrollAnimations, { once: true });
  } else {
    initScrollAnimations();
  }
})();

// Enhanced hover effects
(function() {
  const initHoverEffects = function() {
    const cards = document.querySelectorAll('.analytics-card, .section');
    cards.forEach(card => {
        card.addEventListener('mouseenter', function() {
            this.style.transform = 'translateY(-4px)';
        });
        card.addEventListener('mouseleave', function() {
            this.style.transform = 'translateY(0)';
        });
    });
  };
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initHoverEffects, { once: true });
  } else {
    initHoverEffects();
  }
})();

// Density toggle with persistence
(function() {
  const initDensityToggle = function() {
    const densityBtn = document.getElementById('densityToggle');
    const stored = localStorage.getItem('ui-density');
    if (stored === 'compact') {
        document.body.classList.add('compact-mode');
        if (densityBtn) {
            densityBtn.innerHTML = '<i class="fas fa-expand-alt" aria-hidden="true"></i> Confortável';
            densityBtn.setAttribute('aria-pressed', 'true');
        }
    }
    if (densityBtn) {
        densityBtn.addEventListener('click', function(e) {
            e.preventDefault();
            const isCompact = document.body.classList.toggle('compact-mode');
            if (isCompact) {
                localStorage.setItem('ui-density', 'compact');
                this.innerHTML = '<i class="fas fa-expand-alt" aria-hidden="true"></i> Confortável';
                this.setAttribute('aria-pressed', 'true');
            } else {
                localStorage.setItem('ui-density', 'comfortable');
                this.innerHTML = '<i class="fas fa-compress-alt" aria-hidden="true"></i> Compacto';
                this.setAttribute('aria-pressed', 'false');
            }
        });
    }
  };
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initDensityToggle, { once: true });
  } else {
    initDensityToggle();
  }
})();

// Vendor filter functionality handled by VulnerabilityTable (vulnerability-details-table.js)
// Removed duplicate listener to avoid conflicts.
