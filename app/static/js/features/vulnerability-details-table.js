document.addEventListener('DOMContentLoaded', function() {
  // ==== Table Functionality ====
  class VulnerabilityTable {
      constructor() {
          this.table = document.getElementById('vulnTable');
          this.searchInput = document.getElementById('tableSearch');
          this.vendorFilter = document.getElementById('vendorFilter');
          this.quickFilterButtons = document.querySelectorAll('.quick-filter');
          this.patchMode = 'all';
          this.cvssMin = document.getElementById('cvssMin');
          this.cvssMax = document.getElementById('cvssMax');
          this.init();
      }
      init() {
          if (this.searchInput) {
              const handler = Utils.debounce(() => {
                  this.applyFilters();
              }, 300, 'vuln-details-table-search');
              this.searchInput.addEventListener('input', handler);
          }
          if (this.vendorFilter) {
              this.vendorFilter.addEventListener('change', () => this.applyFilters());
          }
          [this.cvssMin, this.cvssMax].forEach(el => {
              if (el) {
                  const cvssHandler = Utils.debounce(() => {
                      this.applyFilters();
                  }, 500, 'vuln-details-cvss');
                  el.addEventListener('input', cvssHandler);
              }
          });
          this.initSorting();
          this.initTooltips();
          this.initQuickNav();
          this.normalizeVendorOptions();
          this.initQuickFilters();
      }
      applyFilters() {
          const searchTerm = this.searchInput?.value.toLowerCase() || '';
          const vendor = this.vendorFilter?.value || 'all';
          const patch = this.patchMode || 'all';
          const cvssMin = parseFloat(this.cvssMin?.value) || 0;
          const cvssMax = parseFloat(this.cvssMax?.value) || 10;
          let visibleCount = 0;
          const rows = this.table?.querySelectorAll('tbody tr') || [];
          rows.forEach(row => {
              const cve = row.dataset.cve?.toLowerCase() || '';
              const rowVendor = row.dataset.vendor || '';
              const rowPatch = row.dataset.patch || '';
              const cvssText = (row.querySelector('.cvss-badge')?.textContent || '').trim();
              const cvss = parseFloat(cvssText) || 0;
              const rowText = row.textContent.toLowerCase();
              const matchesSearch = !searchTerm || cve.includes(searchTerm) || rowText.includes(searchTerm);
              const matchesVendor = vendor === 'all' || rowVendor === vendor;
              const matchesPatch = patch === 'all' || rowPatch === patch;
              const matchesCVSS = cvss >= cvssMin && cvss <= cvssMax;
              if (matchesSearch && matchesVendor && matchesPatch && matchesCVSS) {
                  row.style.display = '';
                  visibleCount++;
              } else {
                  row.style.display = 'none';
              }
          });
          const countEl = document.getElementById('showingCount');
          if (countEl) countEl.textContent = visibleCount;
          this.highlightSearch(searchTerm);
          this.updateActiveFilters();
      }
      updateActiveFilters() {
          const container = document.getElementById('activeFilters');
          const tagsContainer = document.getElementById('filterTags');
          if (!container || !tagsContainer) return;
          const tags = [];
          if (this.searchInput?.value) {
              tags.push({ label: `Busca: ${this.searchInput.value}`, clear: () => {
                  this.searchInput.value = '';
                  this.applyFilters();
              }});
          }
          if (this.vendorFilter?.value !== 'all') {
              const text = this.vendorFilter.selectedOptions[0]?.text;
              tags.push({ label: `Vendor: ${text}`, clear: () => {
                  this.vendorFilter.value = 'all';
                  this.applyFilters();
              }});
          }
          if (this.patchMode !== 'all') {
              const text = this.patchMode === 'available' ? 'Com patch' : 'Sem patch';
              tags.push({ label: `Patch: ${text}`, clear: () => {
                  this.setPatchMode('all');
              }});
          }
          if (this.cvssMin?.value || this.cvssMax?.value) {
              const min = this.cvssMin?.value || '0';
              const max = this.cvssMax?.value || '10';
              tags.push({ label: `CVSS: ${min}-${max}`, clear: () => {
                  if (this.cvssMin) this.cvssMin.value = '';
                  if (this.cvssMax) this.cvssMax.value = '';
                  this.applyFilters();
              }});
          }
          if (tags.length > 0) {
              container.classList.remove('d-none');
              tagsContainer.innerHTML = tags.map((tag, i) => `
                  <span class="filter-tag">
                      ${tag.label}
                      <button class="btn-remove" onclick="window.vulnTable.clearFilter(${i})" aria-label="Remover filtro">
                          <i class="bi bi-x-circle"></i>
                      </button>
                  </span>
              `).join('');
              this.filterCallbacks = tags.map(t => t.clear);
          } else {
              container.classList.add('d-none');
          }
      }
      clearFilter(index) {
          if (this.filterCallbacks && this.filterCallbacks[index]) {
              this.filterCallbacks[index]();
          }
      }
      clearAllFilters() {
          if (this.searchInput) this.searchInput.value = '';
          if (this.vendorFilter) this.vendorFilter.value = 'all';
          this.patchMode = 'all';
          this.updateQuickFilterButtons();
          if (this.cvssMin) this.cvssMin.value = '';
          if (this.cvssMax) this.cvssMax.value = '';
          this.applyFilters();
      }
      initSorting() {
          const sortables = this.table?.querySelectorAll('.sortable') || [];
          sortables.forEach(th => {
              th.addEventListener('click', () => this.sortTable(th));
              th.addEventListener('keydown', (e) => {
                  const key = e.key || e.code;
                  if (key === 'Enter' || key === ' ' || key === 'Spacebar') {
                      e.preventDefault();
                      this.sortTable(th);
                  }
              });
          });
      }
      sortTable(th) {
          const sortKey = th.dataset.sort;
          const tbody = this.table?.querySelector('tbody');
          if (!tbody) return;
          const rows = Array.from(tbody.querySelectorAll('tr'));
          const isAsc = th.classList.contains('asc');
          rows.sort((a, b) => {
              let aVal, bVal;
              switch(sortKey) {
                  case 'cvss':
                      aVal = parseFloat(a.querySelector('.cvss-badge')?.textContent) || 0;
                      bVal = parseFloat(b.querySelector('.cvss-badge')?.textContent) || 0;
                      break;
                  case 'date':
                      aVal = new Date(a.querySelector('time')?.getAttribute('datetime') || 0);
                      bVal = new Date(b.querySelector('time')?.getAttribute('datetime') || 0);
                      break;
                  case 'cve':
                      aVal = a.dataset.cve || '';
                      bVal = b.dataset.cve || '';
                      break;
                  case 'vendor':
                      aVal = a.dataset.vendor || '';
                      bVal = b.dataset.vendor || '';
                      break;
                  default:
                      aVal = a.textContent.trim();
                      bVal = b.textContent.trim();
              }
              if (aVal < bVal) return isAsc ? 1 : -1;
              if (aVal > bVal) return isAsc ? -1 : 1;
              return 0;
          });
          rows.forEach(row => tbody.appendChild(row));
          this.table.querySelectorAll('.sortable').forEach(el => {
              el.classList.remove('asc', 'desc');
              el.setAttribute('aria-sort', 'none');
          });
          th.classList.add(isAsc ? 'desc' : 'asc');
          th.setAttribute('aria-sort', isAsc ? 'descending' : 'ascending');
      }
      initTooltips() {
          const tooltips = document.querySelectorAll('[data-bs-toggle="tooltip"]');
          tooltips.forEach(el => {
              if (window.bootstrap?.Tooltip) {
                  new bootstrap.Tooltip(el);
              }
          });
      }
      initQuickNav() {
          const sections = document.querySelectorAll('section[id]');
          const navLinks = document.querySelectorAll('.quick-nav .nav-link');
          if (sections.length === 0 || navLinks.length === 0) return;
          const observer = new IntersectionObserver((entries) => {
              entries.forEach(entry => {
                  if (entry.isIntersecting) {
                      navLinks.forEach(link => {
                          link.classList.remove('active');
                          if (link.getAttribute('href') === '#' + entry.target.id) {
                              link.classList.add('active');
                          }
                      });
                  }
              });
          }, { threshold: 0.3 });
          sections.forEach(section => observer.observe(section));
      }
      initQuickFilters() {
          if (!this.quickFilterButtons || this.quickFilterButtons.length === 0) return;
          this.quickFilterButtons.forEach(btn => {
              btn.addEventListener('click', () => {
                  const mode = btn.getAttribute('data-patch') || 'all';
                  this.setPatchMode(mode);
              });
          });
      }
      updateQuickFilterButtons(activeBtn) {
          if (!this.quickFilterButtons) return;
          this.quickFilterButtons.forEach(btn => {
              const isActive = activeBtn ? (btn === activeBtn) : (btn.getAttribute('data-patch') === this.patchMode);
              btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
              btn.classList.toggle('active', isActive);
          });
      }
      setPatchMode(mode) {
          this.patchMode = mode || 'all';
          // Update visual state of quick filter buttons
          let activeBtn = null;
          if (this.quickFilterButtons) {
              this.quickFilterButtons.forEach(btn => {
                  if (btn.getAttribute('data-patch') === this.patchMode) activeBtn = btn;
              });
          }
          this.updateQuickFilterButtons(activeBtn);
          this.applyFilters();
      }
      normalizeVendorOptions() {
          if (!this.vendorFilter) return;
          const options = Array.from(this.vendorFilter.querySelectorAll('option'));
          const first = options.shift(); // keep "Todos" first
          const dedup = new Map();
          options.forEach(opt => {
              const key = opt.value.toLowerCase();
              if (!dedup.has(key)) dedup.set(key, opt);
          });
          const sorted = Array.from(dedup.values()).sort((a, b) => {
              return a.text.localeCompare(b.text, undefined, { sensitivity: 'base' });
          });
          this.vendorFilter.innerHTML = '';
          if (first) this.vendorFilter.appendChild(first);
          sorted.forEach(opt => this.vendorFilter.appendChild(opt));
      }
      highlightSearch(term) {
          const rows = this.table?.querySelectorAll('tbody tr') || [];
          const regex = term ? new RegExp(this.escapeRegExp(term), 'gi') : null;
          rows.forEach(row => {
              if (row.style.display === 'none') return;
              const cells = [
                  row.querySelector('td[data-label="CVE ID"] .cve-link'),
                  row.querySelector('td[data-label="Vendor"] .text-truncate'),
                  row.querySelector('td[data-label="Produto"] .text-truncate')
              ];
              cells.forEach(el => {
                  if (!el) return;
                  const text = el.textContent;
                  if (!regex) {
                      el.innerHTML = text; // clear previous marks
                      return;
                  }
                  el.innerHTML = text.replace(regex, (m) => `<mark class="search-mark">${m}</mark>`);
              });
          });
      }
      escapeRegExp(string) {
          return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      }
  }
  // Initialize table
  window.vulnTable = new VulnerabilityTable();
  // Export CSV functionality
  const exportBtn = document.getElementById('downloadCsvBtn');
  if (exportBtn) {
      exportBtn.addEventListener('click', function() {
          const table = document.getElementById('vulnTable');
          if (!table) return;
          const visibleRows = Array.from(table.querySelectorAll('tbody tr'))
              .filter(row => row.style.display !== 'none');
          const headers = ['CVE ID', 'Descrição', 'Vendor', 'Produto', 'CVSS', 'Publicado', 'Patch'];
          const data = visibleRows.map(row => {
              const cells = row.querySelectorAll('td');
              const cvss = row.querySelector('.cvss-badge')?.textContent.trim() || (cells[4]?.textContent.trim() || '');
              const published = cells[5]?.querySelector('time')?.getAttribute('datetime') || (cells[5]?.textContent.trim() || '');
              const patch = (cells[6]?.textContent || '').includes('Disponível') ? 'Sim' : 'Não';
              return [
                  cells[0]?.textContent.trim() || '',
                  cells[1]?.textContent.trim() || '',
                  cells[2]?.textContent.trim() || '',
                  cells[3]?.textContent.trim() || '',
                  cvss,
                  published,
                  patch
              ];
          });
          const csv = [headers, ...data]
              .map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
              .join('\n');
          const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = `vulnerabilidades_${window.severityConfig?.severity || 'unknown'}_${new Date().toISOString().split('T')[0]}.csv`;
          link.click();
      });
  }
  // Clear all filters
  const clearFiltersBtn = document.getElementById('clearFiltersBtn');
  if (clearFiltersBtn) {
      clearFiltersBtn.addEventListener('click', function() {
          window.vulnTable.clearAllFilters();
      });
  }
  // Reset button mirrors clearAllFilters for convenience
  const resetFiltersBtn = document.getElementById('resetTableFilters');
  if (resetFiltersBtn) {
      resetFiltersBtn.addEventListener('click', function() {
          window.vulnTable.clearAllFilters();
      });
  }
  // Density toggle for table
  const densityToggle = document.getElementById('densityToggle');
  const tableEl = document.getElementById('vulnTable');
  const DENSITY_KEY = 'vulnTableDensity';
  const savedDensity = localStorage.getItem(DENSITY_KEY);
  if (tableEl && savedDensity === 'compact') {
      tableEl.classList.add('table-compact');
      if (densityToggle) densityToggle.setAttribute('aria-pressed', 'true');
  }
  if (densityToggle && tableEl) {
      densityToggle.addEventListener('click', () => {
          const isCompact = tableEl.classList.toggle('table-compact');
          localStorage.setItem(DENSITY_KEY, isCompact ? 'compact' : 'normal');
          densityToggle.setAttribute('aria-pressed', isCompact ? 'true' : 'false');
      });
  }
});
