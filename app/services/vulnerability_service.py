
"""
VulnerabilityService handles business logic for querying and managing vulnerability data.

This service provides methods to fetch paginated vulnerabilities, dashboard counts,
and individual vulnerability details, interacting with the database via SQLAlchemy.
"""

import json
from typing import List, Dict, Optional, Tuple
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from sqlalchemy import func, or_, and_
from app.models.vulnerability import Vulnerability


class VulnerabilityService:
    """Service for managing vulnerability-related operations."""

    def __init__(self, session: Session):
        """
        Initialize the service with a database session.

        Args:
            session: SQLAlchemy session for database operations.
        """
        self.session = session



    def get_recent_paginated(self, page: int, per_page: int) -> Tuple[List[Vulnerability], int]:
        """
        Fetch a paginated list of recent vulnerabilities.

        Args:
            page: Page number for pagination (1-based).
            per_page: Number of items per page.

        Returns:
            Tuple containing the list of vulnerabilities and the total count.
        """
        try:
            from sqlalchemy.orm import joinedload
            query = self.session.query(Vulnerability).options(joinedload(Vulnerability.references)).order_by(Vulnerability.published_date.desc())
            # ... existing code ...
            # Aplicar filtro por prefer√™ncias de vendors do usu√°rio, se houver
            try:
                from flask_login import current_user
                from app.models.sync_metadata import SyncMetadata
                from app.models.cve_vendor import CVEVendor
                selected_vendor_ids: List[int] = []
                if current_user.is_authenticated:
                    key = f'user_vendor_preferences:{current_user.id}'
                    pref = self.session.query(SyncMetadata).filter_by(key=key).first()
                    if pref and pref.value:
                        selected_vendor_ids = [int(x) for x in pref.value.split(',') if x.strip().isdigit()]
                if selected_vendor_ids:
                    query = (
                        query
                        .join(CVEVendor, CVEVendor.cve_id == Vulnerability.cve_id)
                        .filter(CVEVendor.vendor_id.in_(selected_vendor_ids))
                        .distinct()
                    )
            except Exception:
                # Se falhar, segue sem filtro
                pass
            total_count = query.count()
            offset = (page - 1) * per_page
            vulnerabilities = query.offset(offset).limit(per_page).all()
            return vulnerabilities, total_count
        except Exception as e:
            raise RuntimeError(f"Error fetching paginated vulnerabilities: {e}")

    def get_dashboard_counts(self) -> Dict[str, int]:
        """
        Retrieve counts of vulnerabilities by severity and total.

        Returns:
            Dictionary with counts for critical, high, medium, and total vulnerabilities.
        """
        try:
            # Base query
            base_query = self.session.query(Vulnerability)
            # ... existing code ...
            # Aplicar filtro por prefer√™ncias de vendors do usu√°rio, se houver
            try:
                from flask_login import current_user
                from app.models.sync_metadata import SyncMetadata
                from app.models.cve_vendor import CVEVendor
                selected_vendor_ids: List[int] = []
                if current_user.is_authenticated:
                    key = f'user_vendor_preferences:{current_user.id}'
                    pref = self.session.query(SyncMetadata).filter_by(key=key).first()
                    if pref and pref.value:
                        selected_vendor_ids = [int(x) for x in pref.value.split(',') if x.strip().isdigit()]
                if selected_vendor_ids:
                    base_query = (
                        base_query
                        .join(CVEVendor, CVEVendor.cve_id == Vulnerability.cve_id)
                        .filter(CVEVendor.vendor_id.in_(selected_vendor_ids))
                        .distinct()
                    )
            except Exception:
                # Se falhar, segue sem filtro
                pass
            counts = {
                'critical': base_query.filter_by(base_severity='CRITICAL').count(),
                'high': base_query.filter_by(base_severity='HIGH').count(),
                'medium': base_query.filter_by(base_severity='MEDIUM').count(),
                'total': base_query.count()
            }
            return counts
        except Exception as e:
            raise RuntimeError(f"Error fetching dashboard counts: {e}")

    def get_vulnerability_by_id(self, cve_id: str) -> Optional[Vulnerability]:
        """
        Fetch a single vulnerability by its CVE ID.

        Args:
            cve_id: The CVE ID of the vulnerability (e.g., 'CVE-2023-12345').

        Returns:
            The Vulnerability object if found, else None.
        """
        try:
            return self.session.query(Vulnerability).filter_by(cve_id=cve_id).first()
        except Exception as e:
            raise RuntimeError(f"Error fetching vulnerability by ID {cve_id}: {e}")
    
    def get_vulnerability_by_cve_id(self, cve_id: str) -> Optional[Vulnerability]:
        """
        Alias for get_vulnerability_by_id for backward compatibility.
        
        Args:
            cve_id: The CVE ID of the vulnerability (e.g., 'CVE-2023-12345').
            
        Returns:
            The Vulnerability object if found, else None.
        """
        return self.get_vulnerability_by_id(cve_id)
    
    def get_vulnerability_with_details(self, cve_id: str) -> Optional[Vulnerability]:
        """
        Fetch a vulnerability with all related data using eager loading.
        
        Args:
            cve_id: The CVE ID of the vulnerability (e.g., 'CVE-2023-12345').
            
        Returns:
            The Vulnerability object with all related data loaded, or None if not found.
        """
        try:
            from sqlalchemy.orm import joinedload, selectinload
            from app.models.cve_vendor import CVEVendor
            from app.models.cve_product import CVEProduct
            from app.models.vendor import Vendor
            from app.models.product import Product
            
            # Use eager loading to fetch all related data
            vulnerability = self.session.query(Vulnerability).options(
                joinedload(Vulnerability.metrics),
                joinedload(Vulnerability.severity_metrics),
                # selectinload(Vulnerability.vendors).joinedload(CVEVendor.vendor),
                selectinload(Vulnerability.products).joinedload(CVEProduct.product),
                joinedload(Vulnerability.weaknesses),
                joinedload(Vulnerability.references),
                joinedload(Vulnerability.affected_products),
                joinedload(Vulnerability.version_references)
            ).filter_by(cve_id=cve_id).first()
            
            return vulnerability
        except Exception as e:
            raise RuntimeError(f"Error fetching vulnerability with details for {cve_id}: {e}")

    def get_weekly_counts(self) -> Dict[str, int]:
        """
        Retrieve counts of vulnerabilities published in the last 7 days by severity.

        Returns:
            Dictionary with weekly counts for critical, high, medium, and total vulnerabilities.
        """
        try:
            # Calculate date 7 days ago
            week_ago = datetime.now() - timedelta(days=7)
            
            # Base query for vulnerabilities from last week
            base_query = self.session.query(Vulnerability).filter(
                Vulnerability.published_date >= week_ago
            )
            
            counts = {
                'critical': base_query.filter_by(base_severity='CRITICAL').count(),
                'high': base_query.filter_by(base_severity='HIGH').count(),
                'medium': base_query.filter_by(base_severity='MEDIUM').count(),
                'total': base_query.count()
            }
            return counts
        except Exception as e:
            raise RuntimeError(f"Error fetching weekly vulnerability counts: {e}")

    def get_vulnerability_analytics(self, cve_id: str) -> Dict:
        """
        Get comprehensive analytics data for a specific vulnerability.

        Args:
            cve_id: The CVE ID of the vulnerability.

        Returns:
            Dictionary containing analytics data including affected assets, timeline, etc.
        """
        try:
            vulnerability = self.get_vulnerability_by_id(cve_id)
            if not vulnerability:
                return {}

            # Get affected assets count
            from app.models.asset_vulnerability import AssetVulnerability
            affected_assets_count = self.session.query(AssetVulnerability).filter_by(
                vulnerability_id=vulnerability.cve_id
            ).count()

            # Get severity distribution for similar vulnerabilities
            similar_vulns = self.session.query(Vulnerability).filter(
                Vulnerability.base_severity == vulnerability.base_severity
            ).count()

            # Calculate risk score based on CVSS and affected assets
            risk_score = 0
            if vulnerability.cvss_score:
                risk_score = vulnerability.cvss_score * (1 + (affected_assets_count * 0.1))
                risk_score = min(risk_score, 10.0)  # Cap at 10.0

            analytics = {
                'vulnerability': vulnerability,
                'affected_assets_count': affected_assets_count,
                'similar_vulnerabilities_count': similar_vulns,
                'calculated_risk_score': round(risk_score, 1),
                'severity_level': vulnerability.base_severity,
                'cvss_score': vulnerability.cvss_score,
                'published_date': vulnerability.published_date,
                'last_modified': vulnerability.last_update,
                'current_date': datetime.now()
            }

            return analytics
        except Exception as e:
            raise RuntimeError(f"Error fetching vulnerability analytics for {cve_id}: {e}")

    def save_vulnerabilities_batch(self, vulnerabilities_data: List[Dict]) -> int:
        """
        Save a batch of vulnerabilities to the database with detailed feedback.
        
        Args:
            vulnerabilities_data: List of dictionaries containing vulnerability data
            
        Returns:
            Number of vulnerabilities successfully saved
        """
        try:
            from app.models.cvss_metric import CVSSMetric
            from app.utils.terminal_feedback import terminal_feedback
            import time
            
            start_time = time.time()
            saved_count = 0
            updated_count = 0
            error_count = 0
            normalized_count = 0
            
            terminal_feedback.info(f"üíæ Iniciando grava√ß√£o de {len(vulnerabilities_data)} CVEs no banco de dados")
            
            for idx, vuln_data in enumerate(vulnerabilities_data):
                cve_id = vuln_data.get('cve_id', f'unknown_{idx}')
                
                try:
                    # Salvar dados diretos da API NVD sem normaliza√ß√£o
                    nvd_data = {}
                    if 'vendors' in vuln_data and vuln_data['vendors']:
                        nvd_data['nvd_vendors_data'] = vuln_data['vendors']
                        terminal_feedback.info(f"üìä Salvando {len(vuln_data['vendors'])} vendors diretos para {cve_id}")
                    
                    if 'products' in vuln_data and vuln_data['products']:
                        nvd_data['nvd_products_data'] = vuln_data['products']
                        terminal_feedback.info(f"üì¶ Salvando {len(vuln_data['products'])} produtos diretos para {cve_id}")
                    
                    if 'cpe_configurations' in vuln_data and vuln_data['cpe_configurations']:
                        nvd_data['nvd_cpe_configurations'] = vuln_data['cpe_configurations']
                        terminal_feedback.info(f"üîß Salvando configura√ß√µes CPE diretas para {cve_id}")
                    
                    if 'version_ranges' in vuln_data and vuln_data['version_ranges']:
                        nvd_data['nvd_version_ranges'] = vuln_data['version_ranges']
                        terminal_feedback.info(f"üìã Salvando {len(vuln_data['version_ranges'])} vers√µes diretas para {cve_id}")
                    
                    # Check if vulnerability already exists
                    existing_vuln = self.session.query(Vulnerability).filter_by(
                        cve_id=vuln_data['cve_id']
                    ).first()
                    
                    if existing_vuln:
                        # Update existing vulnerability
                        terminal_feedback.info(f"üîÑ Atualizando CVE existente: {cve_id}")
                        for key, value in vuln_data.items():
                            if key not in ['cvss_metrics', 'vendors', 'products', 'weaknesses', 'references', 'version_ranges', 'cpe_configurations']:  # Skip fields that don't belong to model
                                setattr(existing_vuln, key, value)
                        # Atualizar dados NVD diretos
                        for key, value in nvd_data.items():
                            setattr(existing_vuln, key, value)
                        vulnerability = existing_vuln
                        updated_count += 1
                    else:
                        # Create new vulnerability
                        terminal_feedback.success(f"‚úÖ Criando nova CVE: {cve_id}")
                        # Remove fields that don't belong to Vulnerability model
                        vuln_dict = {k: v for k, v in vuln_data.items() 
                                    if k not in ['cvss_metrics', 'vendors', 'products', 'weaknesses', 'references', 'version_ranges', 'cpe_configurations']}
                        # Adicionar dados NVD diretos
                        vuln_dict.update(nvd_data)
                        vulnerability = Vulnerability(**vuln_dict)
                        self.session.add(vulnerability)
                        saved_count += 1
                
                    # Criar associa√ß√µes normalizadas CVE‚ÜîVendor/Product para suportar vincula√ß√£o a ativos
                    try:
                        if 'vendors' in vuln_data and vuln_data['vendors']:
                            terminal_feedback.info(f"üè∑Ô∏è Normalizando vendors para {cve_id}")
                            self._process_vendors(vulnerability.cve_id, vuln_data['vendors'])
                            # Incrementa contagem de normaliza√ß√µes com base na quantidade de vendors
                            try:
                                normalized_count += len(vuln_data['vendors'])
                            except Exception:
                                normalized_count += 1
                        if 'products' in vuln_data and vuln_data['products']:
                            terminal_feedback.info(f"üè∑Ô∏è Normalizando products para {cve_id}")
                            self._process_products(vulnerability.cve_id, vuln_data['products'])
                            # Incrementa contagem de normaliza√ß√µes com base na quantidade de produtos
                            try:
                                normalized_count += len(vuln_data['products'])
                            except Exception:
                                normalized_count += 1
                    except Exception as assoc_err:
                        # N√£o falhar o processamento da CVE por erro de associa√ß√£o; registrar e continuar
                        terminal_feedback.warning(f"‚ö†Ô∏è Falha ao normalizar vendors/products para {cve_id}: {assoc_err}")
                        
                    # Handle CVSS metrics
                    if 'cvss_metrics' in vuln_data and vuln_data['cvss_metrics']:
                        terminal_feedback.info(f"üìä Processando m√©tricas CVSS para {cve_id}")
                        # Remove existing metrics for this vulnerability
                        self.session.query(CVSSMetric).filter_by(
                            cve_id=vulnerability.cve_id
                        ).delete()
                        
                        # Add new metrics
                        for metric_data in vuln_data['cvss_metrics']:
                            metric_data['cve_id'] = vulnerability.cve_id
                            metric = CVSSMetric(**metric_data)
                            self.session.add(metric)
                    
                    # Dados de vendors e products agora s√£o salvos diretamente nos campos JSON
                    # N√£o √© mais necess√°rio processar separadamente
                    
                    # Handle weaknesses (CWEs)
                    if 'weaknesses' in vuln_data and vuln_data['weaknesses']:
                        terminal_feedback.info(f"üîç Processando {len(vuln_data['weaknesses'])} CWEs para {cve_id}")
                        self._process_weaknesses(vulnerability.cve_id, vuln_data['weaknesses'])
                    
                    # Handle references
                    if 'references' in vuln_data and vuln_data['references']:
                        terminal_feedback.info(f"üîó Processando {len(vuln_data['references'])} refer√™ncias para {cve_id}")
                        self._process_references(vulnerability.cve_id, vuln_data['references'])
                    
                    # Handle version ranges
                    if 'version_ranges' in vuln_data and vuln_data['version_ranges']:
                        terminal_feedback.info(f"üìã Processando {len(vuln_data['version_ranges'])} vers√µes para {cve_id}")
                        self._process_version_ranges(vulnerability.cve_id, vuln_data['version_ranges'])
                    
                    terminal_feedback.success(f"‚úÖ CVE {cve_id} gravada com sucesso no banco de dados")
                    
                except Exception as cve_error:
                    error_count += 1
                    terminal_feedback.error(f"‚ùå Erro ao processar CVE {cve_id}: {str(cve_error)}")
                    continue
            
            # Commit das altera√ß√µes
            self.session.commit()
            
            # Feedback final detalhado
            duration = time.time() - start_time
            total_processed = saved_count + updated_count
            
            terminal_feedback.success(
                f"üíæ Lote gravado com sucesso!", 
                {
                    "novas_cves": saved_count,
                    "cves_atualizadas": updated_count,
                    "total_processadas": total_processed,
                    "normalizacoes_aplicadas": normalized_count,
                    "erros": error_count,
                    "duracao": f"{duration:.2f}s",
                    "taxa_sucesso": f"{((total_processed / len(vulnerabilities_data)) * 100):.1f}%"
                }
            )
            
            return total_processed
            
        except Exception as e:
            self.session.rollback()
            terminal_feedback.error(f"‚ùå Erro cr√≠tico ao salvar lote de vulnerabilidades: {str(e)}")
            raise RuntimeError(f"Error saving vulnerabilities batch: {e}")

    def get_last_sync_time(self) -> Optional[datetime]:
        """
        Retorna o melhor timestamp conhecido da √∫ltima sincroniza√ß√£o.
        
        Prefer√™ncia:
        1) SyncMetadata 'nvd_last_sync' com status conclu√≠do
        2) Caso n√£o exista ou esteja inv√°lido, usa o timestamp da √∫ltima CVE cadastrada (Vulnerability.last_update)
        """
        try:
            from app.models.sync_metadata import SyncMetadata
            # Tenta usar metadata de sincroniza√ß√£o primeiro
            sync_record = self.session.query(SyncMetadata).filter_by(
                key='nvd_last_sync'
            ).first()
            
            # Se uma sincroniza√ß√£o estiver em andamento, ignorar metadata e usar fallback
            if sync_record and getattr(sync_record, 'status', None) == 'in_progress':
                sync_record = None

            if sync_record and getattr(sync_record, 'value', None):
                # Converter string ISO para datetime
                from datetime import datetime
                try:
                    return datetime.fromisoformat(sync_record.value.replace('Z', '+00:00'))
                except ValueError:
                    # Valor inv√°lido no metadata ‚Äî prosseguir para o fallback
                    pass
            
            # Fallback: usar data da √∫ltima CVE cadastrada
            from app.models.vulnerability import Vulnerability
            last_cve_update = self.session.query(func.max(Vulnerability.last_update)).scalar()
            if last_cve_update:
                return last_cve_update
            
            return None
            
        except Exception as e:
            raise RuntimeError(f"Error fetching last sync time: {e}")

    def get_vulnerabilities_last_week_by_severity(self, severity: str) -> Dict:
        """
        Get vulnerabilities from the last week filtered by severity.

        Args:
            severity: The severity level to filter by
            
        Returns:
            Dictionary containing vulnerabilities list and total count
        """
        try:
            # Calculate date 7 days ago
            week_ago = datetime.now() - timedelta(days=7)
            
            # Query vulnerabilities from last week with specified severity
            query = self.session.query(Vulnerability).filter(
                Vulnerability.published_date >= week_ago,
                Vulnerability.base_severity == severity.upper()
            ).order_by(Vulnerability.published_date.desc())
            
            vulnerabilities = query.all()
            total_count = query.count()
            
            return {
                'vulnerabilities': vulnerabilities,
                'total_count': total_count
            }
        except Exception as e:
            raise RuntimeError(f"Error fetching vulnerabilities for last week by severity {severity}: {e}")

    def get_weekly_statistics_by_severity(self, severity: str) -> Dict:
        """
        Get weekly statistics for vulnerabilities of a specific severity.

        Args:
            severity: The severity level to analyze
            
        Returns:
            Dictionary containing various statistics and charts data
        """
        try:
            # Calculate date ranges
            week_ago = datetime.now() - timedelta(days=7)
            month_ago = datetime.now() - timedelta(days=30)
            
            # Base query for this severity
            base_query = self.session.query(Vulnerability).filter(
                Vulnerability.base_severity == severity.upper()
            )
            
            # Weekly count
            weekly_count = base_query.filter(
                or_(
                    Vulnerability.published_date >= week_ago,
                    Vulnerability.last_update >= week_ago
                )
            ).count()
            
            # Monthly count
            monthly_count = base_query.filter(
                or_(
                    Vulnerability.published_date >= month_ago,
                    Vulnerability.last_update >= month_ago
                )
            ).count()
            
            # Total count for this severity
            total_count = base_query.count()
            
            # Daily distribution for the last 7 days
            daily_data = []
            for i in range(7):
                day_start = datetime.now() - timedelta(days=i+1)
                day_end = datetime.now() - timedelta(days=i)
                
                day_count = base_query.filter(
                    or_(
                        and_(
                            Vulnerability.published_date >= day_start,
                            Vulnerability.published_date < day_end
                        ),
                        and_(
                            Vulnerability.last_update >= day_start,
                            Vulnerability.last_update < day_end
                        )
                    )
                ).count()
                
                daily_data.append({
                    'date': day_start.strftime('%Y-%m-%d'),
                    'count': day_count
                })
            
            # Reverse to show chronological order
            daily_data.reverse()
            
            # CVSS score distribution for this severity
            cvss_ranges = {
                '0.0-3.9': 0,
                '4.0-6.9': 0,
                '7.0-8.9': 0,
                '9.0-10.0': 0
            }

            # Restrict CVSS distribution to last 7 days (weekly window)
            cvss_data = base_query.filter(
                or_(
                    Vulnerability.published_date >= week_ago,
                    Vulnerability.last_update >= week_ago
                ),
                Vulnerability.cvss_score.isnot(None)
            ).all()
            
            for vuln in cvss_data:
                score = vuln.cvss_score
                if score < 4.0:
                    cvss_ranges['0.0-3.9'] += 1
                elif score < 7.0:
                    cvss_ranges['4.0-6.9'] += 1
                elif score < 9.0:
                    cvss_ranges['7.0-8.9'] += 1
                else:
                    cvss_ranges['9.0-10.0'] += 1
            
            # Top affected products (prefer structured associations, fallback to description analysis)
            top_products = []
            try:
                from app.models.affected_product import AffectedProduct
                from app.models.product import Product
                
                top_products_query = (
                    self.session.query(
                        Product.name,
                        func.count(AffectedProduct.product_id).label('count')
                    )
                    .join(AffectedProduct, Product.id == AffectedProduct.product_id)
                    .join(Vulnerability, Vulnerability.cve_id == AffectedProduct.vulnerability_id)
                    .filter(
                        Vulnerability.base_severity == severity.upper(),
                        Vulnerability.published_date >= month_ago
                    )
                    .group_by(Product.name)
                    .order_by(func.count(AffectedProduct.product_id).desc())
                    .limit(10)
                    .all()
                )
                
                # Convert to list of (name, count) pairs compatible with frontend normalization
                top_products = [(name, int(count)) for name, count in top_products_query]
            except Exception:
                # Fallback handled below if needed
                top_products = []
            
            if not top_products:
                # Fallback: simple keyword extraction from descriptions
                products_analysis = {}
                recent_vulns = base_query.filter(
                    Vulnerability.published_date >= month_ago
                ).all()
                
                common_products = ['windows', 'linux', 'apache', 'nginx', 'mysql', 'postgresql', 'php', 'java', 'python', 'node']
                for vuln in recent_vulns:
                    if vuln.description:
                        desc_lower = vuln.description.lower()
                        for product in common_products:
                            if product in desc_lower:
                                products_analysis[product] = products_analysis.get(product, 0) + 1
                
                # Sort products by frequency and keep Top 10
                top_products = sorted(products_analysis.items(), key=lambda x: x[1], reverse=True)[:10]
            
            return {
                'weekly_count': weekly_count,
                'monthly_count': monthly_count,
                'total_count': total_count,
                'daily_distribution': daily_data,
                'cvss_distribution': cvss_ranges,
                'top_products': top_products,
                'severity': severity.upper()
            }
        except Exception as e:
            raise RuntimeError(f"Error fetching weekly statistics for severity {severity}: {e}")

    def get_weekly_cvss_distribution_all(self) -> Dict[str, int]:
        """
        Get CVSS score distribution for all vulnerabilities published in the last 7 days.

        Returns:
            Dictionary mapping CVSS ranges to counts for the weekly window across all severities.
        """
        try:
            week_ago = datetime.now() - timedelta(days=7)
            cvss_ranges = {
                '0.0-3.9': 0,
                '4.0-6.9': 0,
                '7.0-8.9': 0,
                '9.0-10.0': 0
            }

            query = self.session.query(Vulnerability).filter(
                or_(
                    Vulnerability.published_date >= week_ago,
                    Vulnerability.last_update >= week_ago
                ),
                Vulnerability.cvss_score.isnot(None)
            ).all()

            for vuln in query:
                score = vuln.cvss_score
                if score < 4.0:
                    cvss_ranges['0.0-3.9'] += 1
                elif score < 7.0:
                    cvss_ranges['4.0-6.9'] += 1
                elif score < 9.0:
                    cvss_ranges['7.0-8.9'] += 1
                else:
                    cvss_ranges['9.0-10.0'] += 1

            return cvss_ranges
        except Exception as e:
            raise RuntimeError(f"Error fetching weekly CVSS distribution for all severities: {e}")

    def get_cvss_distribution_by_severity_all(self, severity: str) -> Dict[str, int]:
        """
        Get CVSS score distribution for all CVEs of a given severity (no date restriction).

        Args:
            severity: Severity level (e.g., 'CRITICAL', 'HIGH', 'MEDIUM', 'LOW').

        Returns:
            Dictionary mapping CVSS ranges to counts across ALL records for that severity.
        """
        try:
            cvss_ranges = {
                '0.0-3.9': 0,
                '4.0-6.9': 0,
                '7.0-8.9': 0,
                '9.0-10.0': 0
            }

            query = self.session.query(Vulnerability).filter(
                Vulnerability.base_severity == severity.upper(),
                Vulnerability.cvss_score.isnot(None)
            ).all()

            for vuln in query:
                score = float(vuln.cvss_score)
                if score < 4.0:
                    cvss_ranges['0.0-3.9'] += 1
                elif score < 7.0:
                    cvss_ranges['4.0-6.9'] += 1
                elif score < 9.0:
                    cvss_ranges['7.0-8.9'] += 1
                else:
                    cvss_ranges['9.0-10.0'] += 1

            return cvss_ranges
        except Exception as e:
            raise RuntimeError(f"Error fetching ALL-time CVSS distribution for severity {severity}: {e}")
    
    def update_last_sync_time(self, sync_time: datetime) -> None:
        """
        Update the last synchronization time in sync metadata.
        
        Args:
            sync_time: The datetime to set as the last sync time
        """
        try:
            from app.models.sync_metadata import SyncMetadata
            sync_record = self.session.query(SyncMetadata).filter_by(
                key='nvd_last_sync'
            ).first()
            
            # Convert datetime to ISO string
            sync_time_str = sync_time.isoformat(timespec='milliseconds').replace('+00:00', 'Z')
            
            if sync_record:
                sync_record.value = sync_time_str
                # Mark sync as completed and update last_modified
                sync_record.status = 'completed'
                sync_record.last_modified = sync_time
            else:
                # Create new sync record if it doesn't exist
                sync_record = SyncMetadata(
                    key='nvd_last_sync',
                    value=sync_time_str,
                    status='completed',
                    last_modified=sync_time
                )
                self.session.add(sync_record)
            
            self.session.commit()
            
        except Exception as e:
            self.session.rollback()
            raise RuntimeError(f"Error updating last sync time: {e}")

    def ensure_vendor_associations_for_vendor(self, vendor_name: str, limit: int = 10000) -> int:
        """Garante que existam associa√ß√µes CVEVendor para um determinado vendor, usando dados JSON NVD.
        Retorna o n√∫mero de associa√ß√µes criadas.
        """
        try:
            from sqlalchemy import func, text
            from app.models.vendor import Vendor
            from app.models.cve_vendor import CVEVendor
            from app.models.vulnerability import Vulnerability
            # Encontrar ou criar vendor
            vendor = self.session.query(Vendor).filter(func.lower(Vendor.name) == vendor_name.lower()).first()
            if not vendor:
                vendor = Vendor(name=vendor_name)
                self.session.add(vendor)
                self.session.flush()

            # Coletar CVEs j√° associadas
            existing = set(
                row[0] for row in self.session.query(CVEVendor.cve_id).filter(CVEVendor.vendor_id == vendor.id).all()
            )

            # Procurar CVEs pelo JSON de vendors (com fallback Python)
            sql = """
                SELECT v.cve_id
                FROM vulnerabilities v, json_each(v.nvd_vendors_data) AS vendor_data
                WHERE v.nvd_vendors_data IS NOT NULL
                  AND (
                      LOWER(vendor_data.value) = LOWER(:vendor_name)
                      OR LOWER(json_extract(vendor_data.value, '$.name')) = LOWER(:vendor_name)
                  )
                LIMIT :limit
            """
            cve_ids = []
            try:
                result = self.session.execute(text(sql), {"vendor_name": vendor_name, "limit": limit})
                cve_ids = [row[0] for row in result.fetchall()]
            except Exception:
                # Fallback Python: varrer vulnerabilidades e comparar vendor no dado JSON
                vname = vendor_name.lower()
                vulns = (
                    self.session.query(Vulnerability)
                    .filter(Vulnerability.nvd_vendors_data.isnot(None))
                    .limit(limit)
                    .all()
                )
                tmp_ids = []
                for v in vulns:
                    data = v.nvd_vendors_data
                    parsed = data
                    if isinstance(data, str):
                        try:
                            parsed = json.loads(data)
                        except Exception:
                            parsed = data

                    names = []
                    if isinstance(parsed, list):
                        for item in parsed:
                            if isinstance(item, str):
                                names.append(item)
                            elif isinstance(item, dict):
                                val = item.get('name') or item.get('vendor') or item.get('vendor_name')
                                if val:
                                    names.append(val)
                    elif isinstance(parsed, dict):
                        if 'vendors' in parsed and isinstance(parsed['vendors'], list):
                            for itm in parsed['vendors']:
                                if isinstance(itm, str):
                                    names.append(itm)
                                elif isinstance(itm, dict):
                                    val = itm.get('name') or itm.get('vendor') or itm.get('vendor_name')
                                    if val:
                                        names.append(val)
                        elif 'name' in parsed:
                            names.append(parsed['name'])
                        else:
                            for key in parsed.keys():
                                if isinstance(key, str):
                                    names.append(key)
                    elif isinstance(parsed, str):
                        names.append(parsed)

                    for nm in names:
                        if isinstance(nm, str) and nm.strip().lower() == vname:
                            tmp_ids.append(v.cve_id)
                            break

                # Deduplicar mantendo ordem
                cve_ids = list(dict.fromkeys(tmp_ids))

            created = 0
            for cve_id in cve_ids:
                if cve_id in existing:
                    continue
                self.session.add(CVEVendor(cve_id=cve_id, vendor_id=vendor.id))
                created += 1

            if created > 0:
                self.session.flush()
                self.session.commit()
            return created
        except Exception as e:
            self.session.rollback()
            # N√£o propagar erro cr√≠tico; retornar zero e permitir fallback
            return 0
    
    def _process_vendors(self, cve_id: str, vendors: List[str]) -> None:
        """Process and save vendor data for a CVE."""
        try:
            from app.models.vendor import Vendor
            from app.models.cve_vendor import CVEVendor
            
            # Remove existing vendor associations for this CVE
            self.session.query(CVEVendor).filter_by(cve_id=cve_id).delete()
            
            for vendor_name in vendors:
                # Check if vendor exists, create if not
                vendor = self.session.query(Vendor).filter_by(name=vendor_name).first()
                if not vendor:
                    vendor = Vendor(name=vendor_name)
                    self.session.add(vendor)
                    self.session.flush()  # Get the ID
                
                # Create CVE-Vendor association
                cve_vendor = CVEVendor(cve_id=cve_id, vendor_id=vendor.id)
                self.session.add(cve_vendor)
                
        except Exception as e:
            raise RuntimeError(f"Error processing vendors for {cve_id}: {e}")
    
    def _process_products(self, cve_id: str, products: List[str]) -> None:
        """Process and save product data for a CVE."""
        try:
            from app.models.product import Product
            from app.models.cve_product import CVEProduct
            from app.models.vendor import Vendor
            
            # Remove existing product associations for this CVE
            self.session.query(CVEProduct).filter_by(cve_id=cve_id).delete()
            
            for product_name in products:
                # Check if product exists, create if not
                product = self.session.query(Product).filter_by(name=product_name).first()
                if not product:
                    # Get or create a default vendor for unknown products
                    default_vendor = self.session.query(Vendor).filter_by(name='Unknown').first()
                    if not default_vendor:
                        default_vendor = Vendor(name='Unknown')
                        self.session.add(default_vendor)
                        self.session.flush()  # Get the ID
                    
                    product = Product(name=product_name, vendor_id=default_vendor.id)
                    self.session.add(product)
                    self.session.flush()  # Get the ID
                
                # Create CVE-Product association
                cve_product = CVEProduct(cve_id=cve_id, product_id=product.id)
                self.session.add(cve_product)
                
        except Exception as e:
            raise RuntimeError(f"Error processing products for {cve_id}: {e}")
    
    def _process_weaknesses(self, cve_id: str, weaknesses: List[str]) -> None:
        """Process and save weakness (CWE) data for a CVE."""
        try:
            from app.models.weakness import Weakness
            
            # Remove existing weakness associations for this CVE
            self.session.query(Weakness).filter_by(cve_id=cve_id).delete()
            
            for cwe_id in weaknesses:
                # Create weakness association
                weakness = Weakness(cve_id=cve_id, cwe_id=cwe_id)
                self.session.add(weakness)
                
        except Exception as e:
            raise RuntimeError(f"Error processing weaknesses for {cve_id}: {e}")
    
    def _process_references(self, cve_id: str, references: List[Dict]) -> None:
        """
        Process and save references for a CVE.
        
        Args:
            cve_id: CVE identifier
            references: List of reference dictionaries with url, source, tags
        """
        try:
            from app.models.references import Reference
            
            # Remove existing references for this CVE
            self.session.query(Reference).filter_by(cve_id=cve_id).delete()
            
            # Add new references
            for ref_data in references:
                url = ref_data.get('url')
                source = ref_data.get('source')
                tags = ref_data.get('tags', [])
                
                if url:
                    # Convert tags list to comma-separated string
                    tags_str = ', '.join(tags) if tags else None
                    
                    # Check if this reference indicates a patch
                    patch_tags = ['Patch', 'Vendor Advisory', 'Mitigation', 'Fix']
                    is_patch = any(tag in tags for tag in patch_tags) if tags else False
                    
                    reference = Reference(
                        cve_id=cve_id,
                        url=url,
                        source=source,
                        tags=tags_str,
                        is_patch=is_patch
                    )
                    self.session.add(reference)
        
        except Exception as e:
            raise RuntimeError(f"Error processing version ranges for {cve_id}: {e}")
    
    def _process_version_ranges(self, cve_id: str, version_ranges: List[Dict]):
        """
        Process and save version range information for a vulnerability.
        
        Args:
            cve_id: The CVE ID
            version_ranges: List of version range dictionaries
        """
        try:
            from app.models.version_reference import VersionReference
            from app.models.affected_product import AffectedProduct
            from app.models.product import Product
            
            # Remove existing version references for this CVE
            self.session.query(VersionReference).filter_by(cve_id=cve_id).delete()
            
            # Process each version range
            for version_range in version_ranges:
                vendor = version_range.get('vendor')
                product_name = version_range.get('product')
                
                if not vendor or not product_name:
                    continue
                
                # Find or create vendor first
                from app.models.vendor import Vendor
                vendor_obj = self.session.query(Vendor).filter_by(name=vendor).first()
                if not vendor_obj:
                    vendor_obj = Vendor(name=vendor)
                    self.session.add(vendor_obj)
                    self.session.flush()  # Get the ID
                
                # Find or create product
                product = self.session.query(Product).filter_by(
                    name=product_name,
                    vendor_id=vendor_obj.id
                ).first()
                
                if not product:
                    product = Product(name=product_name, vendor_id=vendor_obj.id)
                    self.session.add(product)
                    self.session.flush()  # Get the ID
                
                # Create version reference only if we have a valid affected version
                affected_version = version_range.get('version')
                if not affected_version:
                    # If no specific version, use version range info to construct one
                    if version_range.get('version_start_including'):
                        affected_version = f">= {version_range['version_start_including']}"
                    elif version_range.get('version_start_excluding'):
                        affected_version = f"> {version_range['version_start_excluding']}"
                    elif version_range.get('version_end_including'):
                        affected_version = f"<= {version_range['version_end_including']}"
                    elif version_range.get('version_end_excluding'):
                        affected_version = f"< {version_range['version_end_excluding']}"
                    else:
                        affected_version = "*"  # Fallback for unknown version
                
                version_ref = VersionReference(
                    cve_id=cve_id,
                    product_id=product.id,
                    affected_version=affected_version,
                    fixed_version=None  # Will be determined from version ranges
                )
                
                # Determine fixed version from version ranges
                if version_range.get('version_end_including'):
                    version_ref.fixed_version = version_range.get('version_end_including')
                elif version_range.get('version_end_excluding'):
                    version_ref.fixed_version = version_range.get('version_end_excluding')
                
                self.session.add(version_ref)
                
                # Create or update affected product entry
                affected_product = self.session.query(AffectedProduct).filter_by(
                    vulnerability_id=cve_id,
                    product_id=product.id
                ).first()
                
                if not affected_product:
                    # Build affected versions string from version range
                    affected_versions_parts = []
                    
                    if version_range.get('version'):
                        affected_versions_parts.append(f"v{version_range['version']}")
                    
                    if version_range.get('version_start_including'):
                        affected_versions_parts.append(f">= {version_range['version_start_including']}")
                    elif version_range.get('version_start_excluding'):
                        affected_versions_parts.append(f"> {version_range['version_start_excluding']}")
                    
                    if version_range.get('version_end_including'):
                        affected_versions_parts.append(f"<= {version_range['version_end_including']}")
                    elif version_range.get('version_end_excluding'):
                        affected_versions_parts.append(f"< {version_range['version_end_excluding']}")
                    
                    affected_versions_str = ", ".join(affected_versions_parts) if affected_versions_parts else None
                    
                    affected_product = AffectedProduct(
                        vulnerability_id=cve_id,
                        product_id=product.id,
                        affected_versions=affected_versions_str
                    )
                    self.session.add(affected_product)
            
        except Exception as e:
            raise RuntimeError(f"Error processing references for {cve_id}: {e}")

    def sync_asset_vulnerabilities_for_asset(self, asset_id: int, limit_per_asset: int = 1000) -> int:
        """Create AssetVulnerability links for a single asset based on its vendor.
        Returns number of created associations.
        """
        from app.models.asset import Asset
        from app.models.asset_vulnerability import AssetVulnerability
        from app.models.cve_vendor import CVEVendor

        created_count = 0
        asset = self.session.query(Asset).get(asset_id)
        if not asset or not asset.vendor_id:
            return 0

        # Fetch CVEs associated with this asset's vendor
        cve_query = self.session.query(CVEVendor.cve_id).filter(CVEVendor.vendor_id == asset.vendor_id)
        if limit_per_asset and limit_per_asset > 0:
            cve_query = cve_query.limit(limit_per_asset)
        cve_ids = [row[0] for row in cve_query.all()]

        # Fallback: use JSON vendors data (NVD) if CVEVendor associations are not populated
        if not cve_ids:
            from sqlalchemy import text
            from app.models.vulnerability import Vulnerability  # ensure model is loaded
            vendor_name = asset.vendor.name if asset.vendor else None
            if vendor_name:
                # Tentar criar associa√ß√µes CVEVendor a partir dos dados JSON antes de consultar
                try:
                    self.ensure_vendor_associations_for_vendor(vendor_name, limit=(limit_per_asset or 1000))
                    # Reconsultar associa√ß√µes CVEVendor ap√≥s backfill
                    cve_ids = [row[0] for row in self.session.query(CVEVendor.cve_id)
                               .filter(CVEVendor.vendor_id == asset.vendor_id)
                               .limit(limit_per_asset or 1000)
                               .all()]
                except Exception:
                    # Prosseguir com fallback SQL
                    pass

                sql = """
                SELECT v.cve_id
                FROM vulnerabilities v, json_each(v.nvd_vendors_data) AS vendor_data
                WHERE v.nvd_vendors_data IS NOT NULL
                  AND (
                      LOWER(vendor_data.value) = LOWER(:vendor_name)
                      OR LOWER(json_extract(vendor_data.value, '$.name')) = LOWER(:vendor_name)
                  )
                LIMIT :limit
                """
                try:
                    result = self.session.execute(text(sql), {
                        "vendor_name": vendor_name,
                        "limit": (limit_per_asset or 1000)
                    })
                    cve_ids = [row[0] for row in result.fetchall()]
                except Exception:
                    # Fallback Python quando JSON1 n√£o est√° dispon√≠vel
                    from app.models.vulnerability import Vulnerability
                    vname = vendor_name.lower()
                    vulns = (
                        self.session.query(Vulnerability)
                        .filter(Vulnerability.nvd_vendors_data.isnot(None))
                        .limit(limit_per_asset or 1000)
                        .all()
                    )
                    tmp_ids = []
                    for v in vulns:
                        data = v.nvd_vendors_data
                        parsed = data
                        if isinstance(data, str):
                            try:
                                parsed = json.loads(data)
                            except Exception:
                                parsed = data

                        names = []
                        if isinstance(parsed, list):
                            for item in parsed:
                                if isinstance(item, str):
                                    names.append(item)
                                elif isinstance(item, dict):
                                    val = item.get('name') or item.get('vendor') or item.get('vendor_name')
                                    if val:
                                        names.append(val)
                        elif isinstance(parsed, dict):
                            if 'vendors' in parsed and isinstance(parsed['vendors'], list):
                                for itm in parsed['vendors']:
                                    if isinstance(itm, str):
                                        names.append(itm)
                                    elif isinstance(itm, dict):
                                        val = itm.get('name') or itm.get('vendor') or itm.get('vendor_name')
                                        if val:
                                            names.append(val)
                            elif 'name' in parsed:
                                names.append(parsed['name'])
                            else:
                                for key in parsed.keys():
                                    if isinstance(key, str):
                                        names.append(key)
                        elif isinstance(parsed, str):
                            names.append(parsed)

                        for nm in names:
                            if isinstance(nm, str) and nm.strip().lower() == vname:
                                tmp_ids.append(v.cve_id)
                                break

                    cve_ids = list(dict.fromkeys(tmp_ids))

        if not cve_ids:
            return 0

        # Existing associations for this asset
        existing = set(
            row[0] for row in self.session.query(AssetVulnerability.vulnerability_id)
            .filter(AssetVulnerability.asset_id == asset.id)
            .all()
        )

        # Create missing associations
        batch_size = 500
        batch = 0
        try:
            for cve_id in cve_ids:
                if cve_id in existing:
                    continue
                av = AssetVulnerability(asset_id=asset.id, vulnerability_id=cve_id, status='OPEN')
                self.session.add(av)
                created_count += 1
                batch += 1
                if batch >= batch_size:
                    self.session.flush()
                    self.session.commit()
                    batch = 0

            # Final commit for remaining
            if batch > 0:
                self.session.flush()
                self.session.commit()
        except Exception:
            self.session.rollback()
            raise

        return created_count

    def sync_all_assets(self, limit_per_asset: int = 1000, only_active: bool = True) -> int:
        """Create AssetVulnerability links for all assets with a vendor assigned.
        Returns total number of created associations across all assets.
        """
        from app.models.asset import Asset
        total_created = 0
        q = self.session.query(Asset).filter(Asset.vendor_id.isnot(None))
        if only_active:
            q = q.filter(Asset.status == 'active')
        assets = q.all()
        for asset in assets:
            total_created += self.sync_asset_vulnerabilities_for_asset(asset.id, limit_per_asset=limit_per_asset)
        return total_created
