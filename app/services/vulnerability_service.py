
"""
VulnerabilityService handles business logic for querying and managing vulnerability data.

This service provides methods to fetch paginated vulnerabilities, dashboard counts,
and individual vulnerability details, interacting with the database via SQLAlchemy.
"""

import json
from typing import List, Dict, Optional, Tuple
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from sqlalchemy import func, or_, and_
from app.models.vulnerability import Vulnerability


# Helper genÃ©rico para parse de campos JSON/lista provenientes da NVD
def _parse_list_field(raw):
    """Parseia um campo potencialmente em vÃ¡rios formatos (list, dict, str JSON, str CSV) e retorna uma lista de strings.

    Este helper Ã© usado para ler `nvd_vendors_data`, `nvd_products_data` e campos similares
    que podem ter sido salvos como lista, dict com chaves internas, string JSON ou string separada por vÃ­rgulas.
    """
    try:
        if raw is None:
            return []
        # JÃ¡ Ã© uma lista: normaliza itens
        if isinstance(raw, list):
            parsed = []
            for x in raw:
                if isinstance(x, dict):
                    # Tenta chaves comuns
                    if 'name' in x:
                        parsed.append(str(x['name']))
                    elif 'vendor' in x:
                        parsed.append(str(x['vendor']))
                    elif 'value' in x:
                        parsed.append(str(x['value']))
                    else:
                        # Fallback: stringifica
                        parsed.append(str(x))
                else:
                    parsed.append(str(x))
            return parsed
        # DicionÃ¡rio: busca chaves padrÃ£o
        if isinstance(raw, dict):
            # Alguns dumps podem ter a chave 'vendors' ou 'items'
            if 'vendors' in raw and isinstance(raw['vendors'], list):
                return [str(x) for x in raw['vendors']]
            if 'items' in raw and isinstance(raw['items'], list):
                return [str(x) for x in raw['items']]
            # Fallback: stringifica tudo
            return [str(raw)]
        # String: pode ser JSON ou CSV
        if isinstance(raw, str):
            s = raw.strip()
            if not s:
                return []
            # Tenta interpretar como JSON
            try:
                obj = json.loads(s)
                return _parse_list_field(obj)
            except Exception:
                # Trata como CSV simples
                return [p.strip() for p in s.split(',') if p.strip()]
        # Tipos nÃ£o esperados
        return []
    except Exception:
        return []


def _chunk_list(lst, size):
    try:
        n = int(size) if size else 900
    except Exception:
        n = 900
    if not lst:
        return []
    return [lst[i:i+n] for i in range(0, len(lst), n)]

class VulnerabilityService:
    """Service for managing vulnerability-related operations."""

    def __init__(self, session: Session):
        """
        Initialize the service with a database session.

        Args:
            session: SQLAlchemy session for database operations.
        """
        self.session = session



    def get_recent_paginated(self, page: int, per_page: int, vendor_ids: Optional[List[int]] = None) -> Tuple[List[Vulnerability], int]:
        """
        Fetch a paginated list of recent vulnerabilities.

        Args:
            page: Page number for pagination (1-based).
            per_page: Number of items per page.

        Returns:
            Tuple containing the list of vulnerabilities and the total count.
        """
        try:
            from sqlalchemy.orm import joinedload
            query = self.session.query(Vulnerability).options(joinedload(Vulnerability.references)).order_by(Vulnerability.published_date.desc())
            # Aplicar filtro por vendors selecionados explicitamente ou preferÃªncias do usuÃ¡rio
            try:
                from flask_login import current_user
                from app.models.sync_metadata import SyncMetadata
                from sqlalchemy import union
                from app.models.cve_vendor import CVEVendor
                from app.models.cve_product import CVEProduct
                from app.models.product import Product
                selected_vendor_ids: List[int] = []
                if vendor_ids:
                    selected_vendor_ids = [int(x) for x in vendor_ids if str(x).strip().isdigit()]
                elif current_user.is_authenticated:
                    key = f'user_vendor_preferences:{current_user.id}'
                    pref = self.session.query(SyncMetadata).filter_by(key=key).first()
                    if pref and pref.value:
                        selected_vendor_ids = [int(x) for x in pref.value.split(',') if x.strip().isdigit()]
                if selected_vendor_ids:
                    try:
                        chunks = _chunk_list(selected_vendor_ids, 900)
                        subqs = []
                        for ch in chunks:
                            if not ch:
                                continue
                            subqs.append(
                                self.session
                                .query(CVEVendor.cve_id)
                                .filter(CVEVendor.vendor_id.in_(ch))
                            )
                            subqs.append(
                                self.session
                                .query(CVEProduct.cve_id)
                                .join(Product, Product.id == CVEProduct.product_id)
                                .filter(Product.vendor_id.in_(ch))
                            )
                        if subqs:
                            cves_unificados_sq = union(*subqs).subquery()
                            query = query.filter(
                                Vulnerability.cve_id.in_(self.session.query(cves_unificados_sq.c.cve_id))
                            ).distinct()
                    except Exception:
                        # Fallback robusto: aplicar filtro via joins diretos
                        chunks = _chunk_list(selected_vendor_ids, 900)
                        conditions = []
                        for ch in chunks:
                            if not ch:
                                continue
                            conditions.append(CVEVendor.vendor_id.in_(ch))
                            conditions.append(Product.vendor_id.in_(ch))
                        query = (
                            query
                            .outerjoin(CVEVendor, CVEVendor.cve_id == Vulnerability.cve_id)
                            .outerjoin(CVEProduct, CVEProduct.cve_id == Vulnerability.cve_id)
                            .outerjoin(Product, Product.id == CVEProduct.product_id)
                            .filter(or_(*conditions) if conditions else True)
                            .distinct()
                        )
            except Exception:
                # Se falhar, segue sem filtro (mantÃ©m comportamento atual), mas evita crash
                pass
            total_count = query.count()
            offset = (page - 1) * per_page
            vulnerabilities = query.offset(offset).limit(per_page).all()
            return vulnerabilities, total_count
        except Exception as e:
            raise RuntimeError(f"Error fetching paginated vulnerabilities: {e}")

    def get_dashboard_counts(self, vendor_ids: Optional[List[int]] = None) -> Dict[str, int]:
        """
        Retrieve counts of vulnerabilities by severity and total.

        Returns:
            Dictionary with counts for critical, high, medium, and total vulnerabilities.
        """
        try:
            # Base query
            base_query = self.session.query(Vulnerability)
            # Aplicar filtro por vendors selecionados explicitamente ou preferÃªncias do usuÃ¡rio, se houver
            try:
                from flask_login import current_user
                from app.models.sync_metadata import SyncMetadata
                from sqlalchemy import union
                from app.models.cve_vendor import CVEVendor
                from app.models.cve_product import CVEProduct
                from app.models.product import Product
                selected_vendor_ids: List[int] = []
                if vendor_ids:
                    selected_vendor_ids = [int(x) for x in vendor_ids if str(x).strip().isdigit()]
                elif current_user.is_authenticated:
                    key = f'user_vendor_preferences:{current_user.id}'
                    pref = self.session.query(SyncMetadata).filter_by(key=key).first()
                    if pref and pref.value:
                        selected_vendor_ids = [int(x) for x in pref.value.split(',') if x.strip().isdigit()]
                if selected_vendor_ids:
                    try:
                        chunks = _chunk_list(selected_vendor_ids, 900)
                        subqs = []
                        for ch in chunks:
                            if not ch:
                                continue
                            subqs.append(
                                self.session
                                .query(CVEVendor.cve_id)
                                .filter(CVEVendor.vendor_id.in_(ch))
                            )
                            subqs.append(
                                self.session
                                .query(CVEProduct.cve_id)
                                .join(Product, Product.id == CVEProduct.product_id)
                                .filter(Product.vendor_id.in_(ch))
                            )
                        if subqs:
                            cves_unificados_sq = union(*subqs).subquery()
                            base_query = base_query.filter(
                                Vulnerability.cve_id.in_(self.session.query(cves_unificados_sq.c.cve_id))
                            ).distinct()
                    except Exception:
                        # Fallback robusto: aplicar filtro via joins diretos
                        chunks = _chunk_list(selected_vendor_ids, 900)
                        conditions = []
                        for ch in chunks:
                            if not ch:
                                continue
                            conditions.append(CVEVendor.vendor_id.in_(ch))
                            conditions.append(Product.vendor_id.in_(ch))
                        base_query = (
                            base_query
                            .outerjoin(CVEVendor, CVEVendor.cve_id == Vulnerability.cve_id)
                            .outerjoin(CVEProduct, CVEProduct.cve_id == Vulnerability.cve_id)
                            .outerjoin(Product, Product.id == CVEProduct.product_id)
                            .filter(or_(*conditions) if conditions else True)
                            .distinct()
                        )
            except Exception:
                # Se falhar, segue sem filtro (mantÃ©m comportamento atual)
                pass
            counts = {
                'critical': base_query.filter(Vulnerability.base_severity == 'CRITICAL').count(),
                'high': base_query.filter(Vulnerability.base_severity == 'HIGH').count(),
                'medium': base_query.filter(Vulnerability.base_severity == 'MEDIUM').count(),
                'total': base_query.count()
            }
            # Fallback por JSON de vendors quando associaÃ§Ãµes normalizadas nÃ£o retornam dados
            # Aqui computamos contagens globais (nÃ£o semanais) respeitando o escopo de vendors via dados NVD diretos
            if vendor_ids and counts.get('total', 0) == 0:
                selected_vendor_names_lower = set()
                try:
                    from app.models.vendor import Vendor
                    vendors = (
                        self.session.query(Vendor.id, Vendor.name)
                        .filter(Vendor.id.in_(vendor_ids))
                        .all()
                    )
                    for _vid, _vname in vendors:
                        if _vname:
                            selected_vendor_names_lower.add(str(_vname).strip().lower())
                except Exception:
                    selected_vendor_names_lower = set()

                # Busca todas as vulnerabilidades e filtra por vendors do JSON
                all_candidates = self.session.query(Vulnerability).all()

                crt = 0
                hig = 0
                med = 0
                tot = 0
                for v in all_candidates:
                    try:
                        # Utiliza helper existente para parsear JSON/strings
                        vnames = [str(x).strip().lower() for x in _parse_list_field(v.nvd_vendors_data)]
                        if not any(vn in selected_vendor_names_lower for vn in vnames):
                            continue
                        tot += 1
                        sev = (v.base_severity or '').upper()
                        if sev == 'CRITICAL':
                            crt += 1
                        elif sev == 'HIGH':
                            hig += 1
                        elif sev == 'MEDIUM':
                            med += 1
                    except Exception:
                        continue

                counts = {
                    'critical': crt,
                    'high': hig,
                    'medium': med,
                    'total': tot
                }
            return counts
        except Exception as e:
            raise RuntimeError(f"Error fetching dashboard counts: {e}")

    def get_vulnerability_by_id(self, cve_id: str) -> Optional[Vulnerability]:
        """
        Fetch a single vulnerability by its CVE ID.

        Args:
            cve_id: The CVE ID of the vulnerability (e.g., 'CVE-2023-12345').

        Returns:
            The Vulnerability object if found, else None.
        """
        try:
            return self.session.query(Vulnerability).filter_by(cve_id=cve_id).first()
        except Exception as e:
            raise RuntimeError(f"Error fetching vulnerability by ID {cve_id}: {e}")
    
    def get_vulnerability_by_cve_id(self, cve_id: str) -> Optional[Vulnerability]:
        """
        Alias for get_vulnerability_by_id for backward compatibility.
        
        Args:
            cve_id: The CVE ID of the vulnerability (e.g., 'CVE-2023-12345').
            
        Returns:
            The Vulnerability object if found, else None.
        """
        return self.get_vulnerability_by_id(cve_id)
    
    def get_vulnerability_with_details(self, cve_id: str) -> Optional[Vulnerability]:
        """
        Fetch a vulnerability with all related data using eager loading.
        
        Args:
            cve_id: The CVE ID of the vulnerability (e.g., 'CVE-2023-12345').
            
        Returns:
            The Vulnerability object with all related data loaded, or None if not found.
        """
        try:
            from sqlalchemy.orm import joinedload, selectinload
            from app.models.cve_product import CVEProduct
            
            vulnerability = self.session.query(Vulnerability).options(
                joinedload(Vulnerability.metrics),
                selectinload(Vulnerability.products).joinedload(CVEProduct.product),
                joinedload(Vulnerability.weaknesses),
                joinedload(Vulnerability.references),
                joinedload(Vulnerability.affected_products),
                joinedload(Vulnerability.version_references)
            ).filter_by(cve_id=cve_id).first()
            return vulnerability
        except Exception:
            try:
                from sqlalchemy.orm import joinedload
                vulnerability = self.session.query(Vulnerability).options(
                    joinedload(Vulnerability.metrics),
                    joinedload(Vulnerability.weaknesses),
                    joinedload(Vulnerability.references),
                    joinedload(Vulnerability.affected_products),
                    joinedload(Vulnerability.version_references)
                ).filter_by(cve_id=cve_id).first()
                return vulnerability
            except Exception as e2:
                raise RuntimeError(f"Error fetching vulnerability with details for {cve_id}: {e2}")

    def get_related_cves_by_cwe(self, cve_id: str, limit: int = 20) -> List[Vulnerability]:
        try:
            from app.models.weakness import Weakness
            base = cve_id.upper()
            cwes = [row[0] for row in self.session.query(Weakness.cwe_id).filter(Weakness.cve_id == base).all()]
            if not cwes:
                return []
            q = (
                self.session.query(Vulnerability)
                .join(Weakness, Weakness.cve_id == Vulnerability.cve_id)
                .filter(Weakness.cwe_id.in_(cwes))
                .filter(Vulnerability.cve_id != base)
                .distinct()
                .order_by(Vulnerability.published_date.desc())
            )
            if limit and limit > 0:
                q = q.limit(int(limit))
            return q.all()
        except Exception as e:
            raise RuntimeError(f"Error fetching related CVEs by CWE for {cve_id}: {e}")

    def get_weekly_counts(self, vendor_ids: Optional[List[int]] = None) -> Dict[str, int]:
        """
        Retrieve counts of vulnerabilities published in the last 7 days by severity.

        Returns:
            Dictionary with weekly counts for critical, high, medium, and total vulnerabilities.
        """
        try:
            # Calculate date 7 days ago
            week_ago = datetime.now() - timedelta(days=7)
            
            # Base query for vulnerabilities from last week (include new and updated)
            base_query = self.session.query(Vulnerability).filter(
                or_(
                    Vulnerability.published_date >= week_ago,
                    Vulnerability.last_update >= week_ago
                )
            )
            # Aplicar filtro por vendors selecionados explicitamente ou preferÃªncias de usuÃ¡rio (via uniÃ£o de CVEs por vendor e por produto do vendor)
            try:
                from flask_login import current_user
                from sqlalchemy import union
                from app.models.sync_metadata import SyncMetadata
                from app.models.cve_vendor import CVEVendor
                from app.models.cve_product import CVEProduct
                from app.models.product import Product
                selected_vendor_ids: List[int] = []
                if vendor_ids:
                    selected_vendor_ids = [int(x) for x in vendor_ids if str(x).strip().isdigit()]
                elif current_user.is_authenticated:
                    key = f'user_vendor_preferences:{current_user.id}'
                    pref = self.session.query(SyncMetadata).filter_by(key=key).first()
                    if pref and pref.value:
                        selected_vendor_ids = [int(x) for x in pref.value.split(',') if x.strip().isdigit()]
                if selected_vendor_ids:
                    try:
                        chunks = _chunk_list(selected_vendor_ids, 900)
                        subqs = []
                        for ch in chunks:
                            if not ch:
                                continue
                            subqs.append(
                                self.session
                                .query(CVEVendor.cve_id)
                                .filter(CVEVendor.vendor_id.in_(ch))
                            )
                            subqs.append(
                                self.session
                                .query(CVEProduct.cve_id)
                                .join(Product, Product.id == CVEProduct.product_id)
                                .filter(Product.vendor_id.in_(ch))
                            )
                        if subqs:
                            cves_unificados_sq = union(*subqs).subquery()
                            base_query = base_query.filter(
                                Vulnerability.cve_id.in_(self.session.query(cves_unificados_sq.c.cve_id))
                            ).distinct()
                    except Exception:
                        # Fallback robusto: aplicar filtro via joins diretos
                        chunks = _chunk_list(selected_vendor_ids, 900)
                        conditions = []
                        for ch in chunks:
                            if not ch:
                                continue
                            conditions.append(CVEVendor.vendor_id.in_(ch))
                            conditions.append(Product.vendor_id.in_(ch))
                        base_query = (
                            base_query
                            .outerjoin(CVEVendor, CVEVendor.cve_id == Vulnerability.cve_id)
                            .outerjoin(CVEProduct, CVEProduct.cve_id == Vulnerability.cve_id)
                            .outerjoin(Product, Product.id == CVEProduct.product_id)
                            .filter(or_(*conditions) if conditions else True)
                            .distinct()
                        )
            except Exception:
                # Se falhar, segue sem filtro
                pass
            
            counts = {
                'critical': base_query.filter(Vulnerability.base_severity == 'CRITICAL').count(),
                'high': base_query.filter(Vulnerability.base_severity == 'HIGH').count(),
                'medium': base_query.filter(Vulnerability.base_severity == 'MEDIUM').count(),
                'total': base_query.count()
            }
            # Fallback por JSON de vendors quando associaÃ§Ãµes normalizadas nÃ£o retornam dados
            # Recalcula contagens semanais respeitando vendors via dados brutos NVD (nvd_vendors_data)
            if vendor_ids and counts.get('total', 0) == 0:
                selected_vendor_names_lower = set()
                try:
                    from app.models.vendor import Vendor
                    vendors = (
                        self.session.query(Vendor.id, Vendor.name)
                        .filter(Vendor.id.in_(vendor_ids))
                        .all()
                    )
                    for _vid, _vname in vendors:
                        if _vname:
                            selected_vendor_names_lower.add(str(_vname).strip().lower())
                except Exception:
                    selected_vendor_names_lower = set()

                def _matches_selected_vendor(v: Vulnerability) -> bool:
                    try:
                        vnames = [str(x).strip().lower() for x in _parse_list_field(v.nvd_vendors_data)]
                        return any(vn in selected_vendor_names_lower for vn in vnames)
                    except Exception:
                        return False

                weekly_candidates = (
                    self.session.query(Vulnerability)
                    .filter(
                        or_(
                            Vulnerability.published_date >= week_ago,
                            Vulnerability.last_update >= week_ago
                        )
                    )
                    .all()
                )

                critical = high = medium = total = 0
                for v in weekly_candidates:
                    if not _matches_selected_vendor(v):
                        continue
                    total += 1
                    sev = getattr(v, 'base_severity', None)
                    if sev == 'CRITICAL':
                        critical += 1
                    elif sev == 'HIGH':
                        high += 1
                    elif sev == 'MEDIUM':
                        medium += 1
                counts = {
                    'critical': int(critical),
                    'high': int(high),
                    'medium': int(medium),
                    'total': int(total)
                }
            return counts
        except Exception as e:
            raise RuntimeError(f"Error fetching weekly vulnerability counts: {e}")

    def get_vulnerability_analytics(self, cve_id: str) -> Dict:
        """
        Get comprehensive analytics data for a specific vulnerability.

        Args:
            cve_id: The CVE ID of the vulnerability.

        Returns:
            Dictionary containing analytics data including affected assets, timeline, etc.
        """
        try:
            vulnerability = self.get_vulnerability_by_id(cve_id)
            if not vulnerability:
                return {}

            # Get affected assets count
            from app.models.asset_vulnerability import AssetVulnerability
            affected_assets_count = self.session.query(AssetVulnerability).filter_by(
                vulnerability_id=vulnerability.cve_id
            ).count()

            # Get severity distribution for similar vulnerabilities
            similar_vulns = self.session.query(Vulnerability).filter(
                Vulnerability.base_severity == vulnerability.base_severity
            ).count()

            # Calculate risk score based on CVSS and affected assets
            risk_score = 0
            if vulnerability.cvss_score:
                risk_score = vulnerability.cvss_score * (1 + (affected_assets_count * 0.1))
                risk_score = min(risk_score, 10.0)  # Cap at 10.0

            analytics = {
                'vulnerability': vulnerability,
                'affected_assets_count': affected_assets_count,
                'similar_vulnerabilities_count': similar_vulns,
                'calculated_risk_score': round(risk_score, 1),
                'severity_level': vulnerability.base_severity,
                'cvss_score': vulnerability.cvss_score,
                'published_date': vulnerability.published_date,
                'last_modified': vulnerability.last_update,
                'current_date': datetime.now()
            }

            return analytics
        except Exception as e:
            raise RuntimeError(f"Error fetching vulnerability analytics for {cve_id}: {e}")

    def save_vulnerabilities_batch(self, vulnerabilities_data: List[Dict]) -> int:
        """
        Save a batch of vulnerabilities to the database with detailed feedback.
        
        Args:
            vulnerabilities_data: List of dictionaries containing vulnerability data
            
        Returns:
            Number of vulnerabilities successfully saved
        """
        try:
            from app.models.cvss_metric import CVSSMetric
            from app.utils.terminal_feedback import terminal_feedback
            import time
            
            start_time = time.time()
            saved_count = 0
            updated_count = 0
            error_count = 0
            normalized_count = 0
            
            terminal_feedback.info(f"ğŸ’¾ Iniciando gravaÃ§Ã£o de {len(vulnerabilities_data)} CVEs no banco de dados")
            
            for idx, vuln_data in enumerate(vulnerabilities_data):
                cve_id = vuln_data.get('cve_id', f'unknown_{idx}')
                
                try:
                    # Salvar dados diretos da API NVD sem normalizaÃ§Ã£o
                    nvd_data = {}
                    if 'vendors' in vuln_data and vuln_data['vendors']:
                        nvd_data['nvd_vendors_data'] = vuln_data['vendors']
                        terminal_feedback.info(f"ğŸ“Š Salvando {len(vuln_data['vendors'])} vendors diretos para {cve_id}")
                    
                    if 'products' in vuln_data and vuln_data['products']:
                        nvd_data['nvd_products_data'] = vuln_data['products']
                        terminal_feedback.info(f"ğŸ“¦ Salvando {len(vuln_data['products'])} produtos diretos para {cve_id}")
                    
                    if 'cpe_configurations' in vuln_data and vuln_data['cpe_configurations']:
                        nvd_data['nvd_cpe_configurations'] = vuln_data['cpe_configurations']
                        terminal_feedback.info(f"ğŸ”§ Salvando configuraÃ§Ãµes CPE diretas para {cve_id}")
                    
                    if 'version_ranges' in vuln_data and vuln_data['version_ranges']:
                        nvd_data['nvd_version_ranges'] = vuln_data['version_ranges']
                        terminal_feedback.info(f"ğŸ“‹ Salvando {len(vuln_data['version_ranges'])} versÃµes diretas para {cve_id}")
                    
                    # Check if vulnerability already exists
                    existing_vuln = self.session.query(Vulnerability).filter_by(
                        cve_id=vuln_data['cve_id']
                    ).first()
                    
                    if existing_vuln:
                        # Update existing vulnerability
                        terminal_feedback.info(f"ğŸ”„ Atualizando CVE existente: {cve_id}")
                        for key, value in vuln_data.items():
                            if key not in ['cvss_metrics', 'vendors', 'products', 'weaknesses', 'references', 'version_ranges', 'cpe_configurations']:  # Skip fields that don't belong to model
                                setattr(existing_vuln, key, value)
                        # Atualizar dados NVD diretos
                        for key, value in nvd_data.items():
                            setattr(existing_vuln, key, value)
                        vulnerability = existing_vuln
                        updated_count += 1
                    else:
                        # Create new vulnerability
                        terminal_feedback.success(f"âœ… Criando nova CVE: {cve_id}")
                        # Remove fields that don't belong to Vulnerability model
                        vuln_dict = {k: v for k, v in vuln_data.items() 
                                    if k not in ['cvss_metrics', 'vendors', 'products', 'weaknesses', 'references', 'version_ranges', 'cpe_configurations']}
                        # Adicionar dados NVD diretos
                        vuln_dict.update(nvd_data)
                        vulnerability = Vulnerability(**vuln_dict)
                        self.session.add(vulnerability)
                        saved_count += 1
                
                    # Criar associaÃ§Ãµes normalizadas CVEâ†”Vendor/Product para suportar vinculaÃ§Ã£o a ativos
                    try:
                        if 'vendors' in vuln_data and vuln_data['vendors']:
                            terminal_feedback.info(f"ğŸ·ï¸ Normalizando vendors para {cve_id}")
                            self._process_vendors(vulnerability.cve_id, vuln_data['vendors'])
                            # Incrementa contagem de normalizaÃ§Ãµes com base na quantidade de vendors
                            try:
                                normalized_count += len(vuln_data['vendors'])
                            except Exception:
                                normalized_count += 1
                        if 'products' in vuln_data and vuln_data['products']:
                            terminal_feedback.info(f"ğŸ·ï¸ Normalizando products para {cve_id}")
                            self._process_products(vulnerability.cve_id, vuln_data['products'])
                            # Incrementa contagem de normalizaÃ§Ãµes com base na quantidade de produtos
                            try:
                                normalized_count += len(vuln_data['products'])
                            except Exception:
                                normalized_count += 1
                    except Exception as assoc_err:
                        # NÃ£o falhar o processamento da CVE por erro de associaÃ§Ã£o; registrar e continuar
                        terminal_feedback.warning(f"âš ï¸ Falha ao normalizar vendors/products para {cve_id}: {assoc_err}")

                    # Materializar CPE parts (a, o, h) para filtragem eficiente
                    try:
                        cpe_cfgs = vuln_data.get('cpe_configurations')
                        if cpe_cfgs:
                            self._process_parts(vulnerability.cve_id, cpe_cfgs)
                    except Exception as parts_err:
                        terminal_feedback.warning(f"âš ï¸ Falha ao materializar CPE parts para {cve_id}: {parts_err}")
                        
                    # Handle CVSS metrics
                    if 'cvss_metrics' in vuln_data and vuln_data['cvss_metrics']:
                        terminal_feedback.info(f"ğŸ“Š Processando mÃ©tricas CVSS para {cve_id}")
                        # Remove existing metrics for this vulnerability
                        self.session.query(CVSSMetric).filter_by(
                            cve_id=vulnerability.cve_id
                        ).delete()
                        
                        # Add new metrics
                        for metric_data in vuln_data['cvss_metrics']:
                            metric_data['cve_id'] = vulnerability.cve_id
                            metric = CVSSMetric(**metric_data)
                            self.session.add(metric)
                    
                    # Dados de vendors e products agora sÃ£o salvos diretamente nos campos JSON
                    # NÃ£o Ã© mais necessÃ¡rio processar separadamente
                    
                    # Handle weaknesses (CWEs)
                    if 'weaknesses' in vuln_data and vuln_data['weaknesses']:
                        terminal_feedback.info(f"ğŸ” Processando {len(vuln_data['weaknesses'])} CWEs para {cve_id}")
                        self._process_weaknesses(vulnerability.cve_id, vuln_data['weaknesses'])
                    
                    # Handle references
                    if 'references' in vuln_data and vuln_data['references']:
                        terminal_feedback.info(f"ğŸ”— Processando {len(vuln_data['references'])} referÃªncias para {cve_id}")
                        self._process_references(vulnerability.cve_id, vuln_data['references'])
                    
                    # Handle version ranges
                    if 'version_ranges' in vuln_data and vuln_data['version_ranges']:
                        terminal_feedback.info(f"ğŸ“‹ Processando {len(vuln_data['version_ranges'])} versÃµes para {cve_id}")
                        self._process_version_ranges(vulnerability.cve_id, vuln_data['version_ranges'])
                    
                    terminal_feedback.success(f"âœ… CVE {cve_id} gravada com sucesso no banco de dados")
                    
                except Exception as cve_error:
                    error_count += 1
                    terminal_feedback.error(f"âŒ Erro ao processar CVE {cve_id}: {str(cve_error)}")
                    continue
            
            # Commit das alteraÃ§Ãµes
            self.session.commit()
            
            # Feedback final detalhado
            duration = time.time() - start_time
            total_processed = saved_count + updated_count
            
            terminal_feedback.success(
                f"ğŸ’¾ Lote gravado com sucesso!", 
                {
                    "novas_cves": saved_count,
                    "cves_atualizadas": updated_count,
                    "total_processadas": total_processed,
                    "normalizacoes_aplicadas": normalized_count,
                    "erros": error_count,
                    "duracao": f"{duration:.2f}s",
                    "taxa_sucesso": f"{((total_processed / len(vulnerabilities_data)) * 100):.1f}%"
                }
            )
            
            return total_processed
            
        except Exception as e:
            self.session.rollback()
            terminal_feedback.error(f"âŒ Erro crÃ­tico ao salvar lote de vulnerabilidades: {str(e)}")
            raise RuntimeError(f"Error saving vulnerabilities batch: {e}")

    def get_last_sync_time(self) -> Optional[datetime]:
        """
        Retorna o melhor timestamp conhecido da Ãºltima sincronizaÃ§Ã£o.
        
        PreferÃªncia:
        1) SyncMetadata 'nvd_last_sync' com status concluÃ­do
        2) Caso nÃ£o exista ou esteja invÃ¡lido, usa o timestamp da Ãºltima CVE cadastrada (Vulnerability.last_update)
        """
        try:
            from app.models.sync_metadata import SyncMetadata
            # Tenta usar metadata de sincronizaÃ§Ã£o primeiro
            sync_record = self.session.query(SyncMetadata).filter_by(
                key='nvd_last_sync'
            ).first()
            
            # Se uma sincronizaÃ§Ã£o estiver em andamento, ignorar metadata e usar fallback
            if sync_record and getattr(sync_record, 'status', None) == 'in_progress':
                sync_record = None

            if sync_record and getattr(sync_record, 'value', None):
                # Converter string ISO para datetime
                from datetime import datetime
                try:
                    return datetime.fromisoformat(sync_record.value.replace('Z', '+00:00'))
                except ValueError:
                    # Valor invÃ¡lido no metadata â€” prosseguir para o fallback
                    pass
            
            # Fallback: usar data da Ãºltima CVE cadastrada
            from app.models.vulnerability import Vulnerability
            last_cve_update = self.session.query(func.max(Vulnerability.last_update)).scalar()
            if last_cve_update:
                return last_cve_update
            
            return None
            
        except Exception as e:
            raise RuntimeError(f"Error fetching last sync time: {e}")

    def get_vulnerabilities_last_week_by_severity(self, severity: str) -> Dict:
        """
        Get vulnerabilities from the last week filtered by severity.

        Args:
            severity: The severity level to filter by
            
        Returns:
            Dictionary containing vulnerabilities list and total count
        """
        try:
            # Calculate date 7 days ago
            week_ago = datetime.now() - timedelta(days=7)
            
            # Query vulnerabilities from last week with specified severity
            query = self.session.query(Vulnerability).filter(
                Vulnerability.published_date >= week_ago,
                Vulnerability.base_severity == severity.upper()
            ).order_by(Vulnerability.published_date.desc())
            
            vulnerabilities = query.all()
            total_count = query.count()
            
            return {
                'vulnerabilities': vulnerabilities,
                'total_count': total_count
            }
        except Exception as e:
            raise RuntimeError(f"Error fetching vulnerabilities for last week by severity {severity}: {e}")

    def get_weekly_statistics_by_severity(self, severity: str, vendor_ids: Optional[List[int]] = None) -> Dict:
        """
        Get weekly statistics for vulnerabilities of a specific severity.

        Args:
            severity: The severity level to analyze
            
        Returns:
            Dictionary containing various statistics and charts data
        """
        try:
            # Calculate date ranges
            week_ago = datetime.now() - timedelta(days=7)
            month_ago = datetime.now() - timedelta(days=30)
            
            # Base query for this severity
            base_query = self.session.query(Vulnerability).filter(
                Vulnerability.base_severity == severity.upper()
            )
            # Vendor-scoped filtering when vendor_ids provided (via union of CVEVendor and Product.vendor_id)
            try:
                if vendor_ids:
                    from sqlalchemy import union
                    from app.models.cve_vendor import CVEVendor
                    from app.models.cve_product import CVEProduct
                    from app.models.product import Product
                    cves_por_vendor = (
                        self.session
                        .query(CVEVendor.cve_id)
                        .filter(CVEVendor.vendor_id.in_(vendor_ids))
                    )
                    cves_por_produto_vendor = (
                        self.session
                        .query(CVEProduct.cve_id)
                        .join(Product, Product.id == CVEProduct.product_id)
                        .filter(Product.vendor_id.in_(vendor_ids))
                    )
                    cves_unificados_sq = union(cves_por_vendor, cves_por_produto_vendor).subquery()
                    base_query = base_query.filter(
                        Vulnerability.cve_id.in_(self.session.query(cves_unificados_sq.c.cve_id))
                    ).distinct()
            except Exception:
                pass
            
            # Weekly count
            weekly_count = base_query.filter(
                or_(
                    Vulnerability.published_date >= week_ago,
                    Vulnerability.last_update >= week_ago
                )
            ).count()
            
            # Monthly count
            monthly_count = base_query.filter(
                or_(
                    Vulnerability.published_date >= month_ago,
                    Vulnerability.last_update >= month_ago
                )
            ).count()
            
            # Total count for this severity
            total_count = base_query.count()
            
            # Vendor-aware JSON fallback when normalized associations return no data
            if vendor_ids and total_count == 0:
                selected_vendor_names_lower = set()
                try:
                    from app.models.vendor import Vendor
                    vendors = (
                        self.session.query(Vendor.id, Vendor.name)
                        .filter(Vendor.id.in_(vendor_ids))
                        .all()
                    )
                    for _vid, _vname in vendors:
                        if _vname:
                            selected_vendor_names_lower.add(str(_vname).strip().lower())
                except Exception:
                    selected_vendor_names_lower = set()

                def _parse_list_field(raw):
                    data = raw
                    if not data:
                        return []
                    if isinstance(data, str):
                        try:
                            data = json.loads(data)
                        except Exception:
                            if ',' in data:
                                data = [p.strip() for p in data.split(',') if p.strip()]
                            else:
                                data = [data]
                    if isinstance(data, list):
                        items = []
                        for itm in data:
                            if isinstance(itm, str):
                                items.append(itm)
                            elif isinstance(itm, dict):
                                val = itm.get('name') or itm.get('vendor') or itm.get('vendor_name') or itm.get('product')
                                if val:
                                    items.append(val)
                        return items
                    return []

                def _matches_selected_vendor(vuln) -> bool:
                    if not selected_vendor_names_lower:
                        return False
                    try:
                        vnames = [str(v).strip().lower() for v in _parse_list_field(vuln.nvd_vendors_data)]
                        return any(vn in selected_vendor_names_lower for vn in vnames)
                    except Exception:
                        return False

                # Compute weekly_count using JSON vendor-aware filter
                weekly_candidates = (
                    self.session.query(Vulnerability)
                    .filter(
                        Vulnerability.base_severity == severity.upper(),
                        or_(
                            Vulnerability.published_date >= week_ago,
                            Vulnerability.last_update >= week_ago
                        )
                    )
                    .all()
                )
                weekly_filtered = [v for v in weekly_candidates if _matches_selected_vendor(v)]
                weekly_count = len(weekly_filtered)

                # Monthly count using JSON vendor-aware filter
                monthly_candidates = (
                    self.session.query(Vulnerability)
                    .filter(
                        Vulnerability.base_severity == severity.upper(),
                        or_(
                            Vulnerability.published_date >= month_ago,
                            Vulnerability.last_update >= month_ago
                        )
                    )
                    .all()
                )
                monthly_filtered = [v for v in monthly_candidates if _matches_selected_vendor(v)]
                monthly_count = len(monthly_filtered)

                # Total count across all time for this severity using JSON vendor-aware filter
                all_candidates = (
                    self.session.query(Vulnerability)
                    .filter(Vulnerability.base_severity == severity.upper())
                    .all()
                )
                total_filtered = [v for v in all_candidates if _matches_selected_vendor(v)]
                total_count = len(total_filtered)

                # Daily distribution (last 7 days) using weekly_filtered set
                daily_data = []
                for i in range(7):
                    day_start = datetime.now() - timedelta(days=i+1)
                    day_end = datetime.now() - timedelta(days=i)
                    day_count = 0
                    for v in weekly_filtered:
                        try:
                            pd = v.published_date
                            lu = v.last_update
                            if (pd and pd >= day_start and pd < day_end) or (lu and lu >= day_start and lu < day_end):
                                day_count += 1
                        except Exception:
                            continue
                    daily_data.append({
                        'date': day_start.strftime('%Y-%m-%d'),
                        'count': day_count
                    })
                daily_data.reverse()

                # CVSS distribution restricted to weekly_filtered
                cvss_ranges = {
                    '0.0-3.9': 0,
                    '4.0-6.9': 0,
                    '7.0-8.9': 0,
                    '9.0-10.0': 0
                }
                for vuln in weekly_filtered:
                    score = getattr(vuln, 'cvss_score', None)
                    if score is None:
                        continue
                    try:
                        if score < 4.0:
                            cvss_ranges['0.0-3.9'] += 1
                        elif score < 7.0:
                            cvss_ranges['4.0-6.9'] += 1
                        elif score < 9.0:
                            cvss_ranges['7.0-8.9'] += 1
                        else:
                            cvss_ranges['9.0-10.0'] += 1
                    except Exception:
                        continue

            # Daily distribution and CVSS base cÃ¡lculo apenas se nÃ£o usamos fallback JSON
            if not (vendor_ids and total_count == 0):
                # Daily distribution for the last 7 days
                daily_data = []
                for i in range(7):
                    day_start = datetime.now() - timedelta(days=i+1)
                    day_end = datetime.now() - timedelta(days=i)
                    
                    day_count = base_query.filter(
                        or_(
                            and_(
                                Vulnerability.published_date >= day_start,
                                Vulnerability.published_date < day_end
                            ),
                            and_(
                                Vulnerability.last_update >= day_start,
                                Vulnerability.last_update < day_end
                            )
                        )
                    ).count()
                    
                    daily_data.append({
                        'date': day_start.strftime('%Y-%m-%d'),
                        'count': day_count
                    })
                
                # Reverse to show chronological order
                daily_data.reverse()
                
                # CVSS score distribution for this severity
                cvss_ranges = {
                    '0.0-3.9': 0,
                    '4.0-6.9': 0,
                    '7.0-8.9': 0,
                    '9.0-10.0': 0
                }

                # Restrict CVSS distribution to last 7 days (weekly window)
                cvss_data = base_query.filter(
                    or_(
                        Vulnerability.published_date >= week_ago,
                        Vulnerability.last_update >= week_ago
                    ),
                    Vulnerability.cvss_score.isnot(None)
                ).all()
                
                for vuln in cvss_data:
                    score = vuln.cvss_score
                    if score < 4.0:
                        cvss_ranges['0.0-3.9'] += 1
                    elif score < 7.0:
                        cvss_ranges['4.0-6.9'] += 1
                    elif score < 9.0:
                        cvss_ranges['7.0-8.9'] += 1
                    else:
                        cvss_ranges['9.0-10.0'] += 1
            
            # Top affected products (prefer structured associations via CVEProduct)
            top_products = []
            try:
                from app.models.product import Product
                from app.models.cve_product import CVEProduct
                from app.models.vendor import Vendor

                top_products_query = (
                    self.session.query(
                        Product.name.label('product_name'),
                        Product.vendor_id.label('vendor_id'),
                        Vendor.name.label('vendor_name'),
                        func.count(CVEProduct.product_id).label('count')
                    )
                    .join(CVEProduct, Product.id == CVEProduct.product_id)
                    .join(Vendor, Vendor.id == Product.vendor_id)
                    .join(Vulnerability, Vulnerability.cve_id == CVEProduct.cve_id)
                    .filter(
                        Vulnerability.base_severity == severity.upper(),
                        or_(
                            Vulnerability.published_date >= month_ago,
                            Vulnerability.last_update >= month_ago
                        )
                    )
                )
                # Aplicar filtro de vendors diretamente pelos produtos
                if vendor_ids:
                    top_products_query = top_products_query.filter(Product.vendor_id.in_(vendor_ids))

                top_products = (
                    top_products_query
                    .group_by(Product.id, Product.name, Product.vendor_id, Vendor.name)
                    .order_by(func.count(CVEProduct.product_id).desc())
                    .limit(10)
                    .all()
                )
                # Convert to list of dicts including vendor metadata (backward compatible on frontend)
                top_products = [
                    {
                        'name': name,
                        'count': int(count),
                        'vendor_id': int(vendor_id) if vendor_id is not None else None,
                        'vendor_name': vendor_name
                    }
                    for name, vendor_id, vendor_name, count in top_products
                ]
            except Exception:
                # Fallback handled below if needed
                top_products = []
            
            if not top_products:
                # Fallback: derive Top Products from NVD JSON fields, vendor-aware
                products_counter = {}
                selected_vendor_names_lower = set()
                name_lower_to_id = {}

                try:
                    if vendor_ids:
                        from app.models.vendor import Vendor
                        vendors = (
                            self.session.query(Vendor.id, Vendor.name)
                            .filter(Vendor.id.in_(vendor_ids))
                            .all()
                        )
                        for vid, vname in vendors:
                            if vname:
                                selected_vendor_names_lower.add(str(vname).strip().lower())
                                name_lower_to_id[str(vname).strip().lower()] = int(vid)
                except Exception:
                    # If vendor lookup fails, proceed without mapping
                    pass

                # Query recent vulns for this severity within monthly window (without relying on base_query vendor filter)
                recent_vulns = (
                    self.session.query(Vulnerability)
                    .filter(
                        Vulnerability.base_severity == severity.upper(),
                        or_(
                            Vulnerability.published_date >= month_ago,
                            Vulnerability.last_update >= month_ago
                        )
                    )
                    .all()
                )

                def _parse_list_field(raw):
                    data = raw
                    if not data:
                        return []
                    if isinstance(data, str):
                        try:
                            data = json.loads(data)
                        except Exception:
                            # If it's a comma-separated string, split; else return as single item
                            if ',' in data:
                                data = [p.strip() for p in data.split(',') if p.strip()]
                            else:
                                data = [data]
                    if isinstance(data, list):
                        items = []
                        for itm in data:
                            if isinstance(itm, str):
                                items.append(itm)
                            elif isinstance(itm, dict):
                                # common keys: name, vendor, vendor_name, product
                                val = itm.get('name') or itm.get('vendor') or itm.get('vendor_name') or itm.get('product')
                                if val:
                                    items.append(val)
                        return items
                    return []

                for vuln in recent_vulns:
                    # If vendor_ids provided, include only vulns whose vendor JSON matches selected vendors
                    matched_vendor_name = None
                    matched_vendor_id = None
                    if vendor_ids:
                        vnames = [str(v).strip().lower() for v in _parse_list_field(vuln.nvd_vendors_data)]
                        match = next((vn for vn in vnames if vn in selected_vendor_names_lower), None)
                        if not match:
                            continue
                        matched_vendor_name = match
                        matched_vendor_id = name_lower_to_id.get(match)

                    # Count product names from JSON field
                    pnames_raw = _parse_list_field(vuln.nvd_products_data)
                    for pname in pnames_raw:
                        if not pname:
                            continue
                        key = str(pname).strip().lower()
                        current = products_counter.get(key)
                        if not current:
                            products_counter[key] = {
                                'name': str(pname).strip(),
                                'count': 1,
                                'vendor_id': matched_vendor_id if vendor_ids else None,
                                'vendor_name': matched_vendor_name if vendor_ids else None
                            }
                        else:
                            current['count'] += 1
                            # Preserve vendor metadata where available
                            if vendor_ids and matched_vendor_name and not current.get('vendor_name'):
                                current['vendor_name'] = matched_vendor_name
                            if vendor_ids and matched_vendor_id is not None and current.get('vendor_id') is None:
                                current['vendor_id'] = matched_vendor_id

                # Produce Top 10 sorted by count
                top_products = sorted(products_counter.values(), key=lambda x: x['count'], reverse=True)[:10]

                # As a last resort, fallback to keyword extraction from description
                if not top_products:
                    products_analysis = {}
                    common_products = ['windows', 'linux', 'apache', 'nginx', 'mysql', 'postgresql', 'php', 'java', 'python', 'node']
                    for vuln in recent_vulns:
                        if vuln.description:
                            desc_lower = vuln.description.lower()
                            for product in common_products:
                                if product in desc_lower:
                                    products_analysis[product] = products_analysis.get(product, 0) + 1
                    top_products = [
                        {
                            'name': name,
                            'count': int(count),
                            'vendor_id': None,
                            'vendor_name': None
                        }
                        for name, count in sorted(products_analysis.items(), key=lambda x: x[1], reverse=True)[:10]
                    ]
            
            return {
                'weekly_count': weekly_count,
                'monthly_count': monthly_count,
                'total_count': total_count,
                'daily_distribution': daily_data,
                'cvss_distribution': cvss_ranges,
                'top_products': top_products,
                'severity': severity.upper()
            }
        except Exception as e:
            raise RuntimeError(f"Error fetching weekly statistics for severity {severity}: {e}")

    def get_weekly_cvss_distribution_all(self, vendor_ids: Optional[List[int]] = None) -> Dict[str, int]:
        """
        Get CVSS score distribution for all vulnerabilities published in the last 7 days.

        Returns:
            Dictionary mapping CVSS ranges to counts for the weekly window across all severities.
        """
        try:
            week_ago = datetime.now() - timedelta(days=7)
            cvss_ranges = {
                '0.0-3.9': 0,
                '4.0-6.9': 0,
                '7.0-8.9': 0,
                '9.0-10.0': 0
            }

            query = self.session.query(Vulnerability).filter(
                or_(
                    Vulnerability.published_date >= week_ago,
                    Vulnerability.last_update >= week_ago
                ),
                Vulnerability.cvss_score.isnot(None)
            )
            # Vendor-scoped filtering when vendor_ids provided (via union of CVEVendor and Product.vendor_id)
            try:
                if vendor_ids:
                    from sqlalchemy import union
                    from app.models.cve_vendor import CVEVendor
                    from app.models.cve_product import CVEProduct
                    from app.models.product import Product
                    cves_por_vendor = (
                        self.session
                        .query(CVEVendor.cve_id)
                        .filter(CVEVendor.vendor_id.in_(vendor_ids))
                    )
                    cves_por_produto_vendor = (
                        self.session
                        .query(CVEProduct.cve_id)
                        .join(Product, Product.id == CVEProduct.product_id)
                        .filter(Product.vendor_id.in_(vendor_ids))
                    )
                    cves_unificados_sq = union(cves_por_vendor, cves_por_produto_vendor).subquery()
                    query = query.filter(
                        Vulnerability.cve_id.in_(self.session.query(cves_unificados_sq.c.cve_id))
                    ).distinct()
            except Exception:
                pass

            result_items = query.all()

            # Fallback: if vendor_ids provided and no normalized matches, filter using JSON vendor names
            if vendor_ids and not result_items:
                selected_vendor_names_lower = set()
                try:
                    from app.models.vendor import Vendor
                    vendors = (
                        self.session.query(Vendor.id, Vendor.name)
                        .filter(Vendor.id.in_(vendor_ids))
                        .all()
                    )
                    for _vid, _vname in vendors:
                        if _vname:
                            selected_vendor_names_lower.add(str(_vname).strip().lower())
                except Exception:
                    selected_vendor_names_lower = set()

                def _parse_list_field(raw):
                    data = raw
                    if not data:
                        return []
                    if isinstance(data, str):
                        try:
                            data = json.loads(data)
                        except Exception:
                            if ',' in data:
                                data = [p.strip() for p in data.split(',') if p.strip()]
                            else:
                                data = [data]
                    if isinstance(data, list):
                        items = []
                        for itm in data:
                            if isinstance(itm, str):
                                items.append(itm)
                            elif isinstance(itm, dict):
                                val = itm.get('name') or itm.get('vendor') or itm.get('vendor_name') or itm.get('product')
                                if val:
                                    items.append(val)
                        return items
                    return []

                weekly_candidates = (
                    self.session.query(Vulnerability)
                    .filter(
                        or_(
                            Vulnerability.published_date >= week_ago,
                            Vulnerability.last_update >= week_ago
                        ),
                        Vulnerability.cvss_score.isnot(None)
                    )
                    .all()
                )
                result_items = []
                for v in weekly_candidates:
                    try:
                        vnames = [str(x).strip().lower() for x in _parse_list_field(v.nvd_vendors_data)]
                        if any(vn in selected_vendor_names_lower for vn in vnames):
                            result_items.append(v)
                    except Exception:
                        continue

            for vuln in result_items:
                score = vuln.cvss_score
                if score < 4.0:
                    cvss_ranges['0.0-3.9'] += 1
                elif score < 7.0:
                    cvss_ranges['4.0-6.9'] += 1
                elif score < 9.0:
                    cvss_ranges['7.0-8.9'] += 1
                else:
                    cvss_ranges['9.0-10.0'] += 1

            return cvss_ranges
        except Exception as e:
            raise RuntimeError(f"Error fetching weekly CVSS distribution for all severities: {e}")

    def get_cvss_distribution_by_severity_all(self, severity: str, vendor_ids: Optional[List[int]] = None) -> Dict[str, int]:
        """
        Get CVSS score distribution for all CVEs of a given severity (no date restriction).

        Args:
            severity: Severity level (e.g., 'CRITICAL', 'HIGH', 'MEDIUM', 'LOW').

        Returns:
            Dictionary mapping CVSS ranges to counts across ALL records for that severity.
        """
        try:
            cvss_ranges = {
                '0.0-3.9': 0,
                '4.0-6.9': 0,
                '7.0-8.9': 0,
                '9.0-10.0': 0
            }

            query = self.session.query(Vulnerability).filter(
                Vulnerability.base_severity == severity.upper(),
                Vulnerability.cvss_score.isnot(None)
            )
            # Vendor-scoped filtering when vendor_ids provided (via union of CVEVendor and Product.vendor_id)
            try:
                if vendor_ids:
                    from sqlalchemy import union
                    from app.models.cve_vendor import CVEVendor
                    from app.models.cve_product import CVEProduct
                    from app.models.product import Product
                    cves_por_vendor = (
                        self.session
                        .query(CVEVendor.cve_id)
                        .filter(CVEVendor.vendor_id.in_(vendor_ids))
                    )
                    cves_por_produto_vendor = (
                        self.session
                        .query(CVEProduct.cve_id)
                        .join(Product, Product.id == CVEProduct.product_id)
                        .filter(Product.vendor_id.in_(vendor_ids))
                    )
                    cves_unificados_sq = union(cves_por_vendor, cves_por_produto_vendor).subquery()
                    query = query.filter(
                        Vulnerability.cve_id.in_(self.session.query(cves_unificados_sq.c.cve_id))
                    ).distinct()
            except Exception:
                pass

            query = query.all()

            # Fallback: if vendor_ids provided and normalized associations return empty, use JSON vendor-aware filter
            if vendor_ids and not query:
                selected_vendor_names_lower = set()
                try:
                    from app.models.vendor import Vendor
                    vendors = (
                        self.session.query(Vendor.id, Vendor.name)
                        .filter(Vendor.id.in_(vendor_ids))
                        .all()
                    )
                    for _vid, _vname in vendors:
                        if _vname:
                            selected_vendor_names_lower.add(str(_vname).strip().lower())
                except Exception:
                    selected_vendor_names_lower = set()

                def _parse_list_field(raw):
                    data = raw
                    if not data:
                        return []
                    if isinstance(data, str):
                        try:
                            data = json.loads(data)
                        except Exception:
                            if ',' in data:
                                data = [p.strip() for p in data.split(',') if p.strip()]
                            else:
                                data = [data]
                    if isinstance(data, list):
                        items = []
                        for itm in data:
                            if isinstance(itm, str):
                                items.append(itm)
                            elif isinstance(itm, dict):
                                val = itm.get('name') or itm.get('vendor') or itm.get('vendor_name') or itm.get('product')
                                if val:
                                    items.append(val)
                        return items
                    return []

                all_candidates = (
                    self.session.query(Vulnerability)
                    .filter(
                        Vulnerability.base_severity == severity.upper(),
                        Vulnerability.cvss_score.isnot(None)
                    )
                    .all()
                )
                query = []
                for v in all_candidates:
                    try:
                        vnames = [str(x).strip().lower() for x in _parse_list_field(v.nvd_vendors_data)]
                        if any(vn in selected_vendor_names_lower for vn in vnames):
                            query.append(v)
                    except Exception:
                        continue

            for vuln in query:
                score = float(vuln.cvss_score)
                if score < 4.0:
                    cvss_ranges['0.0-3.9'] += 1
                elif score < 7.0:
                    cvss_ranges['4.0-6.9'] += 1
                elif score < 9.0:
                    cvss_ranges['7.0-8.9'] += 1
                else:
                    cvss_ranges['9.0-10.0'] += 1

            return cvss_ranges
        except Exception as e:
            raise RuntimeError(f"Error fetching ALL-time CVSS distribution for severity {severity}: {e}")
    
    def update_last_sync_time(self, sync_time: datetime) -> None:
        """
        Update the last synchronization time in sync metadata.
        
        Args:
            sync_time: The datetime to set as the last sync time
        """
        try:
            from app.models.sync_metadata import SyncMetadata
            sync_record = self.session.query(SyncMetadata).filter_by(
                key='nvd_last_sync'
            ).first()
            
            # Convert datetime to ISO string
            sync_time_str = sync_time.isoformat(timespec='milliseconds').replace('+00:00', 'Z')
            
            if sync_record:
                sync_record.value = sync_time_str
                # Mark sync as completed and update last_modified
                sync_record.status = 'completed'
                sync_record.last_modified = sync_time
            else:
                # Create new sync record if it doesn't exist
                sync_record = SyncMetadata(
                    key='nvd_last_sync',
                    value=sync_time_str,
                    status='completed',
                    last_modified=sync_time
                )
                self.session.add(sync_record)
            
            self.session.commit()
            
        except Exception as e:
            self.session.rollback()
            raise RuntimeError(f"Error updating last sync time: {e}")

    def ensure_vendor_associations_for_vendor(self, vendor_name: str, limit: int = 10000) -> int:
        """Garante que existam associaÃ§Ãµes CVEVendor para um determinado vendor, usando dados JSON NVD.
        Retorna o nÃºmero de associaÃ§Ãµes criadas.
        """
        try:
            from sqlalchemy import func, text
            from app.models.vendor import Vendor
            from app.models.cve_vendor import CVEVendor
            from app.models.vulnerability import Vulnerability
            # Encontrar ou criar vendor
            vendor = self.session.query(Vendor).filter(func.lower(Vendor.name) == vendor_name.lower()).first()
            if not vendor:
                vendor = Vendor(name=vendor_name)
                self.session.add(vendor)
                self.session.flush()

            # Coletar CVEs jÃ¡ associadas
            existing = set(
                row[0] for row in self.session.query(CVEVendor.cve_id).filter(CVEVendor.vendor_id == vendor.id).all()
            )

            # Procurar CVEs pelo JSON de vendors (com fallback Python)
            sql = """
                SELECT v.cve_id
                FROM vulnerabilities v, json_each(v.nvd_vendors_data) AS vendor_data
                WHERE v.nvd_vendors_data IS NOT NULL
                  AND (
                      LOWER(vendor_data.value) = LOWER(:vendor_name)
                      OR LOWER(json_extract(vendor_data.value, '$.name')) = LOWER(:vendor_name)
                  )
                LIMIT :limit
            """
            cve_ids = []
            try:
                result = self.session.execute(text(sql), {"vendor_name": vendor_name, "limit": limit})
                cve_ids = [row[0] for row in result.fetchall()]
            except Exception:
                # Fallback Python: varrer vulnerabilidades e comparar vendor no dado JSON
                vname = vendor_name.lower()
                vulns = (
                    self.session.query(Vulnerability)
                    .filter(Vulnerability.nvd_vendors_data.isnot(None))
                    .limit(limit)
                    .all()
                )
                tmp_ids = []
                for v in vulns:
                    data = v.nvd_vendors_data
                    parsed = data
                    if isinstance(data, str):
                        try:
                            parsed = json.loads(data)
                        except Exception:
                            parsed = data

                    names = []
                    if isinstance(parsed, list):
                        for item in parsed:
                            if isinstance(item, str):
                                names.append(item)
                            elif isinstance(item, dict):
                                val = item.get('name') or item.get('vendor') or item.get('vendor_name')
                                if val:
                                    names.append(val)
                    elif isinstance(parsed, dict):
                        if 'vendors' in parsed and isinstance(parsed['vendors'], list):
                            for itm in parsed['vendors']:
                                if isinstance(itm, str):
                                    names.append(itm)
                                elif isinstance(itm, dict):
                                    val = itm.get('name') or itm.get('vendor') or itm.get('vendor_name')
                                    if val:
                                        names.append(val)
                        elif 'name' in parsed:
                            names.append(parsed['name'])
                        else:
                            for key in parsed.keys():
                                if isinstance(key, str):
                                    names.append(key)
                    elif isinstance(parsed, str):
                        names.append(parsed)

                    for nm in names:
                        if isinstance(nm, str) and nm.strip().lower() == vname:
                            tmp_ids.append(v.cve_id)
                            break

                # Deduplicar mantendo ordem
                cve_ids = list(dict.fromkeys(tmp_ids))

            created = 0
            for cve_id in cve_ids:
                if cve_id in existing:
                    continue
                self.session.add(CVEVendor(cve_id=cve_id, vendor_id=vendor.id))
                created += 1

            if created > 0:
                self.session.flush()
                self.session.commit()
            return created
        except Exception as e:
            self.session.rollback()
            # NÃ£o propagar erro crÃ­tico; retornar zero e permitir fallback
            return 0
    
    def _process_vendors(self, cve_id: str, vendors: List[str]) -> None:
        """Process and save vendor data for a CVE."""
        try:
            from app.models.vendor import Vendor
            from app.models.cve_vendor import CVEVendor
            
            # Remove existing vendor associations for this CVE
            self.session.query(CVEVendor).filter_by(cve_id=cve_id).delete()
            
            for vendor_name in vendors:
                # Check if vendor exists, create if not
                vendor = self.session.query(Vendor).filter_by(name=vendor_name).first()
                if not vendor:
                    vendor = Vendor(name=vendor_name)
                    self.session.add(vendor)
                    self.session.flush()  # Get the ID
                
                # Create CVE-Vendor association
                cve_vendor = CVEVendor(cve_id=cve_id, vendor_id=vendor.id)
                self.session.add(cve_vendor)
                
        except Exception as e:
            raise RuntimeError(f"Error processing vendors for {cve_id}: {e}")
    
    def _process_products(self, cve_id: str, products: List[str]) -> None:
        """Process and save product data for a CVE."""
        try:
            from app.models.product import Product
            from app.models.cve_product import CVEProduct
            from app.models.vendor import Vendor
            
            # Remove existing product associations for this CVE
            self.session.query(CVEProduct).filter_by(cve_id=cve_id).delete()
            
            for product_name in products:
                # Check if product exists, create if not
                product = self.session.query(Product).filter_by(name=product_name).first()
                if not product:
                    # Get or create a default vendor for unknown products
                    default_vendor = self.session.query(Vendor).filter_by(name='Unknown').first()
                    if not default_vendor:
                        default_vendor = Vendor(name='Unknown')
                        self.session.add(default_vendor)
                        self.session.flush()  # Get the ID
                    
                    product = Product(name=product_name, vendor_id=default_vendor.id)
                    self.session.add(product)
                    self.session.flush()  # Get the ID
                
                # Create CVE-Product association
                cve_product = CVEProduct(cve_id=cve_id, product_id=product.id)
                self.session.add(cve_product)
                
        except Exception as e:
            raise RuntimeError(f"Error processing products for {cve_id}: {e}")

    def get_vulnerabilities_by_asset(self, asset_id: int):
        """Retorna vulnerabilidades correlacionadas a um ativo pelos produtos vinculados e metadados.

        EstratÃ©gia:
        - Seleciona produtos vinculados ao ativo via AssetProduct.
        - Filtra vulnerabilidades associadas a esses produtos por CVEProduct.
        - Correlaciona por VersionReference/AffectedProduct usando regex contra installed_version.
        - Aplica filtros auxiliares por modelo e sistema operacional na descriÃ§Ã£o.
        """
        from sqlalchemy import union
        import re
        try:
            from app.models.asset_product import AssetProduct
            from app.models.cve_product import CVEProduct
            from app.models.vulnerability import Vulnerability
            from app.models.version_reference import VersionReference
            from app.models.affected_product import AffectedProduct
        except Exception:
            return []

        asset_products = (
            self.session.query(AssetProduct)
            .filter(AssetProduct.asset_id == asset_id)
            .all()
        )
        if not asset_products:
            return []

        product_ids = [ap.product_id for ap in asset_products if ap.product_id]
        base_query = self.session.query(Vulnerability)
        cve_ids = set()
        if product_ids:
            cve_ids.update([row[0] for row in (
                self.session.query(CVEProduct.cve_id)
                .filter(CVEProduct.product_id.in_(product_ids))
                .all()
            )])
            cve_ids.update([row[0] for row in (
                self.session.query(VersionReference.cve_id)
                .filter(VersionReference.product_id.in_(product_ids))
                .all()
            )])

        if cve_ids:
            base_query = base_query.filter(Vulnerability.cve_id.in_(list(cve_ids))).distinct()

        vulns = base_query.all()
        if not vulns:
            return []

        # PÃ³s-processamento por regex: versÃ£o / modelo / SO
        meta_by_pid = {}
        for ap in asset_products:
            meta_by_pid.setdefault(ap.product_id, []).append({
                'model_name': (ap.model_name or '').strip(),
                'operating_system': (ap.operating_system or '').strip(),
                'installed_version': (ap.installed_version or '').strip(),
            })

        def matches_meta(v: Vulnerability) -> bool:
            if not meta_by_pid:
                return True
            desc = (v.description or '').lower()
            refs = self.session.query(VersionReference).filter(VersionReference.cve_id == v.cve_id).all()
            # Corrigir FK: Vulnerability usa chave primÃ¡ria 'cve_id', nÃ£o 'id'
            affs = self.session.query(AffectedProduct).filter(AffectedProduct.vulnerability_id == v.cve_id).all()
            affected_map = {}
            for r in refs:
                affected_map.setdefault(r.product_id, []).append(r.affected_version or '')
            for a in affs:
                affected_map.setdefault(a.product_id, []).append(a.affected_versions or '')
            for pid, metas in meta_by_pid.items():
                for meta in metas:
                    model = meta['model_name'].lower() if meta['model_name'] else ''
                    os_ = meta['operating_system'].lower() if meta['operating_system'] else ''
                    installed = meta['installed_version']
                    model_ok = True if not model else (model in desc)
                    os_ok = True if not os_ else (os_ in desc)
                    version_ok = True
                    if installed:
                        patterns = [p for p in affected_map.get(pid, []) if p]
                        if patterns:
                            version_ok = False
                            for pat in patterns:
                                try:
                                    rx = re.compile(pat.strip(), flags=re.IGNORECASE)
                                    if rx.search(installed):
                                        version_ok = True
                                        break
                                except re.error:
                                    if pat.lower() in installed.lower():
                                        version_ok = True
                                        break
                    if model_ok and os_ok and version_ok:
                        return True
            return False

        filtered = [v for v in vulns if matches_meta(v)]
        return filtered

    def _process_parts(self, cve_id: str, cpe_configurations: List[Dict]) -> None:
        """Extrai e persiste os "parts" das CPEs para uma CVE.

        Args:
            cve_id: Identificador CVE
            cpe_configurations: Lista de configuraÃ§Ãµes CPE (estrutura NVD 2.0)
        """
        try:
            from app.models.cve_part import CVEPart

            # Remover associaÃ§Ãµes anteriores para esta CVE
            self.session.query(CVEPart).filter_by(cve_id=cve_id).delete()

            parts_found = set()
            for config in cpe_configurations or []:
                nodes = config.get('nodes', []) if isinstance(config, dict) else []
                for node in nodes:
                    cpe_matches = node.get('cpeMatch', []) if isinstance(node, dict) else []
                    for cpe_match in cpe_matches:
                        cpe_uri = cpe_match.get('criteria', '') if isinstance(cpe_match, dict) else ''
                        if isinstance(cpe_uri, str) and cpe_uri.startswith('cpe:2.3:'):
                            parts = cpe_uri.split(':')
                            if len(parts) > 2:
                                part_letter = parts[2]
                                if part_letter in ('a', 'o', 'h'):
                                    parts_found.add(part_letter)

            for part_letter in parts_found:
                self.session.add(CVEPart(cve_id=cve_id, part=part_letter))

        except Exception as e:
            raise RuntimeError(f"Error processing CPE parts for {cve_id}: {e}")
    
    def _process_weaknesses(self, cve_id: str, weaknesses: List[str]) -> None:
        """Process and save weakness (CWE) data for a CVE."""
        try:
            from app.models.weakness import Weakness
            
            # Remove existing weakness associations for this CVE
            self.session.query(Weakness).filter_by(cve_id=cve_id).delete()
            
            for cwe_id in weaknesses:
                # Create weakness association
                weakness = Weakness(cve_id=cve_id, cwe_id=cwe_id)
                self.session.add(weakness)
                
        except Exception as e:
            raise RuntimeError(f"Error processing weaknesses for {cve_id}: {e}")
    
    def _process_references(self, cve_id: str, references: List[Dict]) -> None:
        """
        Process and save references for a CVE.
        
        Args:
            cve_id: CVE identifier
            references: List of reference dictionaries with url, source, tags
        """
        try:
            from app.models.references import Reference
            
            # Remove existing references for this CVE
            self.session.query(Reference).filter_by(cve_id=cve_id).delete()
            
            # Add new references
            for ref_data in references:
                url = ref_data.get('url')
                source = ref_data.get('source')
                tags = ref_data.get('tags', [])
                
                if url:
                    # Convert tags list to comma-separated string
                    tags_str = ', '.join(tags) if tags else None
                    
                    # Check if this reference indicates a patch
                    patch_tags = ['Patch', 'Vendor Advisory', 'Mitigation', 'Fix']
                    is_patch = any(tag in tags for tag in patch_tags) if tags else False
                    
                    reference = Reference(
                        cve_id=cve_id,
                        url=url,
                        source=source,
                        tags=tags_str,
                        is_patch=is_patch
                    )
                    self.session.add(reference)
        
        except Exception as e:
            raise RuntimeError(f"Error processing version ranges for {cve_id}: {e}")
    
    def _process_version_ranges(self, cve_id: str, version_ranges: List[Dict]):
        """
        Process and save version range information for a vulnerability.
        
        Args:
            cve_id: The CVE ID
            version_ranges: List of version range dictionaries
        """
        try:
            from app.models.version_reference import VersionReference
            from app.models.affected_product import AffectedProduct
            from app.models.product import Product
            
            # Remove existing version references for this CVE
            self.session.query(VersionReference).filter_by(cve_id=cve_id).delete()
            
            # Process each version range
            for version_range in version_ranges:
                vendor = version_range.get('vendor')
                product_name = version_range.get('product')
                
                if not vendor or not product_name:
                    continue
                
                # Find or create vendor first
                from app.models.vendor import Vendor
                vendor_obj = self.session.query(Vendor).filter_by(name=vendor).first()
                if not vendor_obj:
                    vendor_obj = Vendor(name=vendor)
                    self.session.add(vendor_obj)
                    self.session.flush()  # Get the ID
                
                # Find or create product
                product = self.session.query(Product).filter_by(
                    name=product_name,
                    vendor_id=vendor_obj.id
                ).first()
                
                if not product:
                    product = Product(name=product_name, vendor_id=vendor_obj.id)
                    self.session.add(product)
                    self.session.flush()  # Get the ID
                
                # Create version reference only if we have a valid affected version
                affected_version = version_range.get('version')
                if not affected_version:
                    # If no specific version, use version range info to construct one
                    if version_range.get('version_start_including'):
                        affected_version = f">= {version_range['version_start_including']}"
                    elif version_range.get('version_start_excluding'):
                        affected_version = f"> {version_range['version_start_excluding']}"
                    elif version_range.get('version_end_including'):
                        affected_version = f"<= {version_range['version_end_including']}"
                    elif version_range.get('version_end_excluding'):
                        affected_version = f"< {version_range['version_end_excluding']}"
                    else:
                        affected_version = "*"  # Fallback for unknown version
                
                version_ref = VersionReference(
                    cve_id=cve_id,
                    product_id=product.id,
                    affected_version=affected_version,
                    fixed_version=None  # Will be determined from version ranges
                )
                
                # Determine fixed version from version ranges
                if version_range.get('version_end_including'):
                    version_ref.fixed_version = version_range.get('version_end_including')
                elif version_range.get('version_end_excluding'):
                    version_ref.fixed_version = version_range.get('version_end_excluding')
                
                self.session.add(version_ref)
                
                # Create or update affected product entry
                affected_product = self.session.query(AffectedProduct).filter_by(
                    vulnerability_id=cve_id,
                    product_id=product.id
                ).first()
                
                if not affected_product:
                    # Build affected versions string from version range
                    affected_versions_parts = []
                    
                    if version_range.get('version'):
                        affected_versions_parts.append(f"v{version_range['version']}")
                    
                    if version_range.get('version_start_including'):
                        affected_versions_parts.append(f">= {version_range['version_start_including']}")
                    elif version_range.get('version_start_excluding'):
                        affected_versions_parts.append(f"> {version_range['version_start_excluding']}")
                    
                    if version_range.get('version_end_including'):
                        affected_versions_parts.append(f"<= {version_range['version_end_including']}")
                    elif version_range.get('version_end_excluding'):
                        affected_versions_parts.append(f"< {version_range['version_end_excluding']}")
                    
                    affected_versions_str = ", ".join(affected_versions_parts) if affected_versions_parts else None
                    
                    affected_product = AffectedProduct(
                        vulnerability_id=cve_id,
                        product_id=product.id,
                        affected_versions=affected_versions_str
                    )
                    self.session.add(affected_product)
            
        except Exception as e:
            raise RuntimeError(f"Error processing references for {cve_id}: {e}")

    def sync_asset_vulnerabilities_for_asset(self, asset_id: int, limit_per_asset: int = 1000) -> int:
        from app.models.asset import Asset
        from app.models.asset_vulnerability import AssetVulnerability
        from app.models.cve_vendor import CVEVendor
        from app.models.vulnerability import Vulnerability

        created_count = 0
        asset = self.session.query(Asset).get(asset_id)
        if not asset or not asset.vendor_id:
            return 0

        cve_ids: list[str] = []
        cve_set = set()

        cve_query = self.session.query(CVEVendor.cve_id).filter(CVEVendor.vendor_id == asset.vendor_id)
        if limit_per_asset and limit_per_asset > 0:
            cve_query = cve_query.limit(limit_per_asset)
        for row in cve_query.all():
            cid = row[0]
            if cid and cid not in cve_set:
                cve_set.add(cid)
                cve_ids.append(cid)

        try:
            correlated = self.get_vulnerabilities_by_asset(asset.id)
            for v in correlated:
                cid = getattr(v, 'cve_id', None)
                if cid and cid not in cve_set:
                    cve_set.add(cid)
                    cve_ids.append(cid)
        except Exception:
            pass

        # Fallback: use JSON vendors data (NVD) if CVEVendor associations are not populated
        if not cve_ids:
            from sqlalchemy import text
            vendor_name = asset.vendor.name if asset.vendor else None
            if vendor_name:
                # Tentar criar associaÃ§Ãµes CVEVendor a partir dos dados JSON antes de consultar
                try:
                    self.ensure_vendor_associations_for_vendor(vendor_name, limit=(limit_per_asset or 1000))
                    # Reconsultar associaÃ§Ãµes CVEVendor apÃ³s backfill
                    cve_ids = [row[0] for row in self.session.query(CVEVendor.cve_id)
                               .filter(CVEVendor.vendor_id == asset.vendor_id)
                               .limit(limit_per_asset or 1000)
                               .all()]
                except Exception:
                    # Prosseguir com fallback SQL
                    pass

                sql = """
                SELECT v.cve_id
                FROM vulnerabilities v, json_each(v.nvd_vendors_data) AS vendor_data
                WHERE v.nvd_vendors_data IS NOT NULL
                  AND (
                      LOWER(vendor_data.value) = LOWER(:vendor_name)
                      OR LOWER(json_extract(vendor_data.value, '$.name')) = LOWER(:vendor_name)
                  )
                LIMIT :limit
                """
                try:
                    result = self.session.execute(text(sql), {
                        "vendor_name": vendor_name,
                        "limit": (limit_per_asset or 1000)
                    })
                    cve_ids = [row[0] for row in result.fetchall()]
                except Exception:
                    # Fallback Python quando JSON1 nÃ£o estÃ¡ disponÃ­vel
                    from app.models.vulnerability import Vulnerability
                    vname = vendor_name.lower()
                    vulns = (
                        self.session.query(Vulnerability)
                        .filter(Vulnerability.nvd_vendors_data.isnot(None))
                        .limit(limit_per_asset or 1000)
                        .all()
                    )
                    tmp_ids = []
                    for v in vulns:
                        data = v.nvd_vendors_data
                        parsed = data
                        if isinstance(data, str):
                            try:
                                parsed = json.loads(data)
                            except Exception:
                                parsed = data

                        names = []
                        if isinstance(parsed, list):
                            for item in parsed:
                                if isinstance(item, str):
                                    names.append(item)
                                elif isinstance(item, dict):
                                    val = item.get('name') or item.get('vendor') or item.get('vendor_name')
                                    if val:
                                        names.append(val)
                        elif isinstance(parsed, dict):
                            if 'vendors' in parsed and isinstance(parsed['vendors'], list):
                                for itm in parsed['vendors']:
                                    if isinstance(itm, str):
                                        names.append(itm)
                                    elif isinstance(itm, dict):
                                        val = itm.get('name') or itm.get('vendor') or itm.get('vendor_name')
                                        if val:
                                            names.append(val)
                            elif 'name' in parsed:
                                names.append(parsed['name'])
                            else:
                                for key in parsed.keys():
                                    if isinstance(key, str):
                                        names.append(key)
                        elif isinstance(parsed, str):
                            names.append(parsed)

                        for nm in names:
                            if isinstance(nm, str) and nm.strip().lower() == vname:
                                tmp_ids.append(v.cve_id)
                                break

                    cve_ids = list(dict.fromkeys(tmp_ids))

        if not cve_ids:
            return 0

        existing = set(
            row[0] for row in self.session.query(AssetVulnerability.vulnerability_id)
            .filter(AssetVulnerability.asset_id == asset.id)
            .all()
        )

        # Create missing associations
        batch_size = 500
        batch = 0
        try:
            for cve_id in cve_ids:
                if cve_id in existing:
                    continue
                av = AssetVulnerability(asset_id=asset.id, vulnerability_id=cve_id, status='OPEN')
                self.session.add(av)
                created_count += 1
                batch += 1
                if batch >= batch_size:
                    self.session.flush()
                    self.session.commit()
                    batch = 0

            if batch > 0:
                self.session.flush()
                self.session.commit()
        except Exception:
            self.session.rollback()
            raise

        return created_count

    def sync_all_assets(self, limit_per_asset: int = 1000, only_active: bool = True) -> int:
        """Create AssetVulnerability links for all assets with a vendor assigned.
        Returns total number of created associations across all assets.
        """
        from app.models.asset import Asset
        total_created = 0
        q = self.session.query(Asset).filter(Asset.vendor_id.isnot(None))
        if only_active:
            q = q.filter(Asset.status == 'active')
        assets = q.all()
        for asset in assets:
            total_created += self.sync_asset_vulnerabilities_for_asset(asset.id, limit_per_asset=limit_per_asset)
        return total_created
