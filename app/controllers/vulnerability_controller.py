# controllers/vulnerability_controller.py

import re
import io
import logging
from datetime import datetime, timedelta
from typing import Any, Dict
from flask import (
    Blueprint, request, flash, redirect, url_for,
    current_app, jsonify, abort, render_template, Response, send_file
)
from flask_login import login_required, current_user
# CSRF protection is handled at blueprint level
from sqlalchemy.exc import SQLAlchemyError
from werkzeug.exceptions import BadRequest, NotFound

from app.extensions import db
from app.models.vulnerability import Vulnerability
from app.models.asset import Asset
from app.models.asset_vulnerability import AssetVulnerability
from app.models.cve_vendor import CVEVendor
from app.models.vendor import Vendor
from app.models.sync_metadata import SyncMetadata
from app.models.enums import severity_levels
from sqlalchemy.orm import joinedload
from app.services.vulnerability_service import VulnerabilityService
from app.services.risk_report_service import RiskReportService
from app.schemas.vulnerability_schema import VulnerabilitySchema
from app.forms.vulnerability_form import VulnerabilityForm
from app.forms.common_form import DeleteForm
from app.utils.pagination import paginate_query

logger = logging.getLogger(__name__)

# Blueprints
vuln_ui_bp = Blueprint('vulnerability_ui', __name__, url_prefix='/vulnerabilities')
vuln_api_bp = Blueprint('vulnerability_api', __name__, url_prefix='/api/v1/vulnerabilities')

# Legacy API blueprint to support non-versioned endpoints
# This ensures backward compatibility for clients using '/api/vulnerabilities' without 'v1'
vuln_api_legacy_bp = Blueprint('vulnerability_api_legacy', __name__, url_prefix='/api/vulnerabilities')

# Wrapper routes delegating to the versioned API implementations
@vuln_api_legacy_bp.route('', methods=['GET'])
def list_vulnerabilities_api_legacy():
    return list_vulnerabilities_api()

@vuln_api_legacy_bp.route('/<string:cve_id>', methods=['GET'])
def get_vulnerability_api_legacy(cve_id: str):
    return get_vulnerability_api(cve_id)

@vuln_api_legacy_bp.route('/<string:cve_id>', methods=['PATCH'])
def update_vulnerability_api_legacy(cve_id: str):
    return update_vulnerability_api(cve_id)

@vuln_api_legacy_bp.route('/<string:cve_id>/mitigate', methods=['POST'])
def mitigate_vulnerability_api_legacy(cve_id: str):
    return mitigate_vulnerability_api(cve_id)

@vuln_api_legacy_bp.route('/<string:cve_id>', methods=['DELETE'])
def delete_vulnerability_api_legacy(cve_id: str):
    return delete_vulnerability_api(cve_id)

@vuln_api_legacy_bp.route('/<string:cve_id>/risk-report', methods=['GET'])
def get_risk_report_api_legacy(cve_id: str):
    return get_risk_report_api(cve_id)

# Service and schemas
vuln_service     = VulnerabilityService(db.session)
risk_service     = RiskReportService()
vuln_schema      = VulnerabilitySchema()
vuln_list_schema = VulnerabilitySchema(many=True)

# Regex para validar CVE ID
CVE_PATTERN = re.compile(r'^CVE-\d{4}-\d+$', re.IGNORECASE)

# ──────────────────────────────────────────────────────────────────────────────
# UI Routes
# ──────────────────────────────────────────────────────────────────────────────

@vuln_ui_bp.route('/', methods=['GET'])
def list_vulnerabilities_ui():
    """Lista vulnerabilidades com filtro de severidade e paginação otimizada."""
    logger.info("=== INICIANDO list_vulnerabilities_ui ===")
    page     = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    severity = request.args.get('severity')
    # Novos filtros: vendors selecionados
    vendor_ids_param = request.args.get('vendor_ids', '')
    vendor_ids_list = request.args.getlist('vendor_ids')
    selected_vendor_ids = []
    if vendor_ids_list:
        try:
            selected_vendor_ids = [int(v) for v in vendor_ids_list if str(v).strip()]
        except ValueError:
            selected_vendor_ids = []
    elif vendor_ids_param:
        try:
            selected_vendor_ids = [int(v) for v in vendor_ids_param.split(',') if v.strip()]
        except ValueError:
            selected_vendor_ids = []
    # Novos filtros avançados de UI
    search = (request.args.get('search', '', type=str) or '').strip()
    cvss_range = request.args.get('cvss_range', '', type=str) or ''
    date_range = request.args.get('date_range', '', type=str) or ''
    start_date = request.args.get('start_date', '', type=str) or ''
    end_date = request.args.get('end_date', '', type=str) or ''
    product = (request.args.get('product', '', type=str) or '').strip()
    mitigation_status = request.args.get('mitigation_status', '', type=str) or ''
    vuln_type = request.args.get('vuln_type', '', type=str) or ''
    sort_param = request.args.get('sort', 'published_date_desc', type=str) or 'published_date_desc'
    # Aplicar preferências padrão de vendors quando nenhuma foi fornecida
    if not selected_vendor_ids and current_user.is_authenticated:
        try:
            key = f'user_vendor_preferences:{current_user.id}'
            pref = db.session.query(SyncMetadata).filter_by(key=key).first()
            if pref and pref.value:
                selected_vendor_ids = [int(v.strip()) for v in pref.value.split(',') if v.strip().isdigit()]
        except Exception as e:
            current_app.logger.warning('Falha ao carregar preferências padrão de vendors.', exc_info=e)
    logger.info(f"Parâmetros: page={page}, per_page={per_page}, severity={severity}, vendor_ids={selected_vendor_ids}, search='{search}', cvss_range='{cvss_range}', date_range='{date_range}', start_date='{start_date}', end_date='{end_date}', product='{product}', mitigation_status='{mitigation_status}', vuln_type='{vuln_type}', sort='{sort_param}'")
    
    # Validar per_page para evitar valores excessivos
    if per_page < 1 or per_page > 100:
        per_page = 20
    
    # Validar página
    if page < 1:
        page = 1

    if severity and severity.upper() not in severity_levels.enums:
        flash(f"Severidade inválida: {severity}", 'warning')
        severity = None
    elif severity:
        severity = severity.upper()

    try:
        # TESTE: Usar query raw para contornar problema do SQLAlchemy
        from sqlalchemy import text
        
        # Query base
        sql_query = """
        SELECT cve_id, description, published_date, base_severity, cvss_score, 
               patch_available, assigner, source_identifier, vuln_status,
               nvd_vendors_data, nvd_products_data
        FROM vulnerabilities
        """
        
        # Construção dinâmica de filtros
        params = {}
        where_clauses = []
        if severity and severity != 'all':
            where_clauses.append("base_severity = :severity")
            params['severity'] = severity.upper()
        if selected_vendor_ids:
            vendor_placeholders = []
            for i, vid in enumerate(selected_vendor_ids):
                key = f"vid_{i}"
                vendor_placeholders.append(f":{key}")
                params[key] = vid
            where_clauses.append(
                f"cve_id IN (SELECT cve_id FROM cve_vendors WHERE vendor_id IN ({', '.join(vendor_placeholders)}))"
            )
        # Filtro de busca (CVE ID ou descrição)
        if search:
            where_clauses.append("(LOWER(description) LIKE :search OR UPPER(cve_id) LIKE :search_cve)")
            params['search'] = f"%{search.lower()}%"
            params['search_cve'] = f"%{search.upper()}%"
        # Filtro de faixa CVSS "min-max"
        if cvss_range:
            try:
                parts = [p.strip() for p in cvss_range.split('-')]
                if len(parts) == 2:
                    min_cvss = float(parts[0])
                    max_cvss = float(parts[1])
                    where_clauses.append("cvss_score BETWEEN :min_cvss AND :max_cvss")
                    params['min_cvss'] = min_cvss
                    params['max_cvss'] = max_cvss
            except Exception:
                pass
        # Filtro por período relativo (dias)
        if date_range:
            try:
                days = int(date_range)
                cutoff = datetime.utcnow() - timedelta(days=days)
                where_clauses.append("published_date >= :cutoff_date")
                params['cutoff_date'] = cutoff.isoformat()
            except Exception:
                pass
        # Filtro por intervalo de datas absolutos
        if start_date:
            try:
                sd = datetime.strptime(start_date, '%Y-%m-%d')
                where_clauses.append("published_date >= :start_date")
                params['start_date'] = sd.isoformat()
            except Exception:
                pass
        if end_date:
            try:
                ed = datetime.strptime(end_date, '%Y-%m-%d')
                where_clauses.append("published_date <= :end_date")
                params['end_date'] = ed.isoformat()
            except Exception:
                pass
        # Filtro por produto/vendor (busca em descrição ou JSON de produtos)
        if product:
            where_clauses.append("(LOWER(description) LIKE :product_like OR LOWER(CAST(nvd_products_data AS TEXT)) LIKE :product_like)")
            params['product_like'] = f"%{product.lower()}%"
        # Filtro por status de mitigação
        if mitigation_status:
            where_clauses.append("vuln_status = :mitigation_status")
            params['mitigation_status'] = mitigation_status
        # Filtro por tipo de vulnerabilidade (mapeado para CWE e palavras-chave)
        if vuln_type:
            normalized = vuln_type.strip().lower()
            cwe_ids = []
            description_keywords = []
            if normalized == 'sqli':
                cwe_ids = ['CWE-89']
                description_keywords = ['sql injection']
            elif normalized == 'xss':
                cwe_ids = ['CWE-79']
                description_keywords = ['cross-site scripting', 'xss']
            elif normalized == 'csrf':
                cwe_ids = ['CWE-352']
                description_keywords = ['cross-site request forgery', 'csrf']
            elif normalized == 'information_disclosure':
                cwe_ids = ['CWE-200']
                description_keywords = ['information disclosure', 'information exposure', 'data leak', 'data leakage']
            elif normalized == 'privilege_escalation':
                cwe_ids = ['CWE-862']
                description_keywords = ['privilege escalation', 'elevation of privilege']
            elif normalized == 'rce':
                cwe_ids = ['CWE-78', 'CWE-94', 'CWE-119', 'CWE-787', 'CWE-416']
                description_keywords = ['remote code execution', 'rce', 'code execution']
            elif normalized == 'dos':
                description_keywords = ['denial of service', 'dos']
            vuln_type_subclauses = []
            if cwe_ids:
                cwe_placeholders = []
                for i, cwe in enumerate(cwe_ids):
                    key = f"cwe_{i}"
                    cwe_placeholders.append(f":{key}")
                    params[key] = cwe
                vuln_type_subclauses.append(
                    f"cve_id IN (SELECT cve_id FROM weaknesses WHERE cwe_id IN ({', '.join(cwe_placeholders)}))"
                )
            if description_keywords:
                keyword_conditions = []
                for i, kw in enumerate(description_keywords):
                    key = f"kw_{i}"
                    params[key] = f"%{kw.lower()}%"
                    keyword_conditions.append("LOWER(description) LIKE :" + key)
                vuln_type_subclauses.append("(" + " OR ".join(keyword_conditions) + ")")
            if vuln_type_subclauses:
                where_clauses.append("(" + " OR ".join(vuln_type_subclauses) + ")")
        if where_clauses:
            sql_query += " WHERE " + " AND ".join(where_clauses)

        # Ordenação dinâmica
        order_by_sql = "published_date DESC"
        if sort_param == 'published_date_asc':
            order_by_sql = "published_date ASC"
        elif sort_param == 'cvss_score_desc':
            order_by_sql = "cvss_score DESC"
        elif sort_param == 'cvss_score_asc':
            order_by_sql = "cvss_score ASC"
        elif sort_param == 'severity_desc':
            order_by_sql = "CASE base_severity WHEN 'CRITICAL' THEN 4 WHEN 'HIGH' THEN 3 WHEN 'MEDIUM' THEN 2 WHEN 'LOW' THEN 1 ELSE 0 END DESC"
        elif sort_param == 'severity_asc':
            order_by_sql = "CASE base_severity WHEN 'LOW' THEN 1 WHEN 'MEDIUM' THEN 2 WHEN 'HIGH' THEN 3 WHEN 'CRITICAL' THEN 4 ELSE 0 END ASC"

        sql_query += f" ORDER BY {order_by_sql} LIMIT :limit OFFSET :offset"
        params['limit'] = per_page
        params['offset'] = (page - 1) * per_page
        
        # Executar query
        result = db.session.execute(text(sql_query), params)
        raw_vulnerabilities = result.fetchall()
        
        # Processar dados JSON para converter strings em listas
        import json
        vulnerabilities = []
        for vuln in raw_vulnerabilities:
            # Converter Row para dict para poder modificar
            vuln_dict = dict(vuln._mapping)
            
            # Parse dos campos JSON
            if vuln_dict.get('nvd_vendors_data') and isinstance(vuln_dict['nvd_vendors_data'], str):
                try:
                    vuln_dict['nvd_vendors_data'] = json.loads(vuln_dict['nvd_vendors_data'])
                except (json.JSONDecodeError, TypeError):
                    vuln_dict['nvd_vendors_data'] = []
            elif not vuln_dict.get('nvd_vendors_data'):
                vuln_dict['nvd_vendors_data'] = []
                
            if vuln_dict.get('nvd_products_data') and isinstance(vuln_dict['nvd_products_data'], str):
                try:
                    vuln_dict['nvd_products_data'] = json.loads(vuln_dict['nvd_products_data'])
                except (json.JSONDecodeError, TypeError):
                    vuln_dict['nvd_products_data'] = []
            elif not vuln_dict.get('nvd_products_data'):
                vuln_dict['nvd_products_data'] = []
            
            # Criar objeto simples para o template
            class VulnObject:
                def __init__(self, data):
                    for key, value in data.items():
                        setattr(self, key, value)
            
            vulnerabilities.append(VulnObject(vuln_dict))
        
        # Contar total para paginação (replicando filtros)
        count_sql = "SELECT COUNT(*) FROM vulnerabilities"
        count_params = {}
        count_clauses = []
        if severity and severity != 'all':
            count_clauses.append("base_severity = :severity")
            count_params['severity'] = severity.upper()
        if selected_vendor_ids:
            vendor_placeholders = []
            for i, vid in enumerate(selected_vendor_ids):
                key = f"c_vid_{i}"
                vendor_placeholders.append(f":{key}")
                count_params[key] = vid
            count_clauses.append(
                f"cve_id IN (SELECT cve_id FROM cve_vendors WHERE vendor_id IN ({', '.join(vendor_placeholders)}))"
            )
        # Replicar filtros avançados
        if search:
            count_clauses.append("(LOWER(description) LIKE :c_search OR UPPER(cve_id) LIKE :c_search_cve)")
            count_params['c_search'] = f"%{search.lower()}%"
            count_params['c_search_cve'] = f"%{search.upper()}%"
        if cvss_range:
            try:
                parts = [p.strip() for p in cvss_range.split('-')]
                if len(parts) == 2:
                    min_cvss = float(parts[0])
                    max_cvss = float(parts[1])
                    count_clauses.append("cvss_score BETWEEN :c_min_cvss AND :c_max_cvss")
                    count_params['c_min_cvss'] = min_cvss
                    count_params['c_max_cvss'] = max_cvss
            except Exception:
                pass
        if date_range:
            try:
                days = int(date_range)
                cutoff = datetime.utcnow() - timedelta(days=days)
                count_clauses.append("published_date >= :c_cutoff_date")
                count_params['c_cutoff_date'] = cutoff.isoformat()
            except Exception:
                pass
        if start_date:
            try:
                sd = datetime.strptime(start_date, '%Y-%m-%d')
                count_clauses.append("published_date >= :c_start_date")
                count_params['c_start_date'] = sd.isoformat()
            except Exception:
                pass
        if end_date:
            try:
                ed = datetime.strptime(end_date, '%Y-%m-%d')
                count_clauses.append("published_date <= :c_end_date")
                count_params['c_end_date'] = ed.isoformat()
            except Exception:
                pass
        if product:
            count_clauses.append("(LOWER(description) LIKE :c_product_like OR LOWER(CAST(nvd_products_data AS TEXT)) LIKE :c_product_like)")
            count_params['c_product_like'] = f"%{product.lower()}%"
        if mitigation_status:
            count_clauses.append("vuln_status = :c_mitigation_status")
            count_params['c_mitigation_status'] = mitigation_status
        # Filtro por tipo de vulnerabilidade (mapeado para CWE e palavras-chave)
        if vuln_type:
            normalized = vuln_type.strip().lower()
            cwe_ids = []
            description_keywords = []
            if normalized == 'sqli':
                cwe_ids = ['CWE-89']
                description_keywords = ['sql injection']
            elif normalized == 'xss':
                cwe_ids = ['CWE-79']
                description_keywords = ['cross-site scripting', 'xss']
            elif normalized == 'csrf':
                cwe_ids = ['CWE-352']
                description_keywords = ['cross-site request forgery', 'csrf']
            elif normalized == 'information_disclosure':
                cwe_ids = ['CWE-200']
                description_keywords = ['information disclosure', 'information exposure', 'data leak', 'data leakage']
            elif normalized == 'privilege_escalation':
                cwe_ids = ['CWE-862']
                description_keywords = ['privilege escalation', 'elevation of privilege']
            elif normalized == 'rce':
                cwe_ids = ['CWE-78', 'CWE-94', 'CWE-119', 'CWE-787', 'CWE-416']
                description_keywords = ['remote code execution', 'rce', 'code execution']
            elif normalized == 'dos':
                description_keywords = ['denial of service', 'dos']
            vuln_type_subclauses = []
            if cwe_ids:
                cwe_placeholders = []
                for i, cwe in enumerate(cwe_ids):
                    key = f"c_cwe_{i}"
                    cwe_placeholders.append(f":{key}")
                    count_params[key] = cwe
                vuln_type_subclauses.append(
                    f"cve_id IN (SELECT cve_id FROM weaknesses WHERE cwe_id IN ({', '.join(cwe_placeholders)}))"
                )
            if description_keywords:
                keyword_conditions = []
                for i, kw in enumerate(description_keywords):
                    key = f"c_kw_{i}"
                    count_params[key] = f"%{kw.lower()}%"
                    keyword_conditions.append("LOWER(description) LIKE :" + key)
                vuln_type_subclauses.append("(" + " OR ".join(keyword_conditions) + ")")
            if vuln_type_subclauses:
                count_clauses.append("(" + " OR ".join(vuln_type_subclauses) + ")")
        if count_clauses:
            count_sql += " WHERE " + " AND ".join(count_clauses)
        count_result = db.session.execute(text(count_sql), count_params)
        total = count_result.scalar()
        
        # Criar objeto de paginação manual
        class MockPagination:
            def __init__(self, items, page, per_page, total):
                self.items = items
                self.page = page
                self.per_page = per_page
                self.total = total
                self.pages = (total + per_page - 1) // per_page
                self.has_prev = page > 1
                self.has_next = page < self.pages
                self.prev_num = page - 1 if self.has_prev else None
                self.next_num = page + 1 if self.has_next else None

            def iter_pages(self, left_edge=2, left_current=2, right_current=3, right_edge=2):
                last = 0
                for num in range(1, self.pages + 1):
                    if (
                        num <= left_edge
                        or (num >= self.page - left_current and num <= self.page + right_current)
                        or (num > self.pages - right_edge)
                    ):
                        if last + 1 != num:
                            yield None
                        yield num
                        last = num
        
        pagination = MockPagination(vulnerabilities, page, per_page, total)
        
        logger.info(f"Vulnerabilities encontradas: {len(vulnerabilities)}")
        logger.info(f"Pagination.items: {len(pagination.items)}")
        logger.info(f"Pagination.items é truthy: {bool(pagination.items)}")
        logger.info(f"Total: {total}")

        # Para requisições AJAX, retornar apenas o conteúdo da tabela
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            logger.info("Renderizando template AJAX")
            return render_template(
                'vulnerabilities/table.html',
                vulnerabilities=pagination.items,
                pagination=pagination,
                filters={'severity': severity}
            )

        logger.info("Renderizando template principal")
        return render_template(
            'vulnerabilities/list.html',
            vulnerabilities=pagination.items,
            pagination=pagination,
            filters={'severity': severity}
        )
        
    except Exception as e:
        logger.error(f"Erro ao carregar vulnerabilidades: {e}")
        flash('Erro ao carregar vulnerabilidades. Tente novamente.', 'danger')
        return render_template(
            'vulnerabilities/list.html',
            vulnerabilities=[],
            pagination=None,
            filters={'severity': severity}
        )

@vuln_ui_bp.route('/vendors', methods=['GET'])
def vendor_selection_ui():
    """Página de seleção de fornecedores (vendors) com checkboxes e paginação com filtro por tipo (category_tag)."""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        q = request.args.get('q', '', type=str)
        category_tag = request.args.get('category_tag', '', type=str)
        current_severity = request.args.get('severity', '', type=str) or ''
        try:
            selected_vendor_ids = [int(v) for v in request.args.getlist('vendor_ids') if str(v).strip()]
        except ValueError:
            selected_vendor_ids = []
        # Aplicar preferências padrão de vendors do usuário se nenhuma seleção foi fornecida
        if not selected_vendor_ids:
            try:
                if current_user.is_authenticated:
                    key = f'user_vendor_preferences:{current_user.id}'
                    meta = db.session.query(SyncMetadata).filter_by(key=key).first()
                    if meta and meta.value:
                        selected_vendor_ids = [int(v.strip()) for v in meta.value.split(',') if v.strip().isdigit()]
            except Exception as e:
                current_app.logger.warning("Falha ao carregar preferências de vendors do usuário.", exc_info=e)

        # Mapear category_tag para o "part" da CPE (a=software/application, o=os, h=hardware)
        part_map = {
            'software': 'a',
            'os': 'o',
            'hardware': 'h'
        }
        selected_part = part_map.get(category_tag)

        from sqlalchemy import func, text, or_

        try:
            total_cve_vendor = db.session.query(func.count('*')).select_from(CVEVendor).scalar()
        except SQLAlchemyError as e:
            current_app.logger.warning(
                "Falha ao acessar tabela cve_vendors (contagem). Aplicando fallback via JSON.",
                exc_info=e
            )
            total_cve_vendor = 0

        # Se filtrar por tipo, primeiro montamos um conjunto de CVE IDs que possuem CPE com o part correspondente
        cve_ids_by_part = set()
        if selected_part:
            import json
            vulns_with_cpe = (
                db.session.query(Vulnerability.cve_id, Vulnerability.nvd_cpe_configurations)
                .filter(Vulnerability.nvd_cpe_configurations.isnot(None))
                .all()
            )
            for cve_id, configs in vulns_with_cpe:
                try:
                    configs_list = json.loads(configs) if isinstance(configs, str) else (configs or [])
                except Exception:
                    configs_list = []
                found = False
                for config in configs_list or []:
                    nodes = config.get('nodes', []) if isinstance(config, dict) else []
                    for node in nodes:
                        for cpe_match in node.get('cpeMatch', []) or []:
                            cpe_uri = cpe_match.get('criteria', '')
                            if isinstance(cpe_uri, str) and cpe_uri.startswith('cpe:2.3:'):
                                parts = cpe_uri.split(':')
                                if len(parts) > 2 and parts[2] == selected_part:
                                    cve_ids_by_part.add(cve_id)
                                    found = True
                                    break
                        if found:
                            break
                    if found:
                        break

        if total_cve_vendor and total_cve_vendor > 0:
            # Contagem via tabela normalizada cve_vendors
            cve_counts_query = db.session.query(
                CVEVendor.vendor_id.label('vendor_id'),
                func.count(func.distinct(CVEVendor.cve_id)).label('cve_count')
            )
            if cve_ids_by_part:
                cve_counts_query = cve_counts_query.filter(CVEVendor.cve_id.in_(list(cve_ids_by_part)))
            cve_counts_sq = cve_counts_query.group_by(CVEVendor.vendor_id).subquery()

            query = (
                db.session.query(
                    Vendor.id.label('id'),
                    Vendor.name.label('name'),
                    func.coalesce(cve_counts_sq.c.cve_count, 0).label('cve_count')
                )
                .outerjoin(cve_counts_sq, Vendor.id == cve_counts_sq.c.vendor_id)
                .order_by(Vendor.name.asc())
            )
            if cve_ids_by_part:
                # Restringe vendors aos que possuem CVEs com o tipo selecionado
                eligible_vendor_ids = [row[0] for row in db.session.query(CVEVendor.vendor_id)
                    .filter(CVEVendor.cve_id.in_(list(cve_ids_by_part))).distinct().all()]
                if eligible_vendor_ids:
                    query = query.filter(Vendor.id.in_(eligible_vendor_ids))
                else:
                    # Nenhum vendor com esse tipo; degrade gracefully exibindo todos sem filtro
                    try:
                        current_app.logger.info("Nenhum vendor encontrado para category_tag '%s'; exibindo todos os vendors.", category_tag)
                    except Exception:
                        pass
                    # Não retorna vazio; segue sem aplicar filtro de eligible_vendor_ids
                    # Nota: cve_counts_sq pode produzir contagens 0 para todos, o que é aceitável para exibição.
        else:
            # Fallback: contar via JSON (SQLite) usando Vulnerability.nvd_vendors_data + filtro por part via nvd_cpe_configurations
            from collections import defaultdict
            import json
            vendor_counts = defaultdict(int)
            vulns = db.session.query(Vulnerability.cve_id, Vulnerability.nvd_vendors_data, Vulnerability.nvd_cpe_configurations).all()
            for cve_id, vendors_json, cpe_configs in vulns:
                # Se filtrar por tipo, verifica se o CVE tem pelo menos uma CPE com o part desejado
                if selected_part:
                    try:
                        cfgs = json.loads(cpe_configs) if isinstance(cpe_configs, str) else (cpe_configs or [])
                    except Exception:
                        cfgs = []
                    has_part = False
                    for config in cfgs or []:
                        nodes = config.get('nodes', []) if isinstance(config, dict) else []
                        for node in nodes:
                            for cpe_match in node.get('cpeMatch', []) or []:
                                cpe_uri = cpe_match.get('criteria', '')
                                if isinstance(cpe_uri, str) and cpe_uri.startswith('cpe:2.3:'):
                                    parts = cpe_uri.split(':')
                                    if len(parts) > 2 and parts[2] == selected_part:
                                        has_part = True
                                        break
                            if has_part:
                                break
                        if has_part:
                            break
                    if not has_part:
                        continue
                # Incrementa contagem por vendor
                try:
                    vendor_list = json.loads(vendors_json) if isinstance(vendors_json, str) else (vendors_json or [])
                except Exception:
                    vendor_list = []
                for vn in vendor_list or []:
                    if isinstance(vn, str) and vn.strip():
                        vendor_counts[vn.strip().lower()] += 1
            # Buscar vendors existentes compatíveis
            vendor_names_lower = list(vendor_counts.keys())
            base_vendors = []
            if vendor_names_lower:
                chunk_size = 900  # evita erro do SQLite: too many SQL variables
                for i in range(0, len(vendor_names_lower), chunk_size):
                    names_chunk = vendor_names_lower[i:i+chunk_size]
                    chunk_rows = (
                        db.session.query(Vendor.id, Vendor.name)
                        .filter(func.lower(Vendor.name).in_(names_chunk))
                        .order_by(Vendor.name.asc())
                        .all()
                    )
                    base_vendors.extend(chunk_rows)
                # Garantir ordenação consistente após agregação por chunks
                try:
                    base_vendors.sort(key=lambda x: (x[1] or '').lower())
                except Exception:
                    pass
            vendor_dicts = [
                {'id': vid, 'name': vname, 'cve_count': vendor_counts.get(vname.lower(), 0)}
                for vid, vname in base_vendors
            ]

            # Adicionar filtro por nome (parâmetro 'q') se estiver presente
            if q:
                q_lower = q.lower()
                vendor_dicts = [v for v in vendor_dicts if q_lower in v['name'].lower()]

            total = len(vendor_dicts)
            # Paginação manual
            class MockPagination:
                def __init__(self, items, page, per_page, total):
                    self.items = items
                    self.page = page
                    self.per_page = per_page
                    self.total = total
                    self.pages = (total + per_page - 1) // per_page
                    self.has_prev = page > 1
                    self.has_next = page < self.pages
                    self.prev_num = page - 1 if self.has_prev else None
                    self.next_num = page + 1 if self.has_next else None
            start = (page - 1) * per_page
            end = start + per_page
            items = vendor_dicts[start:end]
            pagination = MockPagination(items, page, per_page, total)
            return render_template(
                'vulnerabilities/vendor_selection.html',
                vendors=pagination.items,
                pagination=pagination,
                current_category=category_tag or '',
                current_severity=current_severity,
                selected_vendor_ids=selected_vendor_ids
            )

        if q:
            query = query.filter(Vendor.name.ilike(f"%{q}%"))

        pagination = paginate_query(query, page=page, per_page=per_page, error_out=False)

        # Normalize vendor items for template (id, name, cve_count) e sobrepor fallback via JSON quando faltar
        vendors_items = []
        page_vendor_names = set()
        rows_info = []
        missing_counts = False
        try:
            for item in pagination.items:
                vid = None
                name = None
                ccount = None

                # Prefer mapping access (SQLAlchemy Row)
                if hasattr(item, '_mapping'):
                    m = item._mapping
                    # Try standard and alternative keys
                    vid = m.get('id', m.get('vendor_id', m.get('Vendor_id')))
                    name = m.get('name', m.get('vendor_name', m.get('Vendor_name')))
                    ccount = m.get('cve_count')
                    if ccount is None:
                        ccount = m.get('count', m.get('vendor_count', m.get('coalesce', m.get('coalesce_1'))))
                elif isinstance(item, tuple):
                    # Handle tuple shapes: (id, name, cve_count) or (Vendor, cve_count)
                    if len(item) >= 3 and isinstance(item[0], (int, str)):
                        vid = item[0]
                        name = item[1]
                        ccount = item[2]
                    elif len(item) >= 2 and hasattr(item[0], 'id') and hasattr(item[0], 'name'):
                        vid = getattr(item[0], 'id', None)
                        name = getattr(item[0], 'name', None)
                        ccount = item[1] if len(item) > 1 else None
                    elif len(item) >= 2:
                        vid = item[0]
                        name = item[1]
                        ccount = item[2] if len(item) > 2 else None
                else:
                    # Fallback to attribute access (ORM model instance)
                    vid = getattr(item, 'id', None)
                    name = getattr(item, 'name', None)
                    ccount = getattr(item, 'cve_count', None)

                # Normalize types and defaults
                try:
                    if ccount is not None:
                        ccount = int(ccount)
                except (TypeError, ValueError):
                    ccount = 0

                if name not in (None, ''):
                    page_vendor_names.add(str(name).strip().lower())
                if vid is not None and name is not None:
                    rows_info.append((vid, name, ccount))
                    if (ccount is None) or (ccount == 0):
                        missing_counts = True
        except Exception as e:
            current_app.logger.warning("Falha ao normalizar vendors; fallback simples.", exc_info=e)
            rows_info = [
                (getattr(it, 'id', None), getattr(it, 'name', None), getattr(it, 'cve_count', 0))
                for it in getattr(pagination, 'items', []) or []
            ]
            page_vendor_names = {str(r[1]).strip().lower() for r in rows_info if r[1]}

        # Computa fallback sempre que houver vendors na página; substitui apenas se for maior
        fallback_counts = {}
        if page_vendor_names:
            try:
                from collections import defaultdict
                import json
                fc = defaultdict(int)
                qv = db.session.query(Vulnerability.cve_id, Vulnerability.nvd_vendors_data)
                # Restringe por part se aplicável
                if selected_part and cve_ids_by_part:
                    qv = qv.filter(Vulnerability.cve_id.in_(list(cve_ids_by_part)))
                # Reduz universo para vulnerabilidades cujo JSON contém algum vendor da página
                try:
                    page_vendor_names_list = list(page_vendor_names)
                    like_filters = [func.lower(Vulnerability.nvd_vendors_data).like(f"%{vn}%") for vn in page_vendor_names_list]
                    if like_filters:
                        qv = qv.filter(or_(*like_filters))
                except Exception:
                    pass
                vulns_rows = qv.all()
                for cve_id, vendors_json in vulns_rows:
                    try:
                        vlist = json.loads(vendors_json) if isinstance(vendors_json, str) else (vendors_json or [])
                    except Exception:
                        vlist = []
                    if not vlist:
                        continue
                    for vn in vlist:
                        if isinstance(vn, str):
                            ln = vn.strip().lower()
                            if ln in page_vendor_names:
                                fc[ln] += 1
                fallback_counts = dict(fc)
            except Exception as e:
                current_app.logger.warning("Falha ao computar contagem fallback via JSON.", exc_info=e)
                fallback_counts = {}

        for vid, name, ccount in rows_info:
            name_lower = str(name).strip().lower() if name is not None else ''
            fb = fallback_counts.get(name_lower)
            base = 0 if (ccount is None) else ccount
            # Se fallback indicar uma contagem maior, usar fallback
            cnt = fb if (fb is not None and fb > base) else base
            vendors_items.append({'id': vid, 'name': name, 'cve_count': cnt})

        return render_template(
            'vulnerabilities/vendor_selection.html',
            vendors=vendors_items,
            pagination=pagination,
            current_category=category_tag or '',
            current_severity=current_severity,
            selected_vendor_ids=selected_vendor_ids
        )
    except Exception as e:
        logger.error(f"Erro ao carregar seleção de vendors: {e}", exc_info=True)
        flash('Erro ao carregar lista de fornecedores.', 'danger')
        return render_template(
            'vulnerabilities/vendor_selection.html',
            vendors=[],
            pagination=None,
            current_category=category_tag or '',
            current_severity=current_severity,
            selected_vendor_ids=[]
        )

@vuln_ui_bp.route('/create', methods=['GET', 'POST'])
def create_vulnerability_ui():
    """Formulário de criação de vulnerabilidade."""
    form = VulnerabilityForm()
    if form.validate_on_submit():
        try:
            vuln = Vulnerability(**form.data)
            db.session.add(vuln)
            db.session.commit()
            flash('Vulnerabilidade criada com sucesso.', 'success')
            return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))
        except SQLAlchemyError as e:
            db.session.rollback()
            logger.error("Erro criando vulnerabilidade: %s", e, exc_info=True)
            flash('Erro ao salvar vulnerabilidade.', 'danger')

    return render_template(
        'vulnerabilities/vulnerability_form.html',
        form=form, action='create'
    )

@vuln_ui_bp.route('/<string:cve_id>/edit', methods=['GET', 'POST'])
def edit_vulnerability_ui(cve_id: str):
    """Formulário de edição de vulnerabilidade."""
    if not CVE_PATTERN.match(cve_id):
        abort(400, description="Formato de CVE inválido.")
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    form = VulnerabilityForm(obj=vuln)

    if form.validate_on_submit():
        try:
            for field, value in form.data.items():
                setattr(vuln, field, value)
            db.session.commit()
            flash('Vulnerabilidade atualizada com sucesso.', 'success')
            return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))
        except SQLAlchemyError as e:
            db.session.rollback()
            logger.error("Erro atualizando vulnerabilidade: %s", e, exc_info=True)
            flash('Erro ao atualizar.', 'danger')

    return render_template(
        'vulnerabilities/vulnerability_form.html',
        form=form, action='edit', cve_id=cve_id
    )

@vuln_ui_bp.route('/<string:cve_id>/delete', methods=['POST'])
def delete_vulnerability_ui(cve_id: str):
    """Exclui vulnerabilidade após validação CSRF."""
    form = DeleteForm()
    if not form.validate_on_submit():
        abort(400, description="CSRF token inválido.")
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    try:
        db.session.delete(vuln)
        db.session.commit()
        flash('Vulnerabilidade removida.', 'success')
    except SQLAlchemyError as e:
        db.session.rollback()
        logger.error("Erro deletando vulnerabilidade: %s", e, exc_info=True)
        flash('Erro ao remover.', 'danger')
    return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))

@vuln_ui_bp.route('/<string:cve_id>/mitigate', methods=['POST'])
def mitigate_vulnerability_ui(cve_id: str):
    """Marca vulnerabilidade como mitigada após validação CSRF."""
    form = DeleteForm()
    if not form.validate_on_submit():
        abort(400, description="CSRF token inválido.")
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    try:
        vuln.patch_available = True
        db.session.commit()
        flash(f"Vulnerabilidade {cve_id} mitigada.", 'success')
    except SQLAlchemyError as e:
        db.session.rollback()
        logger.error("Erro mitigando vulnerabilidade: %s", e, exc_info=True)
        flash('Erro ao mitigar.', 'danger')
    return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))

@vuln_ui_bp.route('/<string:cve_id>', methods=['GET'], strict_slashes=False)
def vulnerability_details(cve_id: str):
    """Exibe detalhes de uma vulnerabilidade específica, com fallback visual para produtos/versões."""
    try:
        # Buscar vulnerabilidade com todos os dados relacionados
        vulnerability = vuln_service.get_vulnerability_with_details(cve_id.upper())
        
        if not vulnerability:
            flash(f'Vulnerabilidade {cve_id} não encontrada ou não autorizada.', 'warning')
            return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))
        
        # Buscar dados de analytics
        analytics = vuln_service.get_vulnerability_analytics(cve_id.upper())
        
        # Calcular fallback de produtos/versões quando dados estruturados estão ausentes
        fallback_versions = []
        try:
            has_structured = bool(getattr(vulnerability, 'version_references', None)) or bool(getattr(vulnerability, 'affected_products', None))
            if not has_structured:
                nvd_ranges = getattr(vulnerability, 'nvd_version_ranges', None) or []
                if isinstance(nvd_ranges, (list, tuple)):
                    for vr in nvd_ranges:
                        try:
                            vendor_name = (vr.get('vendor') or '').strip() if isinstance(vr, dict) else None
                            product_name = (vr.get('product') or '').strip() if isinstance(vr, dict) else None
                            affected_version = None
                            if isinstance(vr, dict):
                                if vr.get('version'):
                                    affected_version = vr['version']
                                else:
                                    # Construir a partir de limites quando possível
                                    if vr.get('version_start_including'):
                                        affected_version = f">= {vr['version_start_including']}"
                                    elif vr.get('version_start_excluding'):
                                        affected_version = f"> {vr['version_start_excluding']}"
                                    elif vr.get('version_end_including'):
                                        affected_version = f"<= {vr['version_end_including']}"
                                    elif vr.get('version_end_excluding'):
                                        affected_version = f"< {vr['version_end_excluding']}"
                            if product_name or vendor_name or affected_version:
                                fallback_versions.append({
                                    'vendor_name': vendor_name,
                                    'product_name': product_name,
                                    'affected_version': affected_version,
                                    'fixed_version': None
                                })
                        except Exception:
                            # Ignorar entradas inválidas individualmente
                            continue
        except Exception:
            # Em caso de falha no cálculo, manter fallback vazio
            fallback_versions = []
        
        return render_template(
            'vulnerabilities/details.html',
            vulnerability=vulnerability,
            analytics=analytics,
            fallback_versions=fallback_versions
        )
    except Exception as e:
        logger.error(f"Erro ao carregar vulnerabilidade {cve_id}: {str(e)}", exc_info=True)
        flash(f'Erro ao carregar vulnerabilidade: {str(e)}', 'danger')
        return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))


@vuln_ui_bp.route('/details/<string:severity>', methods=['GET'])
def vulnerability_details_by_severity(severity: str):
    """Exibe página de detalhes das vulnerabilidades por severidade com dados da última semana."""
    try:
        # Converter severidade para maiúscula para validação
        severity_upper = severity.upper()
        
        # Validar severidade
        if severity_upper not in severity_levels.enums:
            flash(f'Severidade inválida: {severity}', 'warning')
            return redirect(url_for('main.index'))
        
        # Log para debugging
        logger.info(f'Carregando detalhes para severidade: {severity_upper}')
        
        # Carregar dados em paralelo para melhor performance
        vulnerabilities_data = None
        weekly_stats = None
        general_counts = None
        
        try:
            # Obter vulnerabilidades da última semana por severidade
            page = request.args.get('page', 1, type=int)
            per_page = request.args.get('per_page', current_app.config.get('ITEMS_PER_PAGE', 20), type=int)
            week_ago = datetime.now() - timedelta(days=7)
            query = vuln_service.session.query(Vulnerability).filter(
                Vulnerability.published_date >= week_ago,
                Vulnerability.base_severity == severity_upper
            ).order_by(Vulnerability.published_date.desc())
            pagination = paginate_query(query, page=page, per_page=per_page, error_out=False)
            vulnerabilities_data = {
                'vulnerabilities': pagination.items,
                'total_count': pagination.total,
                'pagination': pagination
            }
            logger.debug(f'Vulnerabilidades carregadas: {vulnerabilities_data["total_count"]} itens (página {pagination.page}/{pagination.pages})')
        except Exception as e:
            logger.error(f'Erro ao carregar vulnerabilidades: {str(e)}')
            vulnerabilities_data = {'vulnerabilities': [], 'total_count': 0, 'pagination': None}

        # Calcular métricas derivadas para os cards
        try:
            vulns_list = vulnerabilities_data.get('vulnerabilities', []) or []
            scores = [float(v.cvss_score) for v in vulns_list if getattr(v, 'cvss_score', None) is not None]
            avg_cvss_score = round(sum(scores) / len(scores), 1) if scores else None
            patch_count = sum(1 for v in vulns_list if getattr(v, 'patch_available', False))
        except Exception as e:
            logger.warning(f'Falha ao calcular métricas de cards: {str(e)}')
            avg_cvss_score = None
            patch_count = 0
        
        try:
            # Obter estatísticas para gráficos
            weekly_stats = vuln_service.get_weekly_statistics_by_severity(severity_upper)
            logger.debug('Estatísticas semanais carregadas')
        except Exception as e:
            logger.error(f'Erro ao carregar estatísticas: {str(e)}')
            weekly_stats = {
                'daily_distribution': [],
                'cvss_distribution': [],
                'top_products': [],
                'weekly_count': 0,
                'monthly_count': 0,
                'total_count': 0
            }

        # Distribuição global de CVSS da semana (todas as severidades)
        try:
            weekly_cvss_all = vuln_service.get_weekly_cvss_distribution_all()
            logger.debug('Distribuição semanal CVSS (global) carregada')
        except Exception as e:
            logger.error(f'Erro ao carregar distribuição semanal CVSS global: {str(e)}')
            weekly_cvss_all = {
                '0.0-3.9': 0,
                '4.0-6.9': 0,
                '7.0-8.9': 0,
                '9.0-10.0': 0
            }

        # Distribuição CVSS considerando TODAS as CVEs da severidade atual (sem filtro de data)
        try:
            cvss_all_severity = vuln_service.get_cvss_distribution_by_severity_all(severity_upper)
            logger.debug('Distribuição CVSS para todas as CVEs da severidade carregada')
        except Exception as e:
            logger.error(f'Erro ao carregar distribuição CVSS para todas as CVEs ({severity_upper}): {str(e)}')
            cvss_all_severity = {
                '0.0-3.9': 0,
                '4.0-6.9': 0,
                '7.0-8.9': 0,
                '9.0-10.0': 0
            }
        
        try:
            # Obter contadores gerais
            general_counts = vuln_service.get_dashboard_counts()
            logger.debug('Contadores gerais carregados')
        except Exception as e:
            logger.error(f'Erro ao carregar contadores: {str(e)}')
            general_counts = {
                'critical': 0, 'high': 0, 'medium': 0, 'low': 0,
                'total': 0, 'patched': 0, 'unpatched': 0
            }
        
        return render_template(
            'vulnerabilities/details_page.html',
            severity=severity_upper,
            vulnerabilities=vulnerabilities_data['vulnerabilities'],
            total_count=vulnerabilities_data['total_count'],
            pagination=vulnerabilities_data.get('pagination'),
            weekly_stats=weekly_stats,
            weekly_cvss_all=weekly_cvss_all,
            cvss_all_severity=cvss_all_severity,
            general_counts=general_counts,
            severity_display=severity.title(),
            avg_cvss_score=avg_cvss_score,
            patch_count=patch_count
        )
    except Exception as e:
        logger.error(f'Erro crítico ao carregar detalhes de vulnerabilidades {severity_upper}: {str(e)}')
        # Mensagem de erro mais clara e contextualizada com a severidade
        severity_pt = {
            'CRITICAL': 'Críticas',
            'HIGH': 'Altas',
            'MEDIUM': 'Médias',
            'LOW': 'Baixas'
        }.get(severity_upper, severity_upper)

        flash(
            f'Não foi possível carregar os detalhes de vulnerabilidades {severity_pt}. Tente novamente mais tarde.',
            'danger'
        )
        return redirect(url_for('main.index'))

@vuln_ui_bp.route('/details.html', methods=['GET'], strict_slashes=False)
def vulnerability_details_alias_html():
    """Alias compatível para acessos diretos ao template .html.
    Aceita query params 'cve'/'cve_id' ou 'severity' e redireciona
    para as rotas corretas evitando 404.
    """
    cve_id = request.args.get('cve_id') or request.args.get('cve')
    if cve_id:
        return redirect(url_for('vulnerability_ui.vulnerability_details', cve_id=cve_id))
    severity = request.args.get('severity')
    if severity:
        severity_upper = severity.upper()
        if severity_upper in severity_levels.enums:
            return redirect(url_for('vulnerability_ui.vulnerability_details_by_severity', severity=severity_upper))
        flash(f'Severidade inválida: {severity}', 'warning')
    return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))


@vuln_ui_bp.route('/<string:cve_id>/risk-report', methods=['GET'])
def generate_risk_report(cve_id: str):
    """Gera relatório de risco para uma vulnerabilidade específica."""
    try:
        # Buscar vulnerabilidade diretamente
        vulnerability = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
        
        if not vulnerability:
            flash(f'Vulnerabilidade {cve_id} não encontrada ou não autorizada.', 'warning')
            return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))
        
        # Gerar relatório de risco
        risk_analysis = risk_service.get_risk_analysis(cve_id.upper())
        
        return render_template(
            'risk_report.html',
            vulnerability=vulnerability,
            risk_analysis=risk_analysis,
            cve_id=cve_id.upper()
        )
        
    except Exception as e:
        logger.error(f'Erro ao gerar relatório de risco para {cve_id}: {str(e)}')
        flash(f'Erro ao gerar relatório de risco: {str(e)}', 'danger')
        return redirect(url_for('vulnerability_ui.vulnerability_details', cve_id=cve_id))


@vuln_ui_bp.route('/<string:cve_id>/risk-report/export/pdf', methods=['GET'])
def export_risk_report_pdf(cve_id: str):
    """Exporta relatório de risco em PDF com fallback para HTML."""
    try:
        # Validar CVE ID
        if not CVE_PATTERN.match(cve_id):
            flash('CVE ID inválido.', 'warning')
            return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))

        vulnerability = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
        if not vulnerability:
            flash(f'Vulnerabilidade {cve_id} não encontrada ou não autorizada.', 'warning')
            return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))

        # Gerar conteúdo HTML do relatório
        risk_html = None
        try:
            risk_html = risk_service.generate_risk_report_html(cve_id.upper())
        except Exception as e:
            logger.warning(f'Falha ao gerar HTML do relatório de risco para {cve_id}: {e}')

        if not risk_html:
            # Fallback: usar markdown convertido no template
            risk_md = risk_service.get_risk_analysis(cve_id.upper()) or ''
            html_content = render_template(
                'reports/pdf/risk_report_pdf.html',
                vulnerability=vulnerability,
                cve_id=cve_id.upper(),
                risk_analysis_html=None,
                risk_analysis_md=risk_md,
                generated_at=datetime.now()
            )
        else:
            html_content = render_template(
                'reports/pdf/risk_report_pdf.html',
                vulnerability=vulnerability,
                cve_id=cve_id.upper(),
                risk_analysis_html=risk_html,
                risk_analysis_md=None,
                generated_at=datetime.now()
            )

        # Tentar WeasyPrint primeiro
        try:
            from weasyprint import HTML, CSS
            pdf_bytes = HTML(string=html_content, base_url=current_app.root_path).write_pdf()
            filename = f"relatorio_risco_{cve_id.upper()}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
            return send_file(
                io.BytesIO(pdf_bytes),
                as_attachment=True,
                download_name=filename,
                mimetype='application/pdf'
            )
        except Exception as e:
            logger.error(f'WeasyPrint falhou para {cve_id}: {e}')

        # Fallback: tentar pdfkit (wkhtmltopdf)
        try:
            import pdfkit
            wkhtml_path = (current_app.config.get('WKHTMLTOPDF_PATH') or '').strip() or None
            configuration = None
            if wkhtml_path:
                try:
                    configuration = pdfkit.configuration(wkhtmltopdf=wkhtml_path)
                except Exception as e:
                    logger.warning(f'WKHTMLTOPDF_PATH inválido: {wkhtml_path} ({e})')
                    configuration = None

            options = {
                'quiet': '',
                'enable-local-file-access': None,
                'print-media-type': None,
                'encoding': 'UTF-8',
                'page-size': 'A4',
                'margin-top': '10mm',
                'margin-right': '10mm',
                'margin-bottom': '12mm',
                'margin-left': '10mm'
            }
            pdf_bytes = pdfkit.from_string(html_content, False, options=options, configuration=configuration)
            filename = f"relatorio_risco_{cve_id.upper()}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
            return send_file(
                io.BytesIO(pdf_bytes),
                as_attachment=True,
                download_name=filename,
                mimetype='application/pdf'
            )
        except Exception as e:
            logger.error(f'pdfkit falhou para {cve_id}: {e}')

        # Fallback final: enviar HTML para download
        filename = f"relatorio_risco_{cve_id.upper()}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
        return send_file(
            io.BytesIO(html_content.encode('utf-8')),
            as_attachment=True,
            download_name=filename,
            mimetype='text/html'
        )

    except Exception as e:
        logger.error(f'Erro ao exportar PDF do relatório de risco {cve_id}: {str(e)}')
        flash('Erro ao exportar PDF do relatório de risco. Tente novamente.', 'danger')
        return redirect(url_for('vulnerability_ui.vulnerability_details', cve_id=cve_id))


@vuln_api_bp.route('/<string:cve_id>/risk-report', methods=['GET'])
def get_risk_report_api(cve_id: str):
    """API para obter relatório de risco de uma vulnerabilidade."""
    try:
        # Buscar vulnerabilidade diretamente
        vulnerability = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
        
        if not vulnerability:
            return jsonify({'error': 'Vulnerabilidade não encontrada ou não autorizada'}), 404
        
        # Gerar relatório de risco
        risk_analysis = risk_service.get_risk_analysis(cve_id.upper())
        risk_html = risk_service.generate_risk_report_html(cve_id.upper())
        
        return jsonify({
            'cve_id': cve_id.upper(),
            'risk_analysis_markdown': risk_analysis,
            'risk_analysis_html': risk_html,
            'generated_at': datetime.now().isoformat()
        })
        
    except Exception as e:
        logger.error(f'Erro ao gerar relatório de risco via API para {cve_id}: {str(e)}')
        return jsonify({'error': f'Erro ao gerar relatório de risco: {str(e)}'}), 500

# ──────────────────────────────────────────────────────────────────────────────
# API Routes
# ──────────────────────────────────────────────────────────────────────────────

@vuln_api_bp.route('', methods=['GET'])
def list_vulnerabilities_api():
    """API: listagem paginada com filtros."""
    page     = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', current_app.config.get('ITEMS_PER_PAGE', 20), type=int)
    severity = request.args.get('severity')

    if severity and severity.upper() not in severity_levels.enums:
        raise BadRequest(f"Severidade inválida: {severity}")
    elif severity:
        severity = severity.upper()

    query      = vuln_service.session.query(Vulnerability)
    if severity:
        query = query.filter_by(base_severity=severity)
    pagination = paginate_query(query.order_by(Vulnerability.published_date.desc()),
                                page, per_page, error_out=False)

    return jsonify({
        'data': vuln_list_schema.dump(pagination.items),
        'meta': {
            'page':       pagination.page,
            'per_page':   pagination.per_page,
            'total':      pagination.total,
            'total_pages': pagination.pages
        }
    })

@vuln_api_bp.route('/<string:cve_id>', methods=['GET'])
def get_vulnerability_api(cve_id: str):
    """API: detalhes de uma vulnerabilidade."""
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    return jsonify(vuln_schema.dump(vuln))

@vuln_api_bp.route('/<string:cve_id>', methods=['PATCH'])
def update_vulnerability_api(cve_id: str):
    """API: atualização parcial via PATCH."""
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    data = request.get_json() or {}
    # Validação de campos permitidos
    allowed = {'description','published_date','last_modified','base_severity','cvss_score','patch_available','assigner'}
    invalid = set(data) - allowed
    if invalid:
        raise BadRequest(f"Campos inválidos: {invalid}")

    for k,v in data.items():
        setattr(vuln, k, v)
    db.session.commit()
    return jsonify(vuln_schema.dump(vuln))

@vuln_api_bp.route('/<string:cve_id>/mitigate', methods=['POST'])
def mitigate_vulnerability_api(cve_id: str):
    """API: marca como mitigada."""
    try:
        data = request.get_json()
        vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
        
        if not vuln:
            return jsonify({'success': False, 'message': 'Vulnerabilidade não encontrada'}), 404
        
        # Atualiza status de mitigação
        vuln.patch_available = True
        
        # TODO: Adicionar campos de mitigação ao modelo se necessário
        # vuln.mitigation_notes = data.get('notes')
        # vuln.mitigation_status = data.get('status')
        
        db.session.commit()
        
        return jsonify({
            'success': True, 
            'message': 'Vulnerabilidade mitigada com sucesso',
            'vulnerability': vuln_schema.dump(vuln)
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': str(e)}), 500

@vuln_api_bp.route('/<string:cve_id>', methods=['DELETE'])
def delete_vulnerability_api(cve_id: str):
    """API: exclusão de vulnerabilidade."""
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    db.session.delete(vuln)
    db.session.commit()
    return jsonify({'message': f'CVE {cve_id} excluída.'}), 204

@vuln_api_bp.route('/history', methods=['GET'])
def get_cve_history_data():
    """API: dados históricos de CVEs para o gráfico."""
    try:
        # Parâmetros de filtro
        period = request.args.get('period', '30')
        severity = request.args.get('severity', '')
        cvss_min = request.args.get('cvss_min', type=float)
        cvss_max = request.args.get('cvss_max', type=float)

        # Sanitizar intervalo CVSS
        if cvss_min is not None:
            cvss_min = max(0.0, min(10.0, cvss_min))
        if cvss_max is not None:
            cvss_max = max(0.0, min(10.0, cvss_max))
        if cvss_min is not None and cvss_max is not None and cvss_min > cvss_max:
            cvss_min, cvss_max = cvss_max, cvss_min
        
        # Validar período
        if period not in ['30', '90', '365']:
            period = '30'
        
        days = int(period)
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        
        # Severidades válidas
        valid_severities = ['N/A', 'NONE', 'LOW', 'MEDIUM', 'HIGH', 'CRITICAL']
        # Mapeia severidades não padronizadas para LOW para exibição no gráfico
        severity_map = {
            'CRITICAL': 'CRITICAL',
            'HIGH': 'HIGH',
            'MEDIUM': 'MEDIUM',
            'LOW': 'LOW',
            'NONE': 'LOW',
            'N/A': 'LOW'
        }
        
        # Query para dados diários agrupados por severidade
        from sqlalchemy import func
        
        daily_data = db.session.query(
            func.date(Vulnerability.published_date).label('date'),
            Vulnerability.base_severity,
            func.count(Vulnerability.cve_id).label('count')
        ).filter(
            Vulnerability.published_date >= start_date,
            Vulnerability.published_date <= end_date
        )
        
        # Aplicar filtros
        if severity and severity.upper() in valid_severities:
            daily_data = daily_data.filter(Vulnerability.base_severity == severity.upper())
        
        if cvss_min is not None:
            daily_data = daily_data.filter(Vulnerability.cvss_score >= cvss_min)
        
        if cvss_max is not None:
            daily_data = daily_data.filter(Vulnerability.cvss_score <= cvss_max)
        
        daily_data = daily_data.group_by(
            func.date(Vulnerability.published_date),
            Vulnerability.base_severity
        ).order_by(func.date(Vulnerability.published_date)).all()
        
        # Organizar dados por data
        chart_data = {}
        severity_totals = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
        
        for row in daily_data:
            if row.date:
                # Verificar se row.date é string ou datetime
                if isinstance(row.date, str):
                    date_str = row.date
                else:
                    date_str = row.date.strftime('%Y-%m-%d')
                
                # Normaliza severidade para chaves do gráfico
                raw_level = row.base_severity or 'LOW'
                severity_level = severity_map.get(raw_level, 'LOW')
                count = row.count
                
                if date_str not in chart_data:
                    chart_data[date_str] = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
                
                if severity_level in chart_data[date_str]:
                    chart_data[date_str][severity_level] = count
                    if severity_level in severity_totals:
                        severity_totals[severity_level] += count
        
        # Preencher datas faltantes com zeros
        current_date = start_date.date()
        while current_date <= end_date.date():
            date_str = current_date.strftime('%Y-%m-%d')
            if date_str not in chart_data:
                chart_data[date_str] = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
            current_date += timedelta(days=1)
        
        # Converter para formato do Chart.js
        sorted_dates = sorted(chart_data.keys())
        
        response_data = {
            'labels': sorted_dates,
            'datasets': [
                {
                    'label': 'Critical',
                    'data': [chart_data[date]['CRITICAL'] for date in sorted_dates],
                    'backgroundColor': 'rgba(220, 53, 69, 0.8)',
                    'borderColor': 'rgba(220, 53, 69, 1)',
                    'borderWidth': 2
                },
                {
                    'label': 'High',
                    'data': [chart_data[date]['HIGH'] for date in sorted_dates],
                    'backgroundColor': 'rgba(255, 193, 7, 0.8)',
                    'borderColor': 'rgba(255, 193, 7, 1)',
                    'borderWidth': 2
                },
                {
                    'label': 'Medium',
                    'data': [chart_data[date]['MEDIUM'] for date in sorted_dates],
                    'backgroundColor': 'rgba(255, 165, 0, 0.8)',
                    'borderColor': 'rgba(255, 165, 0, 1)',
                    'borderWidth': 2
                },
                {
                    'label': 'Low',
                    'data': [chart_data[date]['LOW'] for date in sorted_dates],
                    'backgroundColor': 'rgba(40, 167, 69, 0.8)',
                    'borderColor': 'rgba(40, 167, 69, 1)',
                    'borderWidth': 2
                }
            ],
            'statistics': {
                'total': sum(severity_totals.values()),
                'critical': severity_totals['CRITICAL'],
                'high': severity_totals['HIGH'],
                'medium': severity_totals['MEDIUM'],
                'low': severity_totals['LOW']
            }
        }
        
        return jsonify(response_data)
        
    except Exception as e:
        logger.error(f"Erro ao buscar dados históricos de CVE: {e}")
        return jsonify({'error': f'Erro interno do servidor: {str(e)}'}), 500

@vuln_api_legacy_bp.route('/export', methods=['GET'])
def export_vulnerabilities_csv():
    """Exporta vulnerabilidades em CSV.

    Parâmetros:
    - severity: nível de severidade (critical, high, medium, low, all)
    - period: período (week, month, all)
    """
    try:
        import csv
        from io import StringIO

        severity_param = (request.args.get('severity', 'all') or 'all').upper()
        period_param = (request.args.get('period', 'week') or 'week').lower()

        # Validar severidade
        valid_severities = {'CRITICAL', 'HIGH', 'MEDIUM', 'LOW'}
        severity_filter = severity_param if severity_param in valid_severities else None

        # Calcular janela de tempo
        end_date = datetime.now()
        if period_param == 'week':
            start_date = end_date - timedelta(days=7)
        elif period_param == 'month':
            start_date = end_date - timedelta(days=30)
        else:
            start_date = None  # sem filtro

        # Query base
        query = vuln_service.session.query(Vulnerability)
        if severity_filter:
            query = query.filter(Vulnerability.base_severity == severity_filter)
        if start_date:
            query = query.filter(Vulnerability.published_date >= start_date)
        query = query.order_by(Vulnerability.published_date.desc())

        vulns = query.all()

        # Preparar CSV
        csv_buffer = StringIO()
        writer = csv.writer(csv_buffer)
        writer.writerow([
            'CVE ID', 'Severidade', 'CVSS', 'Publicado em', 'Vendor', 'Produto', 'Patch Disponível', 'Assigner'
        ])

        def normalize_first(items, key_name='name'):
            if not items:
                return ''
            first = items[0]
            if isinstance(first, str):
                return first
            if isinstance(first, dict):
                return str(first.get(key_name, ''))
            # Tentativa de atributo .name
            return str(getattr(first, key_name, '') or '')

        for v in vulns:
            vendor = ''
            product = ''
            try:
                vendor = normalize_first(getattr(v, 'nvd_vendors_data', None))
            except Exception:
                vendor = ''
            try:
                product = normalize_first(getattr(v, 'nvd_products_data', None))
            except Exception:
                product = ''

            writer.writerow([
                v.cve_id,
                v.base_severity or '',
                v.cvss_score if v.cvss_score is not None else '',
                v.published_date.strftime('%Y-%m-%d') if v.published_date else '',
                vendor,
                product,
                'Sim' if getattr(v, 'patch_available', False) else 'Não',
                getattr(v, 'assigner', '') or ''
            ])

        csv_data = csv_buffer.getvalue()
        csv_buffer.close()

        filename = f"vulnerabilities_{(severity_filter or 'ALL').lower()}_{datetime.now().strftime('%Y-%m-%d')}" \
                   + (f"_{period_param}" if period_param in ['week','month'] else '') + ".csv"

        return Response(
            csv_data,
            mimetype='text/csv; charset=utf-8',
            headers={
                'Content-Disposition': f'attachment; filename="{filename}"'
            }
        )
    except Exception as e:
        logger.error(f"Erro ao exportar CSV de vulnerabilidades: {e}", exc_info=True)
        return jsonify({'error': 'Falha ao exportar CSV'}), 500

# Rota de teste temporária
@vuln_ui_bp.route('/debug-test')
def test_vulnerabilities():
    """Rota de teste para verificar se as vulnerabilidades estão sendo passadas corretamente."""
    try:
        # Usar a mesma lógica do list_vulnerabilities_ui
        page = 1
        per_page = 20
        severity = None
        
        sql_query = """
        SELECT cve_id, description, base_severity, cvss_score, published_date, nvd_vendors_data 
        FROM vulnerabilities 
        """
        
        params = {}
        if severity and severity != 'all':
            sql_query += " WHERE base_severity = :severity"
            params['severity'] = severity.upper()
        
        sql_query += " ORDER BY published_date DESC LIMIT :limit OFFSET :offset"
        params['limit'] = per_page
        params['offset'] = (page - 1) * per_page
        
        result = db.session.execute(text(sql_query), params)
        vulnerabilities = result.fetchall()
        
        return render_template(
            'vulnerabilities/debug/test_vulnerabilities.html',
            vulnerabilities=vulnerabilities
        )
        
    except Exception as e:
        logger.error(f"Erro no teste de vulnerabilidades: {e}")
        return f"Erro: {e}"

@vuln_ui_bp.route('/debug-simple', strict_slashes=False)
def debug_simple():
    """Rota de debug simples"""
    # Usar exatamente a mesma lógica do list_vulnerabilities_ui
    page = 1
    per_page = 20
    severity = None
    
    # Query SQL idêntica
    from sqlalchemy import text
    
    sql_query = """
    SELECT cve_id, description, published_date, base_severity, cvss_score, 
           patch_available, assigner, source_identifier, vuln_status,
           nvd_vendors_data, nvd_products_data
    FROM vulnerabilities 
    ORDER BY published_date DESC LIMIT :limit OFFSET :offset
    """
    
    params = {
        'limit': per_page,
        'offset': (page - 1) * per_page
    }
    
    result = db.session.execute(text(sql_query), params)
    vulnerabilities = result.fetchall()
    
    # Contar total para paginação
    count_sql = "SELECT COUNT(*) FROM vulnerabilities"
    count_result = db.session.execute(text(count_sql))
    total = count_result.scalar()
    
    # Criar MockPagination igual ao original
    class MockPagination:
        def __init__(self, items, page, per_page, total):
            self.items = items
            self.page = page
            self.per_page = per_page
            self.total = total
            self.pages = (total + per_page - 1) // per_page
            self.has_prev = page > 1
            self.has_next = page < self.pages
            self.prev_num = page - 1 if self.has_prev else None
            self.next_num = page + 1 if self.has_next else None

        def iter_pages(self, left_edge=2, left_current=2, right_current=3, right_edge=2):
            last = 0
            for num in range(1, self.pages + 1):
                if (
                    num <= left_edge
                    or (num >= self.page - left_current and num <= self.page + right_current)
                    or (num > self.pages - right_edge)
                ):
                    if last + 1 != num:
                        yield None
                    yield num
                    last = num
    
    pagination = MockPagination(vulnerabilities, page, per_page, total)
    
    return render_template(
        'vulnerabilities/debug/debug_simple.html',
        vulnerabilities=pagination.items,
        vulns=pagination.items,
        pagination=pagination
    )

# Error handlers poderiam ser registrados no app global, herdar de main.
