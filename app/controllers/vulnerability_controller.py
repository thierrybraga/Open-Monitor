# controllers/vulnerability_controller.py

import re
import io
import logging
from datetime import datetime, timedelta
from typing import Any, Dict
from flask import (
    Blueprint, request, flash, redirect, url_for,
    current_app, jsonify, abort, render_template, Response, send_file
)
from flask_login import login_required, current_user
# CSRF protection is handled at blueprint level

def is_user_authenticated():
    """Verifica autenticação de forma segura, mesmo sem Flask-Login inicializado."""
    try:
        # Evitar acesso quando o login_manager não existe em modo público
        if not hasattr(current_app, 'login_manager') or current_app.login_manager is None:
            return False
        return bool(getattr(current_user, 'is_authenticated', False))
    except Exception:
        # Em modo público ou em falhas de contexto, considerar não autenticado
        return False
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy import or_, func, cast, String
from werkzeug.exceptions import BadRequest, NotFound, InternalServerError

from app.extensions import db
from app.models.vulnerability import Vulnerability
from app.models.asset import Asset
from app.models.asset_vulnerability import AssetVulnerability
from app.models.cve_vendor import CVEVendor
from app.models.cve_part import CVEPart
from app.models.vendor import Vendor
from app.models.sync_metadata import SyncMetadata
from app.models.enums import severity_levels
from sqlalchemy.orm import joinedload
from app.services.vulnerability_service import VulnerabilityService
from app.services.risk_report_service import RiskReportService
from app.schemas.vulnerability_schema import VulnerabilitySchema
from app.forms.vulnerability_form import VulnerabilityForm
from app.forms.common_form import DeleteForm
from app.utils.pagination import paginate_query

logger = logging.getLogger(__name__)

# Blueprints
vuln_ui_bp = Blueprint('vulnerability_ui', __name__, url_prefix='/vulnerabilities')
vuln_api_bp = Blueprint('vulnerability_api', __name__, url_prefix='/api/v1/vulnerabilities')

# Legacy API blueprint to support non-versioned endpoints
# This ensures backward compatibility for clients using '/api/vulnerabilities' without 'v1'
vuln_api_legacy_bp = Blueprint('vulnerability_api_legacy', __name__, url_prefix='/api/vulnerabilities')

@vuln_api_bp.errorhandler(BadRequest)
def _vuln_bad_request(e: BadRequest):
    return jsonify(error=str(e)), 400

@vuln_api_bp.errorhandler(NotFound)
def _vuln_not_found(e: NotFound):
    return jsonify(error='Not Found'), 404

@vuln_api_bp.errorhandler(SQLAlchemyError)
def _vuln_db_error(e: SQLAlchemyError):
    try:
        detail = str(getattr(e, 'orig', e))
    except Exception:
        detail = str(e)
    return jsonify(error='Database error', detail=detail), 500

@vuln_api_bp.errorhandler(Exception)
def _vuln_unexpected(e: Exception):
    raise InternalServerError()

@vuln_api_legacy_bp.errorhandler(BadRequest)
def _vuln_legacy_bad_request(e: BadRequest):
    return jsonify(error=str(e)), 400

@vuln_api_legacy_bp.errorhandler(NotFound)
def _vuln_legacy_not_found(e: NotFound):
    return jsonify(error='Not Found'), 404

@vuln_api_legacy_bp.errorhandler(SQLAlchemyError)
def _vuln_legacy_db_error(e: SQLAlchemyError):
    try:
        detail = str(getattr(e, 'orig', e))
    except Exception:
        detail = str(e)
    return jsonify(error='Database error', detail=detail), 500

@vuln_api_legacy_bp.errorhandler(Exception)
def _vuln_legacy_unexpected(e: Exception):
    raise InternalServerError()

# Wrapper routes delegating to the versioned API implementations
@vuln_api_legacy_bp.route('', methods=['GET'])
def list_vulnerabilities_api_legacy():
    return list_vulnerabilities_api()

@vuln_api_legacy_bp.route('/<string:cve_id>', methods=['GET'])
def get_vulnerability_api_legacy(cve_id: str):
    return get_vulnerability_api(cve_id)

@vuln_api_legacy_bp.route('/<string:cve_id>', methods=['PATCH'])
def update_vulnerability_api_legacy(cve_id: str):
    return update_vulnerability_api(cve_id)

@vuln_api_legacy_bp.route('/<string:cve_id>/mitigate', methods=['POST'])
def mitigate_vulnerability_api_legacy(cve_id: str):
    return mitigate_vulnerability_api(cve_id)

@vuln_api_legacy_bp.route('/<string:cve_id>', methods=['DELETE'])
def delete_vulnerability_api_legacy(cve_id: str):
    return delete_vulnerability_api(cve_id)

@vuln_api_legacy_bp.route('/<string:cve_id>/risk-report', methods=['GET'])
def get_risk_report_api_legacy(cve_id: str):
    return get_risk_report_api(cve_id)

# Service and schemas
vuln_service     = VulnerabilityService(db.session)
risk_service     = RiskReportService()
vuln_schema      = VulnerabilitySchema()
vuln_list_schema = VulnerabilitySchema(many=True)

# Regex para validar CVE ID
CVE_PATTERN = re.compile(r'^CVE-\d{4}-\d+$', re.IGNORECASE)

# ──────────────────────────────────────────────────────────────────────────────
# UI Routes
# ──────────────────────────────────────────────────────────────────────────────

@vuln_ui_bp.route('/', methods=['GET'])
@login_required
def list_vulnerabilities_ui():
    """Lista vulnerabilidades com filtro de severidade e paginação otimizada."""
    logger.info("=== INICIANDO list_vulnerabilities_ui ===")
    page     = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    # Suporte especial: per_page=all para exibir todos os resultados sem paginação
    raw_per_page_arg = request.args.get('per_page')
    no_limit = False
    if isinstance(raw_per_page_arg, str) and raw_per_page_arg.strip().lower() == 'all':
        no_limit = True
    severity = request.args.get('severity')
    # Suporte a filtro por NVD Catalog Tag (application, operating_system, hardware)
    catalog_tag = (request.args.get('catalog_tag', '', type=str) or request.args.get('category_tag', '', type=str))
    part_map = {
        'application': 'a',
        'operating_system': 'o',
        'hardware': 'h',
        # compatibilidade legada
        'software': 'a',
        'os': 'o'
    }
    selected_part = part_map.get((catalog_tag or '').strip().lower())
    # Novos filtros: vendors selecionados
    # Suporta tanto múltiplos parâmetros (vendor_ids=1&vendor_ids=2) quanto lista única (vendor_ids=1,2,3)
    raw_vendor_ids_list = request.args.getlist('vendor_ids')
    # Não definir default aqui para distinguir ausência (None) de presença vazia ('')
    raw_vendor_ids_param = request.args.get('vendor_ids')
    # Suporte explícito a escopo global de vendors: vendor_scope=all
    vendor_scope = (request.args.get('vendor_scope', '', type=str) or '').strip().lower()
    vendor_scope_all = (vendor_scope == 'all')
    # Flag para saber se o parâmetro vendor_ids foi explicitamente fornecido na URL,
    # mesmo que vazio (ex.: vendor_ids=). Alguns servidores/browsers podem omitir
    # chaves com valores vazios em parsing; portanto, checamos de forma robusta.
    try:
        vendor_filter_provided = (
            ('vendor_ids' in request.args) or
            (raw_vendor_ids_param is not None) or
            (isinstance(request.query_string, (bytes, bytearray)) and b'vendor_ids' in request.query_string) or
            ('vendor_ids=' in (request.url or '')) or
            ('vendor_names' in request.args) or
            (raw_vendor_names_param is not None) or
            (isinstance(request.query_string, (bytes, bytearray)) and b'vendor_names' in request.query_string) or
            ('vendor_names=' in (request.url or '')) or
            ('vendor_scope' in request.args) or
            (isinstance(request.query_string, (bytes, bytearray)) and b'vendor_scope' in request.query_string) or
            ('vendor_scope=' in (request.url or ''))
        )
    except Exception:
        vendor_filter_provided = (
            ('vendor_ids' in request.args) or ('vendor_ids=' in (request.url or '')) or
            ('vendor_names' in request.args) or ('vendor_names=' in (request.url or '')) or
            ('vendor_scope' in request.args) or ('vendor_scope=' in (request.url or ''))
        )
    selected_vendor_ids: list[int] = []
    # Suporte a nomes de vendors (dados brutos NVD) sem normalização
    raw_vendor_names_list = request.args.getlist('vendor_names')
    raw_vendor_names_param = request.args.get('vendor_names')
    selected_vendor_names: list[str] = []
    if raw_vendor_ids_list:
        for item in raw_vendor_ids_list:
            parts = str(item).split(',')
            for p in parts:
                try:
                    n = int(p.strip())
                    selected_vendor_ids.append(n)
                except Exception:
                    continue
    elif raw_vendor_ids_param:
        for p in raw_vendor_ids_param.split(','):
            try:
                n = int(p.strip())
                selected_vendor_ids.append(n)
            except Exception:
                continue
    if raw_vendor_names_list:
        for item in raw_vendor_names_list:
            parts = [x.strip() for x in str(item).split(',')]
            for p in parts:
                if p:
                    selected_vendor_names.append(p.lower())
    elif raw_vendor_names_param:
        for p in [x.strip() for x in raw_vendor_names_param.split(',')]:
            if p:
                selected_vendor_names.append(p.lower())
    # Deduplicar e ordenar para consistência
    selected_vendor_ids = sorted(set(selected_vendor_ids))
    selected_vendor_names = sorted(set(selected_vendor_names))
    # Novos filtros avançados de UI
    search = (request.args.get('search', '', type=str) or '').strip()
    cvss_range = request.args.get('cvss_range', '', type=str) or ''
    date_range = request.args.get('date_range', '', type=str) or ''
    start_date = request.args.get('start_date', '', type=str) or ''
    end_date = request.args.get('end_date', '', type=str) or ''
    product = (request.args.get('product', '', type=str) or '').strip()
    raw_product_names_list = request.args.getlist('product_names')
    raw_product_names_param = request.args.get('product_names')
    selected_product_names: list[str] = []
    if raw_product_names_list:
        for item in raw_product_names_list:
            parts = [x.strip() for x in str(item).split(',')]
            for p in parts:
                if p:
                    selected_product_names.append(p.lower())
    elif raw_product_names_param:
        for p in [x.strip() for x in raw_product_names_param.split(',')]:
            if p:
                selected_product_names.append(p.lower())
    mitigation_status = request.args.get('mitigation_status', '', type=str) or ''
    vuln_type = request.args.get('vuln_type', '', type=str) or ''
    sort_param = request.args.get('sort', 'published_date_desc', type=str) or 'published_date_desc'
    # Filtro específico por ativo: restringe CVEs às vinculadas ao asset
    asset_id = request.args.get('asset_id', type=int)
    # Aplicar preferências padrão de vendors quando nenhuma foi fornecida
    # OBS: se vendor_ids estiver presente explicitamente (mesmo vazio), NÃO carregar preferências
    if not selected_vendor_ids and not vendor_filter_provided and is_user_authenticated():
        try:
            key = f'user_vendor_preferences:{current_user.id}'
            pref = db.session.query(SyncMetadata).filter_by(key=key).first()
            if pref and pref.value:
                selected_vendor_ids = [int(v.strip()) for v in pref.value.split(',') if v.strip().isdigit()]
        except Exception as e:
            current_app.logger.warning('Falha ao carregar preferências padrão de vendors.', exc_info=e)

    # Se temos preferências carregadas e o filtro não foi explicitamente fornecido,
    # redirecionar para URL com vendor_ids explícitos para consistência e compartilhamento
    try:
        if (not vendor_filter_provided) and selected_vendor_ids and (not vendor_scope_all):
            from urllib.parse import urlencode
            args = dict(request.args)
            args['vendor_ids'] = ','.join(str(x) for x in selected_vendor_ids)
            return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui') + ('?' + urlencode(args) if args else ''))
    except Exception:
        pass
    # Flag explícita usada pelo template para suprimir a tabela quando vendor_ids foi fornecido e está vazio
    try:
        vendor_query_empty_provided = (
            (
                ('vendor_ids' in request.args) or
                (raw_vendor_ids_param is not None) or
                (isinstance(request.query_string, (bytes, bytearray)) and b'vendor_ids' in request.query_string) or
                ('vendor_ids=' in (request.url or ''))
            ) and (len(selected_vendor_ids) == 0) and (not vendor_scope_all)
        )
    except Exception:
        vendor_query_empty_provided = (
            (('vendor_ids' in request.args) or ('vendor_ids=' in (request.url or ''))) and (len(selected_vendor_ids) == 0) and (not vendor_scope_all)
        )

    logger.info(f"Parâmetros: page={page}, per_page={per_page}, severity={severity}, vendor_ids={selected_vendor_ids}, vendor_scope_all={vendor_scope_all}, vendor_filter_provided={vendor_filter_provided}, vendor_query_empty_provided={vendor_query_empty_provided}, search='{search}', cvss_range='{cvss_range}', date_range='{date_range}', start_date='{start_date}', end_date='{end_date}', product='{product}', mitigation_status='{mitigation_status}', vuln_type='{vuln_type}', sort='{sort_param}', catalog_tag='{catalog_tag}', selected_part='{selected_part}'")
    
    # Validar per_page para evitar valores excessivos (exceto quando for 'all')
    if not no_limit and (per_page < 1 or per_page > 100):
        per_page = 20
    
    # Validar página
    if page < 1:
        page = 1

    if severity and severity.upper() not in severity_levels.enums:
        flash(f"Severidade inválida: {severity}", 'warning')
        severity = None
    elif severity:
        severity = severity.upper()

    try:
        # TESTE: Usar query raw para contornar problema do SQLAlchemy
        from sqlalchemy import text
        # Atalho: se o filtro de vendors foi explicitamente fornecido e está vazio,
        # retornar paginação vazia imediatamente, evitando fallback de preferências.
        if vendor_filter_provided and (not selected_vendor_ids and not selected_vendor_names) and not vendor_scope_all:
            logger.info(f"Vendor filter explicitly provided and empty. raw_param={raw_vendor_ids_param!r}, raw_list={raw_vendor_ids_list!r}, query_string={request.query_string!r}, url={request.url!r}")
            class MockPagination:
                def __init__(self, items, page, per_page, total):
                    self.items = items
                    self.page = page
                    self.per_page = per_page
                    self.total = total
                    self.pages = 0
                    self.has_prev = False
                    self.has_next = False
                    self.prev_num = None
                    self.next_num = None

                def iter_pages(self, left_edge=2, left_current=2, right_current=3, right_edge=2):
                    return []

            pagination = MockPagination([], page, per_page, 0)
            logger.info("Filtro vendor_ids explicitamente vazio; retornando lista vazia.")
            return render_template(
                'vulnerabilities/list.html',
                vulnerabilities=pagination.items,
                pagination=pagination,
                filters={'severity': severity},
                selected_vendor_ids=selected_vendor_ids,
                vendor_filter_provided=vendor_filter_provided,
                vendor_query_empty_provided=vendor_query_empty_provided,
                current_catalog_tag=catalog_tag or ''
            )
        
        # Query base
        sql_query = """
        SELECT cve_id, description, published_date, base_severity, cvss_score, 
               patch_available, assigner, source_identifier, vuln_status,
               nvd_vendors_data, nvd_products_data
        FROM vulnerabilities
        """
        
        # Construção dinâmica de filtros
        params = {}
        where_clauses = []
        if severity and severity != 'all':
            where_clauses.append("base_severity = :severity")
            params['severity'] = severity.upper()
        # Filtro por tipo usando catalog_tag -> CPE part com fallback via JSON nvd_cpe_configurations
        if selected_part:
            where_clauses.append(
                "(cve_id IN (SELECT cve_id FROM cve_parts WHERE part = :selected_part) OR LOWER(CAST(nvd_cpe_configurations AS TEXT)) LIKE :cpe_like)"
            )
            params['selected_part'] = selected_part
            params['cpe_like'] = f"%cpe:2.3:{selected_part}%"
        # Caso o filtro por vendor tenha sido explicitamente fornecido e esteja vazio,
        # forçar zero resultados.
        if vendor_filter_provided and (not selected_vendor_ids and not selected_vendor_names) and not vendor_scope_all:
            where_clauses.append("1=0")
        forced_zero_by_invalid_vendor_ids = False
        # Restringir pela vinculação ao ativo, quando fornecido
        if asset_id:
            where_clauses.append("cve_id IN (SELECT cve_id FROM asset_vulnerabilities WHERE asset_id = :asset_id)")
            params['asset_id'] = asset_id
        vendor_filter_applied = False
        if selected_vendor_ids:
            max_chunk = 900
            selected_vendor_ids = list(selected_vendor_ids)
            vendor_chunks = [selected_vendor_ids[i:i+max_chunk] for i in range(0, len(selected_vendor_ids), max_chunk)]
            try:
                total_cve_vendor = db.session.execute(text("SELECT COUNT(*) FROM cve_vendors")).scalar() or 0
            except Exception:
                total_cve_vendor = 0
            selected_assoc_count = 0
            if total_cve_vendor > 0:
                try:
                    assoc_counts = 0
                    for ci, chunk in enumerate(vendor_chunks):
                        placeholders = []
                        chunk_params = {}
                        for i, vid in enumerate(chunk):
                            key = f"vid_{ci}_{i}"
                            placeholders.append(f":{key}")
                            chunk_params[key] = vid
                        assoc_sql = f"SELECT COUNT(*) FROM cve_vendors WHERE vendor_id IN ({', '.join(placeholders)})"
                        assoc_counts += db.session.execute(text(assoc_sql), chunk_params).scalar() or 0
                    selected_assoc_count = assoc_counts
                except Exception:
                    selected_assoc_count = 0
            if total_cve_vendor > 0 and selected_assoc_count > 0:
                vendor_subfilters = []
                for ci, chunk in enumerate(vendor_chunks):
                    placeholders = []
                    chunk_params = {}
                    for i, vid in enumerate(chunk):
                        key = f"vid_{ci}_{i}"
                        placeholders.append(f":{key}")
                        params[key] = vid
                    vendor_subfilters.append(
                        "("
                        + f"cve_id IN (SELECT cve_id FROM cve_vendors WHERE vendor_id IN ({', '.join(placeholders)}))"
                        + " OR "
                        + f"cve_id IN (SELECT cp.cve_id FROM cve_products cp INNER JOIN product p ON p.id = cp.product_id WHERE p.vendor_id IN ({', '.join(placeholders)}))"
                        + ")"
                    )
                where_clauses.append("(" + " OR ".join(vendor_subfilters) + ")")
                vendor_filter_applied = True
            else:
                try:
                    vendor_names = [name for (name,) in db.session.query(Vendor.name).filter(Vendor.id.in_(selected_vendor_ids)).all()]
                except Exception:
                    vendor_names = []
                if vendor_names:
                    vn_subclauses = []
                    for i, name in enumerate(vendor_names):
                        k = f"vn_like_{i}"
                        params[k] = f"%{(name or '').lower()}%"
                        vn_subclauses.append(f"LOWER(CAST(nvd_vendors_data AS TEXT)) LIKE :{k}")
                    where_clauses.append("(" + " OR ".join(vn_subclauses) + ")")
                    vendor_filter_applied = True
                else:
                    forced_zero_by_invalid_vendor_ids = True
                    where_clauses.append("1=0")
        if (not vendor_filter_applied) and selected_vendor_names:
            vn2_subclauses = []
            for i, name in enumerate(selected_vendor_names):
                k = f"vn2_like_{i}"
                params[k] = f"%{(name or '').lower()}%"
                vn2_subclauses.append(f"LOWER(CAST(nvd_vendors_data AS TEXT)) LIKE :{k}")
            where_clauses.append("(" + " OR ".join(vn2_subclauses) + ")")
        # Filtro de busca (CVE ID ou descrição)
        if search:
            where_clauses.append("(LOWER(description) LIKE :search OR UPPER(cve_id) LIKE :search_cve)")
            params['search'] = f"%{search.lower()}%"
            params['search_cve'] = f"%{search.upper()}%"
        # Filtro de faixa CVSS "min-max"
        if cvss_range:
            try:
                parts = [p.strip() for p in cvss_range.split('-')]
                if len(parts) == 2:
                    min_cvss = float(parts[0])
                    max_cvss = float(parts[1])
                    where_clauses.append("cvss_score BETWEEN :min_cvss AND :max_cvss")
                    params['min_cvss'] = min_cvss
                    params['max_cvss'] = max_cvss
            except Exception:
                pass
        # Filtro por período relativo (dias)
        if date_range:
            try:
                days = int(date_range)
                cutoff = datetime.utcnow() - timedelta(days=days)
                where_clauses.append("published_date >= :cutoff_date")
                params['cutoff_date'] = cutoff.isoformat()
            except Exception:
                pass
        # Filtro por intervalo de datas absolutos
        if start_date:
            try:
                sd = datetime.strptime(start_date, '%Y-%m-%d')
                where_clauses.append("published_date >= :start_date")
                params['start_date'] = sd.isoformat()
            except Exception:
                pass
        if end_date:
            try:
                ed = datetime.strptime(end_date, '%Y-%m-%d')
                where_clauses.append("published_date <= :end_date")
                params['end_date'] = ed.isoformat()
            except Exception:
                pass
        # Filtro por produto/vendor (busca em descrição ou JSON de produtos)
        if product:
            where_clauses.append("(LOWER(description) LIKE :product_like OR LOWER(CAST(nvd_products_data AS TEXT)) LIKE :product_like)")
            params['product_like'] = f"%{product.lower()}%"
        if selected_product_names:
            pn_subclauses = []
            for i, name in enumerate(selected_product_names):
                k = f"pn_like_{i}"
                params[k] = f"%{(name or '').lower()}%"
                pn_subclauses.append(f"LOWER(CAST(nvd_products_data AS TEXT)) LIKE :{k}")
            where_clauses.append("(" + " OR ".join(pn_subclauses) + ")")
        # Filtro por status de mitigação
        if mitigation_status:
            where_clauses.append("vuln_status = :mitigation_status")
            params['mitigation_status'] = mitigation_status
        # Filtro por tipo de vulnerabilidade (mapeado para CWE e palavras-chave)
        if vuln_type:
            normalized = vuln_type.strip().lower()
            cwe_ids = []
            description_keywords = []
            if normalized == 'sqli':
                cwe_ids = ['CWE-89']
                description_keywords = ['sql injection']
            elif normalized == 'xss':
                cwe_ids = ['CWE-79']
                description_keywords = ['cross-site scripting', 'xss']
            elif normalized == 'csrf':
                cwe_ids = ['CWE-352']
                description_keywords = ['cross-site request forgery', 'csrf']
            elif normalized == 'information_disclosure':
                cwe_ids = ['CWE-200']
                description_keywords = ['information disclosure', 'information exposure', 'data leak', 'data leakage']
            elif normalized == 'privilege_escalation':
                cwe_ids = ['CWE-862']
                description_keywords = ['privilege escalation', 'elevation of privilege']
            elif normalized == 'rce':
                cwe_ids = ['CWE-78', 'CWE-94', 'CWE-119', 'CWE-787', 'CWE-416']
                description_keywords = ['remote code execution', 'rce', 'code execution']
            elif normalized == 'dos':
                description_keywords = ['denial of service', 'dos']
            vuln_type_subclauses = []
            if cwe_ids:
                cwe_placeholders = []
                for i, cwe in enumerate(cwe_ids):
                    key = f"cwe_{i}"
                    cwe_placeholders.append(f":{key}")
                    params[key] = cwe
                vuln_type_subclauses.append(
                    f"cve_id IN (SELECT cve_id FROM weaknesses WHERE cwe_id IN ({', '.join(cwe_placeholders)}))"
                )
            if description_keywords:
                keyword_conditions = []
                for i, kw in enumerate(description_keywords):
                    key = f"kw_{i}"
                    params[key] = f"%{kw.lower()}%"
                    keyword_conditions.append("LOWER(description) LIKE :" + key)
                vuln_type_subclauses.append("(" + " OR ".join(keyword_conditions) + ")")
            if vuln_type_subclauses:
                where_clauses.append("(" + " OR ".join(vuln_type_subclauses) + ")")
        if where_clauses:
            sql_query += " WHERE " + " AND ".join(where_clauses)

        # Ordenação dinâmica
        order_by_sql = "published_date DESC"
        if sort_param == 'published_date_asc':
            order_by_sql = "published_date ASC"
        elif sort_param == 'cvss_score_desc':
            order_by_sql = "cvss_score DESC"
        elif sort_param == 'cvss_score_asc':
            order_by_sql = "cvss_score ASC"
        elif sort_param == 'severity_desc':
            order_by_sql = "CASE base_severity WHEN 'CRITICAL' THEN 4 WHEN 'HIGH' THEN 3 WHEN 'MEDIUM' THEN 2 WHEN 'LOW' THEN 1 ELSE 0 END DESC"
        elif sort_param == 'severity_asc':
            order_by_sql = "CASE base_severity WHEN 'LOW' THEN 1 WHEN 'MEDIUM' THEN 2 WHEN 'HIGH' THEN 3 WHEN 'CRITICAL' THEN 4 ELSE 0 END ASC"

        sql_query += f" ORDER BY {order_by_sql}"
        if not no_limit:
            sql_query += " LIMIT :limit OFFSET :offset"
            params['limit'] = per_page
            params['offset'] = (page - 1) * per_page
        
        # Executar query
        result = db.session.execute(text(sql_query), params)
        raw_vulnerabilities = result.fetchall()
        
        # Processar dados JSON para converter strings em listas
        import json
        vulnerabilities = []
        for vuln in raw_vulnerabilities:
            # Converter Row para dict para poder modificar
            vuln_dict = dict(vuln._mapping)
            
            # Parse dos campos JSON
            if vuln_dict.get('nvd_vendors_data') and isinstance(vuln_dict['nvd_vendors_data'], str):
                try:
                    vuln_dict['nvd_vendors_data'] = json.loads(vuln_dict['nvd_vendors_data'])
                except (json.JSONDecodeError, TypeError):
                    vuln_dict['nvd_vendors_data'] = []
            elif not vuln_dict.get('nvd_vendors_data'):
                vuln_dict['nvd_vendors_data'] = []
                
            if vuln_dict.get('nvd_products_data') and isinstance(vuln_dict['nvd_products_data'], str):
                try:
                    vuln_dict['nvd_products_data'] = json.loads(vuln_dict['nvd_products_data'])
                except (json.JSONDecodeError, TypeError):
                    vuln_dict['nvd_products_data'] = []
            elif not vuln_dict.get('nvd_products_data'):
                vuln_dict['nvd_products_data'] = []
            
            # Criar objeto simples para o template
            class VulnObject:
                def __init__(self, data):
                    for key, value in data.items():
                        setattr(self, key, value)
            
            vulnerabilities.append(VulnObject(vuln_dict))
        
        # Contar total para paginação (replicando filtros)
        count_sql = "SELECT COUNT(*) FROM vulnerabilities"
        count_params = {}
        count_clauses = []
        if severity and severity != 'all':
            count_clauses.append("base_severity = :severity")
            count_params['severity'] = severity.upper()
        if selected_part:
            count_clauses.append(
                "(cve_id IN (SELECT cve_id FROM cve_parts WHERE part = :selected_part) OR LOWER(CAST(nvd_cpe_configurations AS TEXT)) LIKE :cpe_like)"
            )
            count_params['selected_part'] = selected_part
            count_params['cpe_like'] = f"%cpe:2.3:{selected_part}%"
        # Espelhar a mesma regra de zero resultados no contador
        if vendor_filter_provided and (not selected_vendor_ids and not selected_vendor_names):
            count_clauses.append("1=0")
        # Replicar restrição por ativo no contador
        if asset_id:
            count_clauses.append("cve_id IN (SELECT cve_id FROM asset_vulnerabilities WHERE asset_id = :c_asset_id)")
            count_params['c_asset_id'] = asset_id
        selected_vendor_filter_applied = False
        if selected_vendor_ids:
            max_chunk = 900
            selected_vendor_ids = list(selected_vendor_ids)
            vendor_chunks = [selected_vendor_ids[i:i+max_chunk] for i in range(0, len(selected_vendor_ids), max_chunk)]
            try:
                total_cve_vendor = db.session.execute(text("SELECT COUNT(*) FROM cve_vendors")).scalar() or 0
            except Exception:
                total_cve_vendor = 0
            selected_assoc_count = 0
            if total_cve_vendor > 0:
                try:
                    assoc_counts = 0
                    for ci, chunk in enumerate(vendor_chunks):
                        placeholders = []
                        chunk_params = {}
                        for i, vid in enumerate(chunk):
                            key = f"c_vid_{ci}_{i}"
                            placeholders.append(f":{key}")
                            count_params[key] = vid
                        assoc_sql = f"SELECT COUNT(*) FROM cve_vendors WHERE vendor_id IN ({', '.join(placeholders)})"
                        assoc_counts += db.session.execute(text(assoc_sql), {k: count_params[k] for k in count_params if k.startswith(f'c_vid_{ci}_')}).scalar() or 0
                    selected_assoc_count = assoc_counts
                except Exception:
                    selected_assoc_count = 0
            if total_cve_vendor > 0 and selected_assoc_count > 0:
                subfilters = []
                for ci, chunk in enumerate(vendor_chunks):
                    placeholders = []
                    for i, vid in enumerate(chunk):
                        key = f"c_vid_{ci}_{i}"
                        placeholders.append(f":{key}")
                    subfilters.append(
                        "("
                        + f"cve_id IN (SELECT cve_id FROM cve_vendors WHERE vendor_id IN ({', '.join(placeholders)}))"
                        + " OR "
                        + f"cve_id IN (SELECT cp.cve_id FROM cve_products cp INNER JOIN product p ON p.id = cp.product_id WHERE p.vendor_id IN ({', '.join(placeholders)}))"
                        + ")"
                    )
                count_clauses.append("(" + " OR ".join(subfilters) + ")")
                selected_vendor_filter_applied = True
            else:
                try:
                    vendor_names = [name for (name,) in db.session.query(Vendor.name).filter(Vendor.id.in_(selected_vendor_ids)).all()]
                except Exception:
                    vendor_names = []
                if vendor_names:
                    vn_subclauses = []
                    for i, name in enumerate(vendor_names):
                        k = f"c_vn_like_{i}"
                        count_params[k] = f"%{(name or '').lower()}%"
                        vn_subclauses.append(f"LOWER(CAST(nvd_vendors_data AS TEXT)) LIKE :{k}")
                    count_clauses.append("(" + " OR ".join(vn_subclauses) + ")")
                    selected_vendor_filter_applied = True
                else:
                    count_clauses.append("1=0")
        if (not selected_vendor_filter_applied) and selected_vendor_names:
            vn2_subclauses = []
            for i, name in enumerate(selected_vendor_names):
                k = f"c_vn2_like_{i}"
                count_params[k] = f"%{(name or '').lower()}%"
                vn2_subclauses.append(f"LOWER(CAST(nvd_vendors_data AS TEXT)) LIKE :{k}")
            count_clauses.append("(" + " OR ".join(vn2_subclauses) + ")")
        # Replicar filtros avançados
        if search:
            count_clauses.append("(LOWER(description) LIKE :c_search OR UPPER(cve_id) LIKE :c_search_cve)")
            count_params['c_search'] = f"%{search.lower()}%"
            count_params['c_search_cve'] = f"%{search.upper()}%"
        if cvss_range:
            try:
                parts = [p.strip() for p in cvss_range.split('-')]
                if len(parts) == 2:
                    min_cvss = float(parts[0])
                    max_cvss = float(parts[1])
                    count_clauses.append("cvss_score BETWEEN :c_min_cvss AND :c_max_cvss")
                    count_params['c_min_cvss'] = min_cvss
                    count_params['c_max_cvss'] = max_cvss
            except Exception:
                pass
        if date_range:
            try:
                days = int(date_range)
                cutoff = datetime.utcnow() - timedelta(days=days)
                count_clauses.append("published_date >= :c_cutoff_date")
                count_params['c_cutoff_date'] = cutoff.isoformat()
            except Exception:
                pass
        if start_date:
            try:
                sd = datetime.strptime(start_date, '%Y-%m-%d')
                count_clauses.append("published_date >= :c_start_date")
                count_params['c_start_date'] = sd.isoformat()
            except Exception:
                pass
        if end_date:
            try:
                ed = datetime.strptime(end_date, '%Y-%m-%d')
                count_clauses.append("published_date <= :c_end_date")
                count_params['c_end_date'] = ed.isoformat()
            except Exception:
                pass
        if product:
            count_clauses.append("(LOWER(description) LIKE :c_product_like OR LOWER(CAST(nvd_products_data AS TEXT)) LIKE :c_product_like)")
            count_params['c_product_like'] = f"%{product.lower()}%"
        if 'selected_product_names' in locals() and selected_product_names:
            c_pn_subclauses = []
            for i, name in enumerate(selected_product_names):
                k = f"c_pn_like_{i}"
                count_params[k] = f"%{(name or '').lower()}%"
                c_pn_subclauses.append(f"LOWER(CAST(nvd_products_data AS TEXT)) LIKE :{k}")
            count_clauses.append("(" + " OR ".join(c_pn_subclauses) + ")")
        if mitigation_status:
            count_clauses.append("vuln_status = :c_mitigation_status")
            count_params['c_mitigation_status'] = mitigation_status
        # Filtro por tipo de vulnerabilidade (mapeado para CWE e palavras-chave)
        if vuln_type:
            normalized = vuln_type.strip().lower()
            cwe_ids = []
            description_keywords = []
            if normalized == 'sqli':
                cwe_ids = ['CWE-89']
                description_keywords = ['sql injection']
            elif normalized == 'xss':
                cwe_ids = ['CWE-79']
                description_keywords = ['cross-site scripting', 'xss']
            elif normalized == 'csrf':
                cwe_ids = ['CWE-352']
                description_keywords = ['cross-site request forgery', 'csrf']
            elif normalized == 'information_disclosure':
                cwe_ids = ['CWE-200']
                description_keywords = ['information disclosure', 'information exposure', 'data leak', 'data leakage']
            elif normalized == 'privilege_escalation':
                cwe_ids = ['CWE-862']
                description_keywords = ['privilege escalation', 'elevation of privilege']
            elif normalized == 'rce':
                cwe_ids = ['CWE-78', 'CWE-94', 'CWE-119', 'CWE-787', 'CWE-416']
                description_keywords = ['remote code execution', 'rce', 'code execution']
            elif normalized == 'dos':
                description_keywords = ['denial of service', 'dos']
            vuln_type_subclauses = []
            if cwe_ids:
                cwe_placeholders = []
                for i, cwe in enumerate(cwe_ids):
                    key = f"c_cwe_{i}"
                    cwe_placeholders.append(f":{key}")
                    count_params[key] = cwe
                vuln_type_subclauses.append(
                    f"cve_id IN (SELECT cve_id FROM weaknesses WHERE cwe_id IN ({', '.join(cwe_placeholders)}))"
                )
            if description_keywords:
                keyword_conditions = []
                for i, kw in enumerate(description_keywords):
                    key = f"c_kw_{i}"
                    count_params[key] = f"%{kw.lower()}%"
                    keyword_conditions.append("LOWER(description) LIKE :" + key)
                vuln_type_subclauses.append("(" + " OR ".join(keyword_conditions) + ")")
            if vuln_type_subclauses:
                count_clauses.append("(" + " OR ".join(vuln_type_subclauses) + ")")
        if count_clauses:
            count_sql += " WHERE " + " AND ".join(count_clauses)
        count_result = db.session.execute(text(count_sql), count_params)
        total = count_result.scalar()
        # Quando per_page=all, ajustar per_page para total para refletir a exibição completa
        if no_limit:
            try:
                per_page = max(int(total or 0), 1)
            except Exception:
                per_page = 1
        
        # Criar objeto de paginação manual
        class MockPagination:
            def __init__(self, items, page, per_page, total):
                self.items = items
                self.page = page
                self.per_page = per_page
                self.total = total
                self.pages = (total + per_page - 1) // per_page
                self.has_prev = page > 1
                self.has_next = page < self.pages
                self.prev_num = page - 1 if self.has_prev else None
                self.next_num = page + 1 if self.has_next else None

            def iter_pages(self, left_edge=2, left_current=2, right_current=3, right_edge=2):
                last = 0
                for num in range(1, self.pages + 1):
                    if (
                        num <= left_edge
                        or (num >= self.page - left_current and num <= self.page + right_current)
                        or (num > self.pages - right_edge)
                    ):
                        if last + 1 != num:
                            yield None
                        yield num
                        last = num
        
        pagination = MockPagination(vulnerabilities, page, per_page, total)
        
        logger.info(f"Vulnerabilities encontradas: {len(vulnerabilities)}")
        logger.info(f"Pagination.items: {len(pagination.items)}")
        logger.info(f"Pagination.items é truthy: {bool(pagination.items)}")
        logger.info(f"Total: {total}")

        # Para requisições AJAX, retornar apenas o conteúdo da tabela
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            logger.info("Renderizando template AJAX")
            return render_template(
                'vulnerabilities/table.html',
                vulnerabilities=pagination.items,
                pagination=pagination,
                filters={'severity': severity},
                selected_vendor_ids=selected_vendor_ids,
                vendor_filter_provided=vendor_filter_provided,
                vendor_query_empty_provided=vendor_query_empty_provided,
                current_catalog_tag=catalog_tag or ''
            )

        logger.info("Renderizando template principal")
        return render_template(
            'vulnerabilities/list.html',
            vulnerabilities=pagination.items,
            pagination=pagination,
            filters={'severity': severity},
            selected_vendor_ids=selected_vendor_ids,
            vendor_filter_provided=vendor_filter_provided,
            vendor_query_empty_provided=vendor_query_empty_provided,
            current_catalog_tag=catalog_tag or ''
        )
        
    except Exception as e:
        logger.error(f"Erro ao carregar vulnerabilidades: {e}")
        flash('Erro ao carregar vulnerabilidades. Tente novamente.', 'danger')
        return render_template(
            'vulnerabilities/list.html',
            vulnerabilities=[],
            pagination=None,
            filters={'severity': severity},
            selected_vendor_ids=[],
            vendor_filter_provided=True
        )

@vuln_ui_bp.route('/vendors', methods=['GET'])
@login_required
def vendor_selection_ui():
    """Página de seleção de fornecedores (vendors) com checkboxes e paginação com filtro por tipo (category_tag)."""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        # Proteção: limitar per_page para evitar consultas muito pesadas e valores inválidos
        try:
            if per_page is None or per_page <= 0:
                per_page = 20
            elif per_page > 200:
                per_page = 200
        except Exception:
            per_page = 20
        q = request.args.get('q', '', type=str)
        # Suportar alias 'catalog_tag' além de 'category_tag' para consistência com UI
        category_tag = (request.args.get('category_tag', '', type=str) or 
                        request.args.get('catalog_tag', '', type=str))
        current_severity = request.args.get('severity', '', type=str) or ''
        # Suporta tanto múltiplos parâmetros (vendor_ids=1&vendor_ids=2) quanto lista única (vendor_ids=1,2,3)
        raw_vendor_ids_list = request.args.getlist('vendor_ids')
        raw_vendor_ids_param = request.args.get('vendor_ids', '')
        selected_vendor_ids: list[int] = []
        if raw_vendor_ids_list:
            for item in raw_vendor_ids_list:
                parts = str(item).split(',')
                for p in parts:
                    try:
                        n = int(p.strip())
                        selected_vendor_ids.append(n)
                    except Exception:
                        continue
        elif raw_vendor_ids_param:
            for p in raw_vendor_ids_param.split(','):
                try:
                    n = int(p.strip())
                    selected_vendor_ids.append(n)
                except Exception:
                    continue
        # Deduplicar e ordenar
        selected_vendor_ids = sorted(set(selected_vendor_ids))
        # Aplicar preferências padrão de vendors do usuário se nenhuma seleção foi fornecida
        if not selected_vendor_ids:
            try:
                if is_user_authenticated():
                    key = f'user_vendor_preferences:{current_user.id}'
                    meta = db.session.query(SyncMetadata).filter_by(key=key).first()
                    if meta and meta.value:
                        selected_vendor_ids = [int(v.strip()) for v in meta.value.split(',') if v.strip().isdigit()]
            except Exception as e:
                current_app.logger.warning("Falha ao carregar preferências de vendors do usuário.", exc_info=e)

        # Mapear category_tag para o "part" da CPE (a=software/application, o=os, h=hardware)
        # Incluir sinônimos para maior compatibilidade com a UI/links
        part_map = {
            'software': 'a',
            'application': 'a',
            'os': 'o',
            'operating_system': 'o',
            'hardware': 'h'
        }
        # Verificar se a categoria é válida
        if category_tag and category_tag not in part_map:
            current_app.logger.warning(f"Categoria inválida: {category_tag}")
            category_tag = ''
            
        selected_part = part_map.get(category_tag, '')

        # Pré-computar o conjunto de CVE IDs por "part" para utilizar nos fallbacks via JSON
        # Isso evita apresentar aplicações quando o filtro for "operating_system" ou "hardware".
        cve_ids_by_part = None
        try:
            if selected_part:
                ids_rows = db.session.query(CVEPart.cve_id).filter(CVEPart.part == selected_part).all()
                # Normalizar para um set de strings/ids
                cve_ids_by_part = set([str(r[0]) if not hasattr(r, 'cve_id') else str(r.cve_id) for r in ids_rows])
        except Exception as e:
            current_app.logger.warning("Falha ao pré-computar cve_ids_by_part; prosseguindo sem restrição por part no fallback.", exc_info=e)

        from sqlalchemy import func, text, or_, cast, String

        try:
            total_cve_vendor = db.session.query(func.count('*')).select_from(CVEVendor).scalar()
        except SQLAlchemyError as e:
            current_app.logger.warning(
                "Falha ao acessar tabela cve_vendors (contagem). Aplicando fallback via JSON.",
                exc_info=e
            )
            total_cve_vendor = 0

        selected_part = selected_part or ''

        total_cve_vendor = 0

        if total_cve_vendor and total_cve_vendor > 0:
            # Contagem via tabela normalizada cve_vendors com filtro opcional por part usando JOIN em cve_parts
            if selected_part:
                cve_counts_query = (
                    db.session.query(
                        CVEVendor.vendor_id.label('vendor_id'),
                        func.count(func.distinct(CVEVendor.cve_id)).label('cve_count')
                    )
                    .join(CVEPart, CVEPart.cve_id == CVEVendor.cve_id)
                    .filter(CVEPart.part == selected_part)
                    .group_by(CVEVendor.vendor_id)
                )
            else:
                cve_counts_query = db.session.query(
                    CVEVendor.vendor_id.label('vendor_id'),
                    func.count(func.distinct(CVEVendor.cve_id)).label('cve_count')
                ).group_by(CVEVendor.vendor_id)

            cve_counts_sq = cve_counts_query.subquery()

            # Quando houver filtro por tipo, usar INNER JOIN para retornar apenas vendors com contagem > 0;
            # caso contrário, OUTER JOIN para exibir a lista completa.
            if selected_part:
                # Selecionar a entidade Vendor para robustez na normalização
                query = (
                    db.session.query(
                        Vendor,
                        cve_counts_sq.c.cve_count.label('cve_count')
                    )
                    .join(cve_counts_sq, Vendor.id == cve_counts_sq.c.vendor_id)
                    .order_by(Vendor.name.asc())
                )
            else:
                query = (
                    db.session.query(
                        Vendor,
                        func.coalesce(cve_counts_sq.c.cve_count, 0).label('cve_count')
                    )
                    .outerjoin(cve_counts_sq, Vendor.id == cve_counts_sq.c.vendor_id)
                    .order_by(Vendor.name.asc())
                )
        else:
            # Fallback: contar via JSON (SQLite) usando Vulnerability.nvd_vendors_data + filtro por part via nvd_cpe_configurations
            from collections import defaultdict
            import json
            vendor_counts = defaultdict(int)
            q_vulns = db.session.query(Vulnerability.cve_id, Vulnerability.nvd_vendors_data, Vulnerability.nvd_cpe_configurations)
            # Restringir universo por part quando disponível (via tabela cve_parts)
            if selected_part and cve_ids_by_part:
                # Evitar exceder limite de parâmetros do banco (ex.: SQLite 999)
                try:
                    cve_ids_list = list(cve_ids_by_part or [])
                except Exception:
                    cve_ids_list = []
                if cve_ids_list:
                    chunk_size = 900
                    filters = []
                    for i in range(0, len(cve_ids_list), chunk_size):
                        chunk = cve_ids_list[i:i + chunk_size]
                        filters.append(Vulnerability.cve_id.in_(chunk))
                    if filters:
                        q_vulns = q_vulns.filter(or_(*filters))
            vulns = q_vulns.all()
            for cve_id, vendors_json, cpe_configs in vulns:
                # Se filtrar por tipo, verifica se o CVE tem pelo menos uma CPE com o part desejado
                if selected_part:
                    try:
                        if isinstance(cpe_configs, str):
                            try:
                                cfgs = json.loads(cpe_configs)
                            except json.JSONDecodeError:
                                cfgs = []
                        else:
                            cfgs = cpe_configs or []
                    except Exception as e:
                        current_app.logger.warning(f"Erro ao processar configurações CPE: {str(e)}")
                        cfgs = []
                    
                    has_part = False
                    try:
                        for config in cfgs or []:
                            if not isinstance(config, dict):
                                continue
                            nodes = config.get('nodes', [])
                            if not isinstance(nodes, list):
                                continue
                            
                            for node in nodes:
                                if not isinstance(node, dict):
                                    continue
                                cpe_matches = node.get('cpeMatch', [])
                                if not isinstance(cpe_matches, list):
                                    continue
                                    
                                for cpe_match in cpe_matches:
                                    if not isinstance(cpe_match, dict):
                                        continue
                                    cpe_uri = cpe_match.get('criteria', '')
                                    if isinstance(cpe_uri, str) and cpe_uri.startswith('cpe:2.3:'):
                                        parts = cpe_uri.split(':')
                                        if len(parts) > 2 and parts[2] == selected_part:
                                            has_part = True
                                            break
                                if has_part:
                                    break
                            if has_part:
                                break
                    except Exception as e:
                        current_app.logger.warning(f"Erro ao processar CPE matches: {str(e)}")
                        # Continuar mesmo com erro, mas registrar para debug
                        
                    # Se não encontrou o part desejado, pula este CVE
                    if not has_part:
                        continue
                # Incrementa contagem por vendor
                try:
                    if isinstance(vendors_json, str):
                        try:
                            vendor_list = json.loads(vendors_json)
                        except json.JSONDecodeError:
                            vendor_list = []
                    else:
                        vendor_list = vendors_json or []
                except Exception as e:
                    current_app.logger.warning(f"Erro ao processar vendors_json: {str(e)}")
                    vendor_list = []
                
                vendor_original = {}
                try:
                    for vn in vendor_list or []:
                        if isinstance(vn, str) and vn.strip():
                            key = vn.strip().lower()
                            vendor_counts[key] += 1
                            if key not in vendor_original:
                                vendor_original[key] = vn.strip()
                except Exception as e:
                    current_app.logger.warning(f"Erro ao processar lista de vendors: {str(e)}")
            # Buscar vendors existentes compatíveis
            vendor_names_lower = list(vendor_counts.keys())
            base_vendors = []
            if vendor_names_lower:
                chunk_size = 900  # evita erro do SQLite: too many SQL variables
                for i in range(0, len(vendor_names_lower), chunk_size):
                    names_chunk = vendor_names_lower[i:i+chunk_size]
                    chunk_rows = (
                        db.session.query(Vendor.id, Vendor.name)
                        .filter(func.lower(Vendor.name).in_(names_chunk))
                        .order_by(Vendor.name.asc())
                        .all()
                    )
                    base_vendors.extend(chunk_rows)
                # Garantir ordenação consistente após agregação por chunks
                try:
                    base_vendors.sort(key=lambda x: (x[1] or '').lower())
                except Exception:
                    pass
            existing_lower = {(nm or '').strip().lower() for _, nm in base_vendors}
            vendor_dicts = [
                {'id': vid, 'name': vname, 'cve_count': vendor_counts.get((vname or '').strip().lower(), 0)}
                for vid, vname in base_vendors
            ]
            for nm_lower in vendor_names_lower:
                if nm_lower not in existing_lower:
                    vendor_dicts.append({
                        'id': None,
                        'name': vendor_original.get(nm_lower, nm_lower),
                        'cve_count': vendor_counts.get(nm_lower, 0)
                    })
            try:
                vendor_dicts.sort(key=lambda v: (v.get('name') or '').lower())
            except Exception:
                pass

            # Adicionar filtro por nome (parâmetro 'q') se estiver presente
            if q:
                q_lower = q.lower()
                vendor_dicts = [v for v in vendor_dicts if q_lower in v['name'].lower()]

            total = len(vendor_dicts)
            # Paginação manual
            class MockPagination:
                def __init__(self, items, page, per_page, total):
                    self.items = items
                    self.page = page
                    self.per_page = per_page
                    self.total = total
                    self.pages = (total + per_page - 1) // per_page
                    self.has_prev = page > 1
                    self.has_next = page < self.pages
                    self.prev_num = page - 1 if self.has_prev else None
                    self.next_num = page + 1 if self.has_next else None

                def iter_pages(self, left_edge=2, left_current=2, right_current=3, right_edge=2):
                    last = 0
                    for num in range(1, self.pages + 1):
                        if (
                            num <= left_edge
                            or (num >= self.page - left_current and num <= self.page + right_current)
                            or (num > self.pages - right_edge)
                        ):
                            if last + 1 != num:
                                yield None
                            yield num
                            last = num
            start = (page - 1) * per_page
            end = start + per_page
            items = vendor_dicts[start:end]
            pagination = MockPagination(items, page, per_page, total)
            return render_template(
                'vulnerabilities/vendor_selection.html',
                vendors=pagination.items,
                pagination=pagination,
                current_category=category_tag or '',
                current_severity=current_severity,
                selected_vendor_ids=selected_vendor_ids,
                all_vendor_ids=[v['id'] for v in vendor_dicts]
            )

        if q:
            query = query.filter(Vendor.name.ilike(f"%{q}%"))

        # Coletar todos os IDs de vendors compatíveis com os filtros atuais (para seleção global)
        try:
            all_ids_rows = query.with_entities(Vendor.id).all()
            all_vendor_ids = [int(getattr(r, 'id', r[0])) for r in all_ids_rows]
        except Exception:
            all_vendor_ids = []

        pagination = paginate_query(query, page=page, per_page=per_page, error_out=False)

        vendors_items = []
        rows_info = []
        try:
            for item in pagination.items:
                vid = None
                name = None
                ccount = None
                if hasattr(item, '_mapping'):
                    m = item._mapping
                    vid = m.get('id', m.get('vendor_id', m.get('Vendor_id')))
                    name = m.get('name', m.get('vendor_name', m.get('Vendor_name')))
                    ccount = m.get('cve_count')
                    if ccount is None:
                        ccount = m.get('count', m.get('vendor_count', m.get('coalesce', m.get('coalesce_1'))))
                elif isinstance(item, tuple):
                    if len(item) >= 3 and isinstance(item[0], (int, str)):
                        vid = item[0]
                        name = item[1]
                        ccount = item[2]
                    elif len(item) >= 2 and hasattr(item[0], 'id') and hasattr(item[0], 'name'):
                        vid = getattr(item[0], 'id', None)
                        name = getattr(item[0], 'name', None)
                        ccount = item[1] if len(item) > 1 else None
                    elif len(item) >= 2:
                        vid = item[0]
                        name = item[1]
                        ccount = item[2] if len(item) > 2 else None
                else:
                    vid = getattr(item, 'id', None)
                    name = getattr(item, 'name', None)
                    ccount = getattr(item, 'cve_count', None)
                try:
                    if ccount is not None:
                        ccount = int(ccount)
                except (TypeError, ValueError):
                    ccount = 0
                if vid is not None and name is not None:
                    rows_info.append((vid, name, ccount))
        except Exception as e:
            current_app.logger.warning("Falha ao normalizar vendors.", exc_info=e)
            rows_info = [
                (getattr(it, 'id', None), getattr(it, 'name', None), getattr(it, 'cve_count', 0))
                for it in getattr(pagination, 'items', []) or []
            ]

        if selected_part and not rows_info:
            try:
                from collections import defaultdict
                import json
                vendor_counts = defaultdict(int)
                cve_ids_list = []
                try:
                    cve_ids_list = list(cve_ids_by_part) if cve_ids_by_part else []
                except Exception:
                    cve_ids_list = list(cve_ids_by_part or [])
                vulns_rows = []
                if cve_ids_list:
                    chunk_size = 900
                    for i in range(0, len(cve_ids_list), chunk_size):
                        chunk = cve_ids_list[i:i + chunk_size]
                        rows = (
                            db.session.query(Vulnerability.cve_id, Vulnerability.nvd_vendors_data)
                            .filter(Vulnerability.cve_id.in_(chunk))
                            .all()
                        )
                        if rows:
                            vulns_rows.extend(rows)
                else:
                    vulns_rows = db.session.query(
                        Vulnerability.cve_id, Vulnerability.nvd_vendors_data
                    ).all()
                for _cid, vendors_json in vulns_rows:
                    try:
                        vlist = json.loads(vendors_json) if isinstance(vendors_json, str) else (vendors_json or [])
                    except Exception:
                        vlist = []
                    if not vlist:
                        continue
                    for vn in vlist:
                        if isinstance(vn, str):
                            ln = vn.strip().lower()
                            if ln:
                                vendor_counts[ln] += 1
                vendor_names_lower = list(vendor_counts.keys())
                base_vendors = []
                if vendor_names_lower:
                    chunk_size = 900
                    for i in range(0, len(vendor_names_lower), chunk_size):
                        names_chunk = vendor_names_lower[i:i+chunk_size]
                        chunk_rows = (
                            db.session.query(Vendor.id, Vendor.name)
                            .filter(func.lower(Vendor.name).in_(names_chunk))
                            .order_by(Vendor.name.asc())
                            .all()
                        )
                        base_vendors.extend(chunk_rows)
                    try:
                        base_vendors.sort(key=lambda x: (x[1] or '').lower())
                    except Exception:
                        pass
                vendor_dicts = [
                    {'id': vid, 'name': vname, 'cve_count': vendor_counts.get((vname or '').strip().lower(), 0)}
                    for vid, vname in base_vendors
                ]
                if q:
                    q_lower = q.lower()
                    vendor_dicts = [v for v in vendor_dicts if q_lower in (v['name'] or '').lower()]
                class MockPagination:
                    def __init__(self, items, page, per_page, total):
                        self.items = items
                        self.page = page
                        self.per_page = per_page
                        self.total = total
                        self.pages = (total + per_page - 1) // per_page
                        self.has_prev = page > 1
                        self.has_next = page < self.pages
                        self.prev_num = page - 1 if self.has_prev else None
                        self.next_num = page + 1 if self.has_next else None
                    def iter_pages(self, left_edge=2, left_current=2, right_current=3, right_edge=2):
                        last = 0
                        for num in range(1, self.pages + 1):
                            if (
                                num <= left_edge
                                or (num >= self.page - left_current and num <= self.page + right_current)
                                or (num > self.pages - right_edge)
                            ):
                                if last + 1 != num:
                                    yield None
                                yield num
                                last = num
                start = (page - 1) * per_page
                end = start + per_page
                items = vendor_dicts[start:end]
                pagination2 = MockPagination(vendor_dicts, page, per_page, len(vendor_dicts))
                return render_template(
                    'vulnerabilities/vendor_selection.html',
                    vendors=items,
                    pagination=pagination2,
                    current_category=category_tag or '',
                    current_severity=current_severity,
                    selected_vendor_ids=selected_vendor_ids
                )
            except Exception as e:
                current_app.logger.warning("Fallback JSON falhou.", exc_info=e)

        try:
            from collections import defaultdict
            import json
            vendor_counts_all = defaultdict(int)
            qv = db.session.query(Vulnerability.cve_id, Vulnerability.nvd_vendors_data, Vulnerability.nvd_cpe_configurations)
            if selected_part and cve_ids_by_part:
                try:
                    cve_ids_list = list(cve_ids_by_part or [])
                except Exception:
                    cve_ids_list = []
                if cve_ids_list:
                    chunk_size = 900
                    filters = []
                    for i in range(0, len(cve_ids_list), chunk_size):
                        chunk = cve_ids_list[i:i + chunk_size]
                        filters.append(Vulnerability.cve_id.in_(chunk))
                    if filters:
                        qv = qv.filter(or_(*filters))
            vulns_rows = qv.all()
            for _cid, vendors_json, cpe_configs in vulns_rows:
                if selected_part:
                    try:
                        if isinstance(cpe_configs, str):
                            try:
                                cfgs = json.loads(cpe_configs)
                            except json.JSONDecodeError:
                                cfgs = []
                        else:
                            cfgs = cpe_configs or []
                    except Exception:
                        cfgs = []
                    has_part = False
                    try:
                        for config in cfgs or []:
                            if not isinstance(config, dict):
                                continue
                            nodes = config.get('nodes', [])
                            if not isinstance(nodes, list):
                                continue
                            for node in nodes:
                                if not isinstance(node, dict):
                                    continue
                                cpe_matches = node.get('cpeMatch', [])
                                if not isinstance(cpe_matches, list):
                                    continue
                                for cpe_match in cpe_matches:
                                    if not isinstance(cpe_match, dict):
                                        continue
                                    cpe_uri = cpe_match.get('criteria', '')
                                    if isinstance(cpe_uri, str) and cpe_uri.startswith('cpe:2.3:'):
                                        parts = cpe_uri.split(':')
                                        if len(parts) > 2 and parts[2] == selected_part:
                                            has_part = True
                                            break
                                if has_part:
                                    break
                            if has_part:
                                break
                    except Exception:
                        has_part = False
                    if not has_part:
                        continue
                try:
                    if isinstance(vendors_json, str):
                        try:
                            vlist = json.loads(vendors_json)
                        except json.JSONDecodeError:
                            vlist = []
                    else:
                        vlist = vendors_json or []
                except Exception:
                    vlist = []
                if not vlist:
                    continue
                for vn in vlist or []:
                    if isinstance(vn, str) and vn.strip():
                        vendor_counts_all[vn.strip().lower()] += 1
            vendor_names_lower = list(vendor_counts_all.keys())
            base_vendors = []
            if vendor_names_lower:
                chunk_size = 900
                for i in range(0, len(vendor_names_lower), chunk_size):
                    names_chunk = vendor_names_lower[i:i+chunk_size]
                    chunk_rows = (
                        db.session.query(Vendor.id, Vendor.name)
                        .filter(func.lower(Vendor.name).in_(names_chunk))
                        .order_by(Vendor.name.asc())
                        .all()
                    )
                    base_vendors.extend(chunk_rows)
            existing_lower = {(nm or '').strip().lower() for _, nm in base_vendors}
            missing_names = [n for n in vendor_names_lower if n not in existing_lower]
            if missing_names:
                to_create = [Vendor(name=n) for n in sorted({m for m in missing_names if (m or '').strip()})]
                if to_create:
                    try:
                        db.session.bulk_save_objects(to_create)
                        db.session.commit()
                    except Exception:
                        try:
                            db.session.rollback()
                        except Exception:
                            pass
                extra_rows = []
                for i in range(0, len(missing_names), 900):
                    names_chunk = missing_names[i:i+900]
                    rows2 = (
                        db.session.query(Vendor.id, Vendor.name)
                        .filter(func.lower(Vendor.name).in_(names_chunk))
                        .order_by(Vendor.name.asc())
                        .all()
                    )
                    extra_rows.extend(rows2)
                base_vendors.extend(extra_rows)
            try:
                base_vendors.sort(key=lambda x: (x[1] or '').lower())
            except Exception:
                pass
            name_to_row = { (nm or '').strip().lower(): (vid, nm) for vid, nm in base_vendors }
            merged_map = {}
            for vid, name, cnt in rows_info:
                key = (name or '').strip().lower()
                merged_map[key] = {'id': vid, 'name': name, 'cve_count': int(cnt or 0)}
            for nm_lower, cnt in vendor_counts_all.items():
                row = name_to_row.get(nm_lower)
                if row:
                    vid, nm = row
                    existing = merged_map.get(nm_lower)
                    if existing:
                        existing['cve_count'] = max(existing.get('cve_count', 0), int(cnt or 0))
                    else:
                        merged_map[nm_lower] = {'id': vid, 'name': nm, 'cve_count': int(cnt or 0)}
            vendor_dicts = list(merged_map.values())
            if q:
                q_lower = q.lower()
                vendor_dicts = [v for v in vendor_dicts if q_lower in (v.get('name') or '').lower()]
            total = len(vendor_dicts)
            class MockPagination:
                def __init__(self, items, page, per_page, total):
                    self.items = items
                    self.page = page
                    self.per_page = per_page
                    self.total = total
                    self.pages = (total + per_page - 1) // per_page
                    self.has_prev = page > 1
                    self.has_next = page < self.pages
                    self.prev_num = page - 1 if self.has_prev else None
                    self.next_num = page + 1 if self.has_next else None
                def iter_pages(self, left_edge=2, left_current=2, right_current=3, right_edge=2):
                    last = 0
                    for num in range(1, self.pages + 1):
                        if (
                            num <= left_edge
                            or (num >= self.page - left_current and num <= self.page + right_current)
                            or (num > self.pages - right_edge)
                        ):
                            if last + 1 != num:
                                yield None
                            yield num
                            last = num
            start = (page - 1) * per_page
            end = start + per_page
            items = vendor_dicts[start:end]
            pagination2 = MockPagination(vendor_dicts, page, per_page, total)
            all_vendor_ids = [int(v['id']) for v in vendor_dicts if v.get('id') is not None]
            return render_template(
                'vulnerabilities/vendor_selection.html',
                vendors=items,
                pagination=pagination2,
                current_category=category_tag or '',
                current_severity=current_severity,
                selected_vendor_ids=selected_vendor_ids,
                all_vendor_ids=all_vendor_ids
            )
        except Exception as e:
            current_app.logger.warning("Falha ao unir vendors normalizados e JSON.", exc_info=e)
            return render_template(
                'vulnerabilities/vendor_selection.html',
                vendors=[{'id': vid, 'name': name, 'cve_count': cnt} for vid, name, cnt in rows_info],
                pagination=pagination,
                current_category=category_tag or '',
                current_severity=current_severity,
                selected_vendor_ids=selected_vendor_ids,
                all_vendor_ids=all_vendor_ids
            )
    except Exception as e:
        logger.error(f"Erro ao carregar seleção de vendors: {e}", exc_info=True)
        flash('Erro ao carregar lista de fornecedores.', 'danger')
        return render_template(
            'vulnerabilities/vendor_selection.html',
            vendors=[],
            pagination=None,
            current_category=category_tag or '',
            current_severity=current_severity,
            selected_vendor_ids=[]
        )

@vuln_ui_bp.route('/products', methods=['GET'])
@login_required
def product_selection_ui():
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        q = (request.args.get('q', '') or '').strip()
        raw_vendor_ids_list = request.args.getlist('vendor_ids')
        raw_vendor_ids_param = request.args.get('vendor_ids')
        raw_vendor_names_list = request.args.getlist('vendor_names')
        raw_vendor_names_param = request.args.get('vendor_names')
        selected_vendor_ids = []
        selected_vendor_names = []
        if raw_vendor_ids_list:
            for item in raw_vendor_ids_list:
                for p in str(item).split(','):
                    try:
                        n = int(p.strip())
                        selected_vendor_ids.append(n)
                    except Exception:
                        continue
        elif raw_vendor_ids_param:
            for p in raw_vendor_ids_param.split(','):
                try:
                    n = int(p.strip())
                    selected_vendor_ids.append(n)
                except Exception:
                    continue
        if raw_vendor_names_list:
            for item in raw_vendor_names_list:
                for p in str(item).split(','):
                    p2 = (p or '').strip().lower()
                    if p2:
                        selected_vendor_names.append(p2)
        elif raw_vendor_names_param:
            for p in raw_vendor_names_param.split(','):
                p2 = (p or '').strip().lower()
                if p2:
                    selected_vendor_names.append(p2)
        selected_vendor_ids = sorted(set(selected_vendor_ids))
        selected_vendor_names = sorted(set(selected_vendor_names))
        if not selected_vendor_ids and is_user_authenticated():
            try:
                key = f'user_vendor_preferences:{current_user.id}'
                pref = db.session.query(SyncMetadata).filter_by(key=key).first()
                if pref and pref.value:
                    selected_vendor_ids = [int(v.strip()) for v in pref.value.split(',') if v.strip().isdigit()]
            except Exception:
                selected_vendor_ids = []
        # Montar lista de produtos a partir de dados brutos NVD
        try:
            from app.models.vulnerability import Vulnerability
            from sqlalchemy import text, or_, func
            # Construir consulta base
            qv = db.session.query(
                Vulnerability.cve_id,
                Vulnerability.nvd_vendors_data,
                Vulnerability.nvd_products_data
            )
            # Aplicar filtro por vendor names direto em JSON quando fornecido
            if selected_vendor_names:
                name_clauses = []
                params = {}
                for i, nm in enumerate(selected_vendor_names):
                    k = f'vn_like_{i}'
                    params[k] = f"%{(nm or '').lower()}%"
                    name_clauses.append(text(f"LOWER(CAST(nvd_vendors_data AS TEXT)) LIKE :{k}").bindparams(**{k: params[k]}))
                if name_clauses:
                    # Usar filtro OR composto
                    qv = qv.filter(or_(*name_clauses))
            # Quando há apenas vendor_ids, mapear para nomes para filtrar por JSON
            elif selected_vendor_ids:
                try:
                    from app.models.vendor import Vendor
                    rows = db.session.query(Vendor.name).filter(Vendor.id.in_(selected_vendor_ids)).all()
                    vnames = [str(r[0]).strip().lower() for r in rows if r and r[0]]
                except Exception:
                    vnames = []
                if vnames:
                    name_clauses = []
                    params = {}
                    for i, nm in enumerate(vnames):
                        k = f'vnid_like_{i}'
                        params[k] = f"%{(nm or '').lower()}%"
                        name_clauses.append(text(f"LOWER(CAST(nvd_vendors_data AS TEXT)) LIKE :{k}").bindparams(**{k: params[k]}))
                    qv = qv.filter(or_(*name_clauses))

            rows = qv.all()
            from collections import defaultdict
            import json
            product_counts = defaultdict(int)
            original_names = {}
            for _cve, vendors_json, products_json in rows:
                # Parse vendors (para eventual filtragem na memória se necessário)
                try:
                    vlist = json.loads(vendors_json) if isinstance(vendors_json, str) else (vendors_json or [])
                except Exception:
                    vlist = []
                try:
                    plist = json.loads(products_json) if isinstance(products_json, str) else (products_json or [])
                except Exception:
                    plist = []
                if selected_vendor_names:
                    # Garantir que pelo menos um vendor da seleção esteja presente neste CVE
                    try:
                        present = any(((vn or '').strip().lower() in selected_vendor_names) for vn in (vlist or []))
                    except Exception:
                        present = False
                    if not present:
                        continue
                for pn in plist or []:
                    if isinstance(pn, str) and pn.strip():
                        key = pn.strip().lower()
                        product_counts[key] += 1
                        if key not in original_names:
                            original_names[key] = pn.strip()
            # Aplicar busca
            items = []
            for key, cnt in product_counts.items():
                name = original_names.get(key, key)
                if q and q.lower() not in (name or '').lower():
                    continue
                items.append({'id': None, 'name': name, 'cve_count': int(cnt or 0)})
            # Ordenar por nome
            try:
                items.sort(key=lambda x: (x.get('name') or '').lower())
            except Exception:
                pass
            # Paginar manualmente
            total = len(items)
            start = (page - 1) * per_page
            end = start + per_page
            page_items = items[start:end]
            class MockPagination:
                def __init__(self, items, page, per_page, total):
                    self.items = items
                    self.page = page
                    self.per_page = per_page
                    self.total = total
                    self.pages = (total + per_page - 1) // per_page
                    self.has_prev = page > 1
                    self.has_next = page < self.pages
                    self.prev_num = page - 1 if self.has_prev else None
                    self.next_num = page + 1 if self.has_next else None
                def iter_pages(self, left_edge=2, left_current=2, right_current=3, right_edge=2):
                    last = 0
                    for num in range(1, self.pages + 1):
                        if (num <= left_edge or (num >= self.page - left_current and num <= self.page + right_current) or (num > self.pages - right_edge)):
                            if last + 1 != num:
                                yield None
                            yield num
                            last = num
            pagination = MockPagination(items, page, per_page, total)
            # Renderizar
            return render_template(
                'vulnerabilities/product_selection.html',
                products=page_items,
                pagination=pagination,
                selected_vendor_ids=selected_vendor_ids,
                selected_vendor_names=[n for n in selected_vendor_names]
            )
        except Exception:
            return render_template(
                'vulnerabilities/product_selection.html',
                products=[],
                pagination=None,
                selected_vendor_ids=selected_vendor_ids,
                selected_vendor_names=[n for n in selected_vendor_names]
            )
    except Exception as e:
        logger.error(f"Erro ao carregar seleção de produtos: {e}", exc_info=True)
        flash('Erro ao carregar lista de produtos.', 'danger')
        return render_template(
            'vulnerabilities/product_selection.html',
            products=[],
            pagination=None,
            selected_vendor_ids=[],
            selected_vendor_names=[]
        )

@vuln_ui_bp.route('/create', methods=['GET', 'POST'])
@login_required
def create_vulnerability_ui():
    """Formulário de criação de vulnerabilidade."""
    form = VulnerabilityForm()
    if form.validate_on_submit():
        try:
            vuln = Vulnerability(**form.data)
            db.session.add(vuln)
            db.session.commit()
            flash('Vulnerabilidade criada com sucesso.', 'success')
            return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))
        except SQLAlchemyError as e:
            db.session.rollback()
            logger.error("Erro criando vulnerabilidade: %s", e, exc_info=True)
            flash('Erro ao salvar vulnerabilidade.', 'danger')

    return render_template(
        'vulnerabilities/vulnerability_form.html',
        form=form, action='create'
    )

@vuln_ui_bp.route('/<string:cve_id>/edit', methods=['GET', 'POST'])
@login_required
def edit_vulnerability_ui(cve_id: str):
    """Formulário de edição de vulnerabilidade."""
    if not CVE_PATTERN.match(cve_id):
        abort(400, description="Formato de CVE inválido.")
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    form = VulnerabilityForm(obj=vuln)

    if form.validate_on_submit():
        try:
            for field, value in form.data.items():
                setattr(vuln, field, value)
            db.session.commit()
            flash('Vulnerabilidade atualizada com sucesso.', 'success')
            return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))
        except SQLAlchemyError as e:
            db.session.rollback()
            logger.error("Erro atualizando vulnerabilidade: %s", e, exc_info=True)
            flash('Erro ao atualizar.', 'danger')

    return render_template(
        'vulnerabilities/vulnerability_form.html',
        form=form, action='edit', cve_id=cve_id
    )

@vuln_ui_bp.route('/<string:cve_id>/delete', methods=['POST'])
@login_required
def delete_vulnerability_ui(cve_id: str):
    """Exclui vulnerabilidade após validação CSRF."""
    form = DeleteForm()
    if not form.validate_on_submit():
        abort(400, description="CSRF token inválido.")
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    try:
        db.session.delete(vuln)
        db.session.commit()
        flash('Vulnerabilidade removida.', 'success')
    except SQLAlchemyError as e:
        db.session.rollback()
        logger.error("Erro deletando vulnerabilidade: %s", e, exc_info=True)
        flash('Erro ao remover.', 'danger')
    return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))

@vuln_ui_bp.route('/<string:cve_id>/mitigate', methods=['POST'])
@login_required
def mitigate_vulnerability_ui(cve_id: str):
    """Marca vulnerabilidade como mitigada após validação CSRF."""
    form = DeleteForm()
    if not form.validate_on_submit():
        abort(400, description="CSRF token inválido.")
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    try:
        vuln.patch_available = True
        db.session.commit()
        flash(f"Vulnerabilidade {cve_id} mitigada.", 'success')
    except SQLAlchemyError as e:
        db.session.rollback()
        logger.error("Erro mitigando vulnerabilidade: %s", e, exc_info=True)
        flash('Erro ao mitigar.', 'danger')
    return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))

@vuln_ui_bp.route('/<string:cve_id>', methods=['GET'], strict_slashes=False)
@login_required
def vulnerability_details(cve_id: str):
    """Exibe detalhes de uma vulnerabilidade específica, com fallback visual para produtos/versões."""
    try:
        # Buscar vulnerabilidade com todos os dados relacionados
        vulnerability = vuln_service.get_vulnerability_with_details(cve_id.upper())
        
        if not vulnerability:
            flash(f'Vulnerabilidade {cve_id} não encontrada ou não autorizada.', 'warning')
            return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))
        
        # Buscar dados de analytics
        analytics = vuln_service.get_vulnerability_analytics(cve_id.upper())
        
        # Calcular fallback de produtos/versões quando dados estruturados estão ausentes
        fallback_versions = []
        try:
            has_structured = bool(getattr(vulnerability, 'version_references', None)) or bool(getattr(vulnerability, 'affected_products', None))
            if not has_structured:
                nvd_ranges = getattr(vulnerability, 'nvd_version_ranges', None) or []
                if isinstance(nvd_ranges, (list, tuple)):
                    for vr in nvd_ranges:
                        try:
                            vendor_name = (vr.get('vendor') or '').strip() if isinstance(vr, dict) else None
                            product_name = (vr.get('product') or '').strip() if isinstance(vr, dict) else None
                            affected_version = None
                            if isinstance(vr, dict):
                                if vr.get('version'):
                                    affected_version = vr['version']
                                else:
                                    # Construir a partir de limites quando possível
                                    if vr.get('version_start_including'):
                                        affected_version = f">= {vr['version_start_including']}"
                                    elif vr.get('version_start_excluding'):
                                        affected_version = f"> {vr['version_start_excluding']}"
                                    elif vr.get('version_end_including'):
                                        affected_version = f"<= {vr['version_end_including']}"
                                    elif vr.get('version_end_excluding'):
                                        affected_version = f"< {vr['version_end_excluding']}"
                            if product_name or vendor_name or affected_version:
                                fallback_versions.append({
                                    'vendor_name': vendor_name,
                                    'product_name': product_name,
                                    'affected_version': affected_version,
                                    'fixed_version': None
                                })
                        except Exception:
                            # Ignorar entradas inválidas individualmente
                            continue
        except Exception:
            # Em caso de falha no cálculo, manter fallback vazio
            fallback_versions = []
        
        return render_template(
            'vulnerabilities/details.html',
            vulnerability=vulnerability,
            analytics=analytics,
            fallback_versions=fallback_versions
        )
    except Exception as e:
        logger.error(f"Erro ao carregar vulnerabilidade {cve_id}: {str(e)}", exc_info=True)
        flash(f'Erro ao carregar vulnerabilidade: {str(e)}', 'danger')
        return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))


@vuln_ui_bp.route('/details/<string:severity>', methods=['GET'])
@login_required
def vulnerability_details_by_severity(severity: str):
    """Exibe página de detalhes das vulnerabilidades por severidade com dados da última semana."""
    try:
        # Normalizar severidade para suportar aliases pt-BR
        severity_slug = (severity or '').strip().lower()
        severity_aliases = {
            'critica': 'CRITICAL',
            'crítica': 'CRITICAL',
            'alta': 'HIGH',
            'media': 'MEDIUM',
            'média': 'MEDIUM',
            'baixa': 'LOW'
        }
        if severity_slug in severity_aliases:
            severity_upper = severity_aliases[severity_slug]
        else:
            # Converter severidade para maiúscula para validação (inglês)
            severity_upper = severity.upper()
        
        # Validar severidade
        if severity_upper not in severity_levels.enums:
            flash(f'Severidade inválida: {severity}', 'warning')
            return redirect(url_for('main.index'))
        
        # Log para debugging
        logger.info(f'Carregando detalhes para severidade: %s', severity_upper)
        
        # Extrair vendor_ids da query string (prioriza URL sobre preferências)
        raw_vendor_ids_list = request.args.getlist('vendor_ids')
        raw_vendor_ids_param = request.args.get('vendor_ids', '')
        # Flag: parâmetro vendor_ids foi fornecido explicitamente, mesmo que vazio
        vendor_filter_provided = ('vendor_ids' in request.args)
        selected_vendor_ids: list[int] = []
        if raw_vendor_ids_list:
            for item in raw_vendor_ids_list:
                parts = str(item).split(',')
                for p in parts:
                    try:
                        n = int(p.strip())
                        selected_vendor_ids.append(n)
                    except Exception:
                        continue
        elif raw_vendor_ids_param:
            for p in raw_vendor_ids_param.split(','):
                try:
                    n = int(p.strip())
                    selected_vendor_ids.append(n)
                except Exception:
                    continue
        # Deduplicar e ordenar
        selected_vendor_ids = sorted(set(selected_vendor_ids))
        # Fallback: usar preferências do usuário autenticado se NÃO houver vendor_ids explicitamente na URL
        if not selected_vendor_ids and not vendor_filter_provided:
            try:
                if current_user.is_authenticated:
                    key = f'user_vendor_preferences:{current_user.id}'
                    meta = db.session.query(SyncMetadata).filter_by(key=key).first()
                    if meta and meta.value:
                        selected_vendor_ids = [int(v.strip()) for v in meta.value.split(',') if v.strip().isdigit()]
            except Exception as e:
                current_app.logger.warning("Falha ao carregar preferências de vendors do usuário.", exc_info=e)

        # Resolver vendors selecionados (id/nome) para exibição consistente e fallback de filtro
        selected_vendor_names: list[str] = []
        selected_vendor_map: list[dict] = []
        try:
            if selected_vendor_ids:
                from app.models.vendor import Vendor
                rows = (
                    vuln_service.session.query(Vendor.id, Vendor.name)
                    .filter(Vendor.id.in_(selected_vendor_ids))
                    .all()
                )
                for row in rows:
                    try:
                        vid = int(getattr(row, 'id', row[0]))
                        vname = getattr(row, 'name', row[1])
                    except Exception:
                        vid, vname = row
                    if vname:
                        selected_vendor_names.append(vname)
                    selected_vendor_map.append({'id': vid, 'name': vname})
                logger.info(
                    'Vendors resolvidos: ids=%s, nomes=%s (total=%s)',
                    selected_vendor_ids, selected_vendor_names, len(selected_vendor_names)
                )
        except Exception as e:
            logger.warning(f'Falha ao resolver vendors selecionados (id/nome) previamente: {str(e)}')

        # Variáveis de escopo comum (evita UnboundLocalError em fallbacks)
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', current_app.config.get('ITEMS_PER_PAGE', 20), type=int)
        week_ago = datetime.now() - timedelta(days=7)

        # Carregar dados em paralelo para melhor performance
        vulnerabilities_data = None
        weekly_stats = None
        general_counts = None
        
        try:
            # Obter vulnerabilidades da última semana por severidade
            # Se o filtro por vendor foi explicitamente fornecido e está vazio, preparar estado vazio
            query = vuln_service.session.query(Vulnerability).filter(
                or_(
                    Vulnerability.published_date >= week_ago,
                    Vulnerability.last_update >= week_ago
                ),
                Vulnerability.base_severity == severity_upper
            )
            # Aplicar filtro de vendors quando houver seleção usando subconsulta unificada de CVEs por vendor/produto
            applied_vendor_filter = False
            if selected_vendor_ids:
                try:
                    from sqlalchemy import union
                    from app.models.cve_product import CVEProduct
                    from app.models.product import Product
                    from app.models.cve_vendor import CVEVendor
                    # CVEs associados diretamente a vendors selecionados (rotular coluna para união estável)
                    cves_por_vendor = (
                        vuln_service.session
                        .query(CVEVendor.cve_id.label('cve_id'))
                        .filter(CVEVendor.vendor_id.in_(selected_vendor_ids))
                    )
                    # CVEs associados a produtos cujo vendor pertence aos selecionados
                    cves_por_produto_vendor = (
                        vuln_service.session
                        .query(CVEProduct.cve_id.label('cve_id'))
                        .join(Product, Product.id == CVEProduct.product_id)
                        .filter(Product.vendor_id.in_(selected_vendor_ids))
                    )
                    # União com subquery nomeada para evitar conflitos de rótulo
                    cves_unificados_sq = union(cves_por_vendor, cves_por_produto_vendor).subquery('cves_unificados')
                    query = query.filter(
                        Vulnerability.cve_id.in_(vuln_service.session.query(cves_unificados_sq.c.cve_id))
                    ).distinct()
                    applied_vendor_filter = True
                    logger.info('Filtro por vendors aplicado via tabelas normalizadas | ids=%s', selected_vendor_ids)
                except Exception as e:
                    logger.warning(f"Falha ao aplicar filtro de vendors via tabelas normalizadas. Aplicando fallback por JSON. Detalhe: {e}")
            
            query = query.order_by(Vulnerability.published_date.desc())
            # Paginação manual para compatibilidade com SQLAlchemy Query puro
            try:
                # Quando vendor_ids foi explicitamente fornecido e está vazio, retornar zero itens
                if vendor_filter_provided and not selected_vendor_ids:
                    total_count = 0
                    items = []
                else:
                    total_count = query.count()
                    offset = (page - 1) * per_page
                    items = query.limit(per_page).offset(offset).all()
                # Fallback: se nenhuma CVE for encontrada via tabelas normalizadas, tentar filtrar por JSON de vendors
                if selected_vendor_ids and applied_vendor_filter and (total_count == 0) and selected_vendor_names:
                    try:
                        name_clauses = []
                        for vname in selected_vendor_names:
                            try:
                                vn = (vname or '').strip()
                                if not vn:
                                    continue
                                # Filtrar por presença do nome do vendor no JSON de vendors (case-insensitive)
                                name_clauses.append(Vulnerability.nvd_vendors_data.ilike(f"%{vn}%"))
                            except Exception:
                                continue
                        if name_clauses:
                            logger.info("Aplicando fallback de filtro por vendor via JSON (nvd_vendors_data)")
                            # Reconstruir a query base e aplicar o fallback
                            query = vuln_service.session.query(Vulnerability).filter(
                                or_(
                                    Vulnerability.published_date >= week_ago,
                                    Vulnerability.last_update >= week_ago
                                ),
                                Vulnerability.base_severity == severity_upper
                            ).filter(or_(*name_clauses)).order_by(Vulnerability.published_date.desc())
                            total_count = query.count()
                            offset = (page - 1) * per_page
                            items = query.limit(per_page).offset(offset).all()
                    except Exception as e:
                        logger.warning(f"Falha no fallback por JSON de vendors: {e}")
            except Exception as e:
                logger.error(f'Falha na paginação manual: {e}', exc_info=True)
                total_count = 0
                items = []

            class MockPagination:
                def __init__(self, items, page, per_page, total):
                    self.items = items
                    self.page = page
                    self.per_page = per_page
                    self.total = total
                    self.pages = (total + per_page - 1) // per_page if per_page > 0 else 0
                    self.has_prev = page > 1
                    self.has_next = page < self.pages
                    self.prev_num = page - 1 if self.has_prev else None
                    self.next_num = page + 1 if self.has_next else None

                def iter_pages(self, left_edge=2, left_current=2, right_current=3, right_edge=2):
                    last = 0
                    for num in range(1, (self.pages or 0) + 1):
                        if (
                            num <= left_edge
                            or (num >= self.page - left_current and num <= self.page + right_current)
                            or (num > self.pages - right_edge)
                        ):
                            if last + 1 != num:
                                yield None
                            yield num
                            last = num

            pagination = MockPagination(items, page, per_page, total_count)
            vulnerabilities_data = {
                'vulnerabilities': pagination.items,
                'total_count': pagination.total,
                'pagination': pagination
            }
            logger.debug(
                'Vulnerabilidades carregadas: %s itens (página %s/%s) | vendors_selecionados=%s',
                vulnerabilities_data["total_count"], pagination.page, pagination.pages, selected_vendor_ids
            )
        except Exception as e:
            logger.error(f'Erro ao carregar vulnerabilidades: {str(e)}')
            vulnerabilities_data = {'vulnerabilities': [], 'total_count': 0, 'pagination': None}

        # Calcular métricas derivadas para os cards (baseado em TODAS as vulnerabilidades filtradas, não apenas a página atual)
        try:
            # Recalcular com base em todas as vulnerabilidades da severidade e vendors selecionados
            if vendor_filter_provided and not selected_vendor_ids:
                all_vulns_query = vuln_service.session.query(Vulnerability).filter(False)
            else:
                all_vulns_query = vuln_service.session.query(Vulnerability).filter(
                    or_(
                        Vulnerability.published_date >= week_ago,
                        Vulnerability.last_update >= week_ago
                    ),
                    Vulnerability.base_severity == severity_upper
                )
            
            # Aplicar filtro de vendors se selecionados
            if selected_vendor_ids:
                try:
                    from sqlalchemy import union
                    from app.models.cve_vendor import CVEVendor
                    from app.models.cve_product import CVEProduct
                    from app.models.product import Product
                    
                    cves_por_vendor = (
                        vuln_service.session
                        .query(CVEVendor.cve_id.label('cve_id'))
                        .filter(CVEVendor.vendor_id.in_(selected_vendor_ids))
                    )
                    cves_por_produto_vendor = (
                        vuln_service.session
                        .query(CVEProduct.cve_id.label('cve_id'))
                        .join(Product, Product.id == CVEProduct.product_id)
                        .filter(Product.vendor_id.in_(selected_vendor_ids))
                    )
                    cves_unificados_sq = union(cves_por_vendor, cves_por_produto_vendor).subquery('cves_unificados')
                    all_vulns_query = all_vulns_query.filter(
                        Vulnerability.cve_id.in_(vuln_service.session.query(cves_unificados_sq.c.cve_id))
                    ).distinct()
                    # Fallback via JSON quando não houver correspondência nas tabelas normalizadas
                    try:
                        cnt = all_vulns_query.count()
                        if (cnt == 0) and selected_vendor_names:
                            name_clauses = []
                            for vname in selected_vendor_names:
                                vn = (vname or '').strip()
                                if not vn:
                                    continue
                                name_clauses.append(Vulnerability.nvd_vendors_data.ilike(f"%{vn}%"))
                            if name_clauses:
                                logger.info("Aplicando fallback de métricas por vendor via JSON (nvd_vendors_data)")
                                all_vulns_query = vuln_service.session.query(Vulnerability).filter(
                                    or_(
                                        Vulnerability.published_date >= week_ago,
                                        Vulnerability.last_update >= week_ago
                                    ),
                                    Vulnerability.base_severity == severity_upper
                                ).filter(or_(*name_clauses)).distinct()
                    except Exception as e:
                        logger.warning(f"Falha ao calcular contagem para fallback de métricas: {e}")
                except Exception as e:
                    logger.warning(f"Falha ao aplicar filtro normalizado em métricas; aplicando fallback por JSON. Detalhe: {e}")
                    try:
                        name_clauses = []
                        for vname in selected_vendor_names:
                            vn = (vname or '').strip()
                            if not vn:
                                continue
                            name_clauses.append(Vulnerability.nvd_vendors_data.ilike(f"%{vn}%"))
                        if name_clauses:
                            all_vulns_query = vuln_service.session.query(Vulnerability).filter(
                                or_(
                                    Vulnerability.published_date >= week_ago,
                                    Vulnerability.last_update >= week_ago
                                ),
                                Vulnerability.base_severity == severity_upper
                            ).filter(or_(*name_clauses)).distinct()
                    except Exception as e2:
                        logger.error(f"Falha no fallback por JSON para métricas: {e2}")
            
            # Calcular CVSS médio
            if vendor_filter_provided and not selected_vendor_ids:
                avg_cvss_score = None
                patch_count = 0
            else:
                cvss_scores = [
                    float(v.cvss_score) for v in all_vulns_query.all() 
                    if getattr(v, 'cvss_score', None) is not None
                ]
                avg_cvss_score = round(sum(cvss_scores) / len(cvss_scores), 1) if cvss_scores else None
                
                # Calcular contagem de patches
                patch_count = all_vulns_query.filter(Vulnerability.patch_available == True).count()
            
        except Exception as e:
            logger.warning(f'Falha ao calcular métricas de cards: {str(e)}')
            avg_cvss_score = None
            patch_count = 0
        
        try:
            # Obter estatísticas para gráficos (vendor-scoped quando aplicável)
            if vendor_filter_provided and not selected_vendor_ids:
                weekly_stats = {
                    'daily_distribution': [],
                    'cvss_distribution': [],
                    'top_products': [],
                    'weekly_count': 0,
                    'monthly_count': 0,
                    'total_count': 0
                }
            else:
                weekly_stats = vuln_service.get_weekly_statistics_by_severity(severity_upper, selected_vendor_ids or None)
                logger.debug('Estatísticas semanais carregadas')
        except Exception as e:
            logger.error(f'Erro ao carregar estatísticas: {str(e)}')
            weekly_stats = {
                'daily_distribution': [],
                'cvss_distribution': [],
                'top_products': [],
                'weekly_count': 0,
                'monthly_count': 0,
                'total_count': 0
            }

        # Distribuição global de CVSS da semana (todas as severidades)
        try:
            if vendor_filter_provided and not selected_vendor_ids:
                weekly_cvss_all = {
                    '0.0-3.9': 0,
                    '4.0-6.9': 0,
                    '7.0-8.9': 0,
                    '9.0-10.0': 0
                }
            else:
                weekly_cvss_all = vuln_service.get_weekly_cvss_distribution_all(selected_vendor_ids or None)
                logger.debug('Distribuição semanal CVSS (global) carregada')
        except Exception as e:
            logger.error(f'Erro ao carregar distribuição semanal CVSS global: {str(e)}')
            weekly_cvss_all = {
                '0.0-3.9': 0,
                '4.0-6.9': 0,
                '7.0-8.9': 0,
                '9.0-10.0': 0
            }

        # Distribuição CVSS considerando TODAS as CVEs da severidade atual (sem filtro de data)
        try:
            if vendor_filter_provided and not selected_vendor_ids:
                cvss_all_severity = {
                    '0.0-3.9': 0,
                    '4.0-6.9': 0,
                    '7.0-8.9': 0,
                    '9.0-10.0': 0
                }
            else:
                cvss_all_severity = vuln_service.get_cvss_distribution_by_severity_all(severity_upper, selected_vendor_ids or None)
                logger.debug('Distribuição CVSS para todas as CVEs da severidade carregada')
        except Exception as e:
            logger.error(f'Erro ao carregar distribuição CVSS para todas as CVEs ({severity_upper}): {str(e)}')
            cvss_all_severity = {
                '0.0-3.9': 0,
                '4.0-6.9': 0,
                '7.0-8.9': 0,
                '9.0-10.0': 0
            }
        
        try:
            # Obter contadores gerais (escopados por vendors quando selecionados)
            if vendor_filter_provided and not selected_vendor_ids:
                general_counts = {
                    'critical': 0, 'high': 0, 'medium': 0, 'low': 0,
                    'total': 0, 'patched': 0, 'unpatched': 0
                }
            else:
                general_counts = vuln_service.get_dashboard_counts(selected_vendor_ids or None)
                logger.debug('Contadores gerais carregados (vendor-scoped)')
        except Exception as e:
            logger.error(f'Erro ao carregar contadores: {str(e)}')
            general_counts = {
                'critical': 0, 'high': 0, 'medium': 0, 'low': 0,
                'total': 0, 'patched': 0, 'unpatched': 0
            }

        # selected_vendor_names e selected_vendor_map já resolvidos acima para uso em fallback e UI

        return render_template(
            'vulnerabilities/details_page.html',
            severity=severity_upper,
            vulnerabilities=vulnerabilities_data['vulnerabilities'],
            total_count=vulnerabilities_data['total_count'],
            pagination=vulnerabilities_data.get('pagination'),
            weekly_stats=weekly_stats,
            weekly_cvss_all=weekly_cvss_all,
            cvss_all_severity=cvss_all_severity,
            general_counts=general_counts,
            severity_display=severity.title(),
            avg_cvss_score=avg_cvss_score,
            patch_count=patch_count,
            selected_vendor_ids=selected_vendor_ids,
            selected_vendor_names=selected_vendor_names,
            selected_vendor_map=selected_vendor_map,
            page_error=None
        )
    except Exception as e:
        logger.error('Erro crítico ao carregar detalhes de vulnerabilidades %s: %s', severity if isinstance(severity, str) else 'UNKNOWN', str(e), exc_info=True)
        # Em caso de erro crítico, renderizar página com estados vazios e mensagem inline
        severity_upper = (severity.upper() if isinstance(severity, str) else 'UNKNOWN')
        severity_display = severity_upper.title()
        page_error_msg = 'Falha ao carregar dados desta seção. A página foi exibida com conteúdo parcial.'
        return render_template(
            'vulnerabilities/details_page.html',
            severity=severity_upper,
            severity_display=severity_display,
            vulnerabilities=[],
            total_count=0,
            pagination=None,
            weekly_stats={
                'daily_distribution': [],
                'cvss_distribution': [],
                'top_products': [],
                'weekly_count': 0,
                'monthly_count': 0,
                'total_count': 0
            },
            weekly_cvss_all={
                '0.0-3.9': 0,
                '4.0-6.9': 0,
                '7.0-8.9': 0,
                '9.0-10.0': 0
            },
            cvss_all_severity={
                '0.0-3.9': 0,
                '4.0-6.9': 0,
                '7.0-8.9': 0,
                '9.0-10.0': 0
            },
            general_counts={
                'critical': 0, 'high': 0, 'medium': 0, 'low': 0,
                'total': 0, 'patched': 0, 'unpatched': 0
            },
            avg_cvss_score=None,
            patch_count=0,
            selected_vendor_ids=[],
            selected_vendor_names=[],
            selected_vendor_map=[],
            page_error=page_error_msg
        )

@vuln_ui_bp.route('/details.html', methods=['GET'], strict_slashes=False)
@login_required
def vulnerability_details_alias_html():
    """Alias compatível para acessos diretos ao template .html.
    Aceita query params 'cve'/'cve_id' ou 'severity' e redireciona
    para as rotas corretas evitando 404.
    """
    cve_id = request.args.get('cve_id') or request.args.get('cve')
    if cve_id:
        return redirect(url_for('vulnerability_ui.vulnerability_details', cve_id=cve_id))
    severity = request.args.get('severity')
    if severity:
        severity_upper = severity.upper()
        if severity_upper in severity_levels.enums:
            return redirect(url_for('vulnerability_ui.vulnerability_details_by_severity', severity=severity_upper))
        flash(f'Severidade inválida: {severity}', 'warning')
    return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))


@vuln_ui_bp.route('/<string:cve_id>/risk-report', methods=['GET'])
@login_required
def generate_risk_report(cve_id: str):
    """Gera relatório de risco para uma vulnerabilidade específica."""
    try:
        # Buscar vulnerabilidade diretamente
        vulnerability = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
        
        if not vulnerability:
            flash(f'Vulnerabilidade {cve_id} não encontrada ou não autorizada.', 'warning')
            return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))
        
        # Gerar relatório de risco
        risk_analysis = risk_service.get_risk_analysis(cve_id.upper())
        is_prompt = False
        try:
            low = (risk_analysis or "").lower()
            if low.startswith("você é um analista sênior de risco cibernético"):
                is_prompt = True
        except Exception:
            is_prompt = False
        
        related_cves = []
        try:
            related_cves = vuln_service.get_related_cves_by_cwe(cve_id.upper(), limit=20)
        except Exception:
            related_cves = []
        from datetime import datetime
        return render_template(
            'risk_report.html',
            vulnerability=vulnerability,
            risk_analysis=risk_analysis,
            cve_id=cve_id.upper(),
            is_prompt=is_prompt,
            related_cves=related_cves,
            generated_at=datetime.now()
        )
        
    except Exception as e:
        logger.error(f'Erro ao gerar relatório de risco para {cve_id}: {str(e)}')
        flash(f'Erro ao gerar relatório de risco: {str(e)}', 'danger')
        return redirect(url_for('vulnerability_ui.vulnerability_details', cve_id=cve_id))


@vuln_ui_bp.route('/<string:cve_id>/risk-report/export/pdf', methods=['GET'])
@login_required
def export_risk_report_pdf(cve_id: str):
    """Exporta relatório de risco em PDF com fallback para HTML."""
    try:
        # Validar CVE ID
        if not CVE_PATTERN.match(cve_id):
            flash('CVE ID inválido.', 'warning')
            return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))

        vulnerability = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
        if not vulnerability:
            flash(f'Vulnerabilidade {cve_id} não encontrada ou não autorizada.', 'warning')
            return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))

        # Gerar conteúdo HTML do relatório
        risk_html = None
        try:
            risk_html = risk_service.generate_risk_report_html(cve_id.upper())
        except Exception as e:
            logger.warning(f'Falha ao gerar HTML do relatório de risco para {cve_id}: {e}')

        if not risk_html:
            # Fallback: usar markdown convertido no template
            risk_md = risk_service.get_risk_analysis(cve_id.upper()) or ''
            html_content = render_template(
                'reports/pdf/risk_report_pdf.html',
                vulnerability=vulnerability,
                cve_id=cve_id.upper(),
                risk_analysis_html=None,
                risk_analysis_md=risk_md,
                generated_at=datetime.now()
            )
        else:
            html_content = render_template(
                'reports/pdf/risk_report_pdf.html',
                vulnerability=vulnerability,
                cve_id=cve_id.upper(),
                risk_analysis_html=risk_html,
                risk_analysis_md=None,
                generated_at=datetime.now()
            )

        # Tentar WeasyPrint primeiro
        try:
            from weasyprint import HTML, CSS
            pdf_bytes = HTML(string=html_content, base_url=current_app.root_path).write_pdf()
            filename = f"relatorio_risco_{cve_id.upper()}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
            return send_file(
                io.BytesIO(pdf_bytes),
                as_attachment=True,
                download_name=filename,
                mimetype='application/pdf'
            )
        except Exception as e:
            logger.error(f'WeasyPrint falhou para {cve_id}: {e}')

        # Fallback: tentar pdfkit (wkhtmltopdf)
        try:
            import pdfkit
            wkhtml_path = (current_app.config.get('WKHTMLTOPDF_PATH') or '').strip() or None
            configuration = None
            if wkhtml_path:
                try:
                    configuration = pdfkit.configuration(wkhtmltopdf=wkhtml_path)
                except Exception as e:
                    logger.warning(f'WKHTMLTOPDF_PATH inválido: {wkhtml_path} ({e})')
                    configuration = None

            options = {
                'quiet': '',
                'enable-local-file-access': None,
                'print-media-type': None,
                'encoding': 'UTF-8',
                'page-size': 'A4',
                'margin-top': '10mm',
                'margin-right': '10mm',
                'margin-bottom': '12mm',
                'margin-left': '10mm'
            }
            pdf_bytes = pdfkit.from_string(html_content, False, options=options, configuration=configuration)
            filename = f"relatorio_risco_{cve_id.upper()}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
            return send_file(
                io.BytesIO(pdf_bytes),
                as_attachment=True,
                download_name=filename,
                mimetype='application/pdf'
            )
        except Exception as e:
            logger.error(f'pdfkit falhou para {cve_id}: {e}')

        # Fallback final: enviar HTML para download
        filename = f"relatorio_risco_{cve_id.upper()}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
        return send_file(
            io.BytesIO(html_content.encode('utf-8')),
            as_attachment=True,
            download_name=filename,
            mimetype='text/html'
        )

    except Exception as e:
        logger.error(f'Erro ao exportar PDF do relatório de risco {cve_id}: {str(e)}')
        flash('Erro ao exportar PDF do relatório de risco. Tente novamente.', 'danger')
        return redirect(url_for('vulnerability_ui.vulnerability_details', cve_id=cve_id))


@vuln_api_bp.route('/<string:cve_id>/risk-report', methods=['GET'])
def get_risk_report_api(cve_id: str):
    """API para obter relatório de risco de uma vulnerabilidade."""
    try:
        # Buscar vulnerabilidade diretamente
        vulnerability = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
        
        if not vulnerability:
            return jsonify({'error': 'Vulnerabilidade não encontrada ou não autorizada'}), 404
        
        # Gerar relatório de risco
        risk_analysis = risk_service.get_risk_analysis(cve_id.upper())
        risk_html = risk_service.generate_risk_report_html(cve_id.upper())

        # Metadados de geração
        is_prompt = False
        try:
            low = (risk_analysis or '').lower()
            is_prompt = low.startswith('você é um analista sênior de risco cibernético')
        except Exception:
            is_prompt = False
        # Provider e model
        try:
            # Inicializa client para popular provider/model se necessário
            risk_service._initialize_client()
            provider = getattr(risk_service, 'provider', None)
            model = getattr(risk_service, 'model', None)
            # Incluir cache metadata se disponível
            from sqlalchemy import text as _text
            row = db.session.execute(_text("SELECT risks FROM vulnerabilities WHERE cve_id = :cve"), {"cve": cve_id.upper()}).fetchone()
            cache_meta = None
            if row and row[0]:
                try:
                    import json as _json
                    obj = _json.loads(row[0])
                    if isinstance(obj, dict):
                        cache_meta = {k: obj.get(k) for k in ['generated_at','vuln_signature','provider','model']}
                except Exception:
                    cache_meta = None
        except Exception:
            provider, model, cache_meta = None, None, None
        # Prompt reconstruído (útil para frontend copiar)
        try:
            prompt_md = risk_service.build_markdown_prompt(vulnerability)
        except Exception:
            prompt_md = None
        
        try:
            related = vuln_service.get_related_cves_by_cwe(cve_id.upper(), limit=20)
            related_payload = [
                {
                    'cve_id': v.cve_id,
                    'base_severity': v.base_severity,
                    'cvss_score': v.cvss_score
                } for v in related
            ]
        except Exception:
            related_payload = []
        return jsonify({
            'cve_id': cve_id.upper(),
            'risk_analysis_markdown': risk_analysis,
            'risk_analysis_html': risk_html,
            'is_prompt': is_prompt,
            'provider': provider,
            'model': model,
            'prompt_markdown': prompt_md,
            'cache_meta': cache_meta,
            'generated_at': datetime.now().isoformat(),
            'related_cves': related_payload
        })
        
    except Exception as e:
        logger.error(f'Erro ao gerar relatório de risco via API para {cve_id}: {str(e)}')
        return jsonify({'error': f'Erro ao gerar relatório de risco: {str(e)}'}), 500

# ──────────────────────────────────────────────────────────────────────────────
# API Routes
# ──────────────────────────────────────────────────────────────────────────────

@vuln_api_bp.route('', methods=['GET'])
def list_vulnerabilities_api():
    """API: listagem paginada com filtros."""
    page     = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', current_app.config.get('ITEMS_PER_PAGE', 20), type=int)
    severity = request.args.get('severity')

    if severity and severity.upper() not in severity_levels.enums:
        raise BadRequest(f"Severidade inválida: {severity}")
    elif severity:
        severity = severity.upper()

    query      = vuln_service.session.query(Vulnerability)
    if severity:
        query = query.filter_by(base_severity=severity)
    pagination = paginate_query(query.order_by(Vulnerability.published_date.desc()),
                                page, per_page, error_out=False)

    return jsonify({
        'data': vuln_list_schema.dump(pagination.items),
        'meta': {
            'page':       pagination.page,
            'per_page':   pagination.per_page,
            'total':      pagination.total,
            'total_pages': pagination.pages
        }
    })

@vuln_api_bp.route('/<string:cve_id>', methods=['GET'])
def get_vulnerability_api(cve_id: str):
    """API: detalhes de uma vulnerabilidade."""
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    return jsonify(vuln_schema.dump(vuln))

@vuln_api_bp.route('/<string:cve_id>', methods=['PATCH'])
def update_vulnerability_api(cve_id: str):
    """API: atualização parcial via PATCH."""
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    data = request.get_json() or {}
    # Validação de campos permitidos
    allowed = {'description','published_date','last_modified','base_severity','cvss_score','patch_available','assigner'}
    invalid = set(data) - allowed
    if invalid:
        raise BadRequest(f"Campos inválidos: {invalid}")

    for k,v in data.items():
        setattr(vuln, k, v)
    db.session.commit()
    return jsonify(vuln_schema.dump(vuln))

@vuln_api_bp.route('/<string:cve_id>/mitigate', methods=['POST'])
def mitigate_vulnerability_api(cve_id: str):
    """API: marca como mitigada."""
    try:
        data = request.get_json()
        vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
        
        if not vuln:
            return jsonify({'success': False, 'message': 'Vulnerabilidade não encontrada'}), 404
        
        # Atualiza status de mitigação
        vuln.patch_available = True
        
        # TODO: Adicionar campos de mitigação ao modelo se necessário
        # vuln.mitigation_notes = data.get('notes')
        # vuln.mitigation_status = data.get('status')
        
        db.session.commit()
        
        return jsonify({
            'success': True, 
            'message': 'Vulnerabilidade mitigada com sucesso',
            'vulnerability': vuln_schema.dump(vuln)
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': str(e)}), 500

@vuln_api_bp.route('/<string:cve_id>', methods=['DELETE'])
def delete_vulnerability_api(cve_id: str):
    """API: exclusão de vulnerabilidade."""
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    db.session.delete(vuln)
    db.session.commit()
    return jsonify({'message': f'CVE {cve_id} excluída.'}), 204

@vuln_api_bp.route('/history', methods=['GET'])
def get_cve_history_data():
    """API: dados históricos de CVEs para o gráfico."""
    try:
        # Parâmetros de filtro
        period = request.args.get('period', '30')
        severity = request.args.get('severity', '')
        cvss_min = request.args.get('cvss_min', type=float)
        cvss_max = request.args.get('cvss_max', type=float)

        # Sanitizar intervalo CVSS
        if cvss_min is not None:
            cvss_min = max(0.0, min(10.0, cvss_min))
        if cvss_max is not None:
            cvss_max = max(0.0, min(10.0, cvss_max))
        if cvss_min is not None and cvss_max is not None and cvss_min > cvss_max:
            cvss_min, cvss_max = cvss_max, cvss_min
        
        # Validar período
        if period not in ['30', '90', '365']:
            period = '30'
        
        days = int(period)
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        
        # Severidades válidas
        valid_severities = ['N/A', 'NONE', 'LOW', 'MEDIUM', 'HIGH', 'CRITICAL']
        # Mapeia severidades não padronizadas para LOW para exibição no gráfico
        severity_map = {
            'CRITICAL': 'CRITICAL',
            'HIGH': 'HIGH',
            'MEDIUM': 'MEDIUM',
            'LOW': 'LOW',
            'NONE': 'LOW',
            'N/A': 'LOW'
        }
        
        # Query para dados diários agrupados por severidade
        from sqlalchemy import func
        
        daily_data = db.session.query(
            func.date(Vulnerability.published_date).label('date'),
            Vulnerability.base_severity,
            func.count(Vulnerability.cve_id).label('count')
        ).filter(
            Vulnerability.published_date >= start_date,
            Vulnerability.published_date <= end_date
        )

        # Aplicar filtro por vendors selecionados (querystring e/ou preferências do usuário)
        try:
            # Suporta vendor_ids como lista repetida e/ou CSV único na querystring
            raw_vendor_ids_list = request.args.getlist('vendor_ids') or []
            raw_vendor_ids_param = request.args.get('vendor_ids')
            selected_vendor_ids: list[int] = []
            # Extrair IDs de vendor das duas formas
            if raw_vendor_ids_list:
                for item in raw_vendor_ids_list:
                    parts = str(item).split(',')
                    for p in parts:
                        try:
                            n = int(p.strip())
                            selected_vendor_ids.append(n)
                        except Exception:
                            continue
            elif raw_vendor_ids_param:
                for p in raw_vendor_ids_param.split(','):
                    try:
                        n = int(p.strip())
                        selected_vendor_ids.append(n)
                    except Exception:
                        continue

            # Fallback: preferências persistidas do usuário autenticado
            if not selected_vendor_ids and is_user_authenticated():
                key = f'user_vendor_preferences:{current_user.id}'
                pref = db.session.query(SyncMetadata).filter_by(key=key).first()
                if pref and pref.value:
                    selected_vendor_ids = [int(x) for x in pref.value.split(',') if x.strip().isdigit()]

            # Aplicar filtro via união dos CVEs associados diretamente ao vendor e via produtos do vendor
            if selected_vendor_ids:
                try:
                    from sqlalchemy import union
                    from app.models.cve_vendor import CVEVendor
                    from app.models.cve_product import CVEProduct
                    from app.models.product import Product

                    cves_por_vendor = (
                        db.session
                        .query(CVEVendor.cve_id.label('cve_id'))
                        .filter(CVEVendor.vendor_id.in_(selected_vendor_ids))
                    )
                    cves_por_produto_vendor = (
                        db.session
                        .query(CVEProduct.cve_id.label('cve_id'))
                        .join(Product, Product.id == CVEProduct.product_id)
                        .filter(Product.vendor_id.in_(selected_vendor_ids))
                    )
                    cves_unificados_sq = union(cves_por_vendor, cves_por_produto_vendor).subquery('cves_unificados')

                    daily_data = (
                        daily_data
                        .filter(
                            Vulnerability.cve_id.in_(
                                db.session.query(cves_unificados_sq.c.cve_id)
                            )
                        )
                        .distinct()
                    )
                except Exception:
                    # Em caso de erro silencioso, não bloquear o gráfico
                    pass
        except Exception:
            # Não bloquear o gráfico se houver erro ao aplicar filtros de vendor
            pass

        # Aplicar filtros
        if severity and severity.upper() in valid_severities:
            daily_data = daily_data.filter(Vulnerability.base_severity == severity.upper())
        
        if cvss_min is not None:
            daily_data = daily_data.filter(Vulnerability.cvss_score >= cvss_min)
        
        if cvss_max is not None:
            daily_data = daily_data.filter(Vulnerability.cvss_score <= cvss_max)
        
        daily_data = daily_data.group_by(
            func.date(Vulnerability.published_date),
            Vulnerability.base_severity
        ).order_by(func.date(Vulnerability.published_date)).all()
        
        # Organizar dados por data
        chart_data = {}
        severity_totals = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
        
        for row in daily_data:
            if row.date:
                # Verificar se row.date é string ou datetime
                if isinstance(row.date, str):
                    date_str = row.date
                else:
                    date_str = row.date.strftime('%Y-%m-%d')
                
                # Normaliza severidade para chaves do gráfico
                raw_level = row.base_severity or 'LOW'
                severity_level = severity_map.get(raw_level, 'LOW')
                count = row.count
                
                if date_str not in chart_data:
                    chart_data[date_str] = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
                
                if severity_level in chart_data[date_str]:
                    chart_data[date_str][severity_level] = count
                    if severity_level in severity_totals:
                        severity_totals[severity_level] += count
        
        # Preencher datas faltantes com zeros
        current_date = start_date.date()
        while current_date <= end_date.date():
            date_str = current_date.strftime('%Y-%m-%d')
            if date_str not in chart_data:
                chart_data[date_str] = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
            current_date += timedelta(days=1)
        
        # Converter para formato do Chart.js
        sorted_dates = sorted(chart_data.keys())
        
        response_data = {
            'labels': sorted_dates,
            'datasets': [
                {
                    'label': 'Critical',
                    'data': [chart_data[date]['CRITICAL'] for date in sorted_dates],
                    'backgroundColor': 'rgba(220, 53, 69, 0.8)',
                    'borderColor': 'rgba(220, 53, 69, 1)',
                    'borderWidth': 2
                },
                {
                    'label': 'High',
                    'data': [chart_data[date]['HIGH'] for date in sorted_dates],
                    'backgroundColor': 'rgba(255, 193, 7, 0.8)',
                    'borderColor': 'rgba(255, 193, 7, 1)',
                    'borderWidth': 2
                },
                {
                    'label': 'Medium',
                    'data': [chart_data[date]['MEDIUM'] for date in sorted_dates],
                    'backgroundColor': 'rgba(255, 165, 0, 0.8)',
                    'borderColor': 'rgba(255, 165, 0, 1)',
                    'borderWidth': 2
                },
                {
                    'label': 'Low',
                    'data': [chart_data[date]['LOW'] for date in sorted_dates],
                    'backgroundColor': 'rgba(40, 167, 69, 0.8)',
                    'borderColor': 'rgba(40, 167, 69, 1)',
                    'borderWidth': 2
                }
            ],
            'statistics': {
                'total': sum(severity_totals.values()),
                'critical': severity_totals['CRITICAL'],
                'high': severity_totals['HIGH'],
                'medium': severity_totals['MEDIUM'],
                'low': severity_totals['LOW']
            }
        }
        
        return jsonify(response_data)
        
    except Exception as e:
        logger.error(f"Erro ao buscar dados históricos de CVE: {e}")
        return jsonify({'error': f'Erro interno do servidor: {str(e)}'}), 500

@vuln_api_bp.route('/by-asset/<int:asset_id>', methods=['GET'])
def api_vulns_by_asset(asset_id: int):
    """Lista vulnerabilidades correlacionadas ao ativo informado.

    A correlação utiliza os produtos vinculados ao ativo, regex de versões afetadas
    e filtros por modelo/sistema operacional presentes na descrição.
    """
    try:
        from app.services.vulnerability_service import VulnerabilityService
        vs = VulnerabilityService(db.session)
        vulns = vs.get_vulnerabilities_by_asset(asset_id)
        items = []
        for v in vulns:
            items.append({
                'cve_id': v.cve_id,
                'description': v.description,
                'base_severity': v.base_severity,
                'cvss_score': v.cvss_score,
                'published_date': v.published_date.isoformat() if v.published_date else None,
            })
        return jsonify({'count': len(items), 'items': items})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@vuln_api_legacy_bp.route('/export', methods=['GET'])
def export_vulnerabilities_csv():
    """Exporta vulnerabilidades em CSV.

    Parâmetros:
    - severity: nível de severidade (critical, high, medium, low, all)
    - period: período (week, month, all)
    """
    try:
        import csv
        from io import StringIO

        severity_param = (request.args.get('severity', 'all') or 'all').upper()
        period_param = (request.args.get('period', 'week') or 'week').lower()

        # Validar severidade
        valid_severities = {'CRITICAL', 'HIGH', 'MEDIUM', 'LOW'}
        severity_filter = severity_param if severity_param in valid_severities else None

        # Calcular janela de tempo
        end_date = datetime.now()
        if period_param == 'week':
            start_date = end_date - timedelta(days=7)
        elif period_param == 'month':
            start_date = end_date - timedelta(days=30)
        else:
            start_date = None  # sem filtro

        # Query base
        query = vuln_service.session.query(Vulnerability)
        if severity_filter:
            query = query.filter(Vulnerability.base_severity == severity_filter)
        if start_date:
            query = query.filter(Vulnerability.published_date >= start_date)

        # Aplicar filtro de vendors selecionados (querystring e preferências)
        try:
            # Suporta vendor_ids como lista repetida e/ou CSV único
            raw_vendor_ids_list = request.args.getlist('vendor_ids') or []
            raw_vendor_ids_param = request.args.get('vendor_ids')
            selected_vendor_ids: list[int] = []
            # Extrair IDs de vendor de ambas as formas
            if raw_vendor_ids_list:
                for item in raw_vendor_ids_list:
                    parts = str(item).split(',')
                    for p in parts:
                        try:
                            n = int(p.strip())
                            selected_vendor_ids.append(n)
                        except Exception:
                            continue
            elif raw_vendor_ids_param:
                for p in raw_vendor_ids_param.split(','):
                    try:
                        n = int(p.strip())
                        selected_vendor_ids.append(n)
                    except Exception:
                        continue
            # Fallback: preferências do usuário autenticado
            from flask_login import current_user
            from app.models.sync_metadata import SyncMetadata
            if not selected_vendor_ids and current_user.is_authenticated:
                try:
                    key = f'user_vendor_preferences:{current_user.id}'
                    pref = db.session.query(SyncMetadata).filter_by(key=key).first()
                    if pref and pref.value:
                        selected_vendor_ids = [int(v.strip()) for v in pref.value.split(',') if v.strip().isdigit()]
                except Exception:
                    selected_vendor_ids = []
            # Aplicar filtro via união de CVEs por vendor e por produto de vendor
            if selected_vendor_ids:
                try:
                    from sqlalchemy import union
                    from app.models.cve_vendor import CVEVendor
                    from app.models.cve_product import CVEProduct
                    from app.models.product import Product
                    cves_por_vendor = (
                        vuln_service.session
                        .query(CVEVendor.cve_id.label('cve_id'))
                        .filter(CVEVendor.vendor_id.in_(selected_vendor_ids))
                    )
                    cves_por_produto_vendor = (
                        vuln_service.session
                        .query(CVEProduct.cve_id.label('cve_id'))
                        .join(Product, Product.id == CVEProduct.product_id)
                        .filter(Product.vendor_id.in_(selected_vendor_ids))
                    )
                    cves_unificados_sq = union(cves_por_vendor, cves_por_produto_vendor).subquery('cves_unificados')
                    query = query.filter(
                        Vulnerability.cve_id.in_(vuln_service.session.query(cves_unificados_sq.c.cve_id))
                    ).distinct()
                except Exception:
                    # Em caso de falha silenciosa, segue sem filtro para não quebrar export
                    pass
        except Exception:
            # Não interromper exportação por erro de parsing
            pass
        query = query.order_by(Vulnerability.published_date.desc())

        vulns = query.all()

        # Preparar CSV
        csv_buffer = StringIO()
        writer = csv.writer(csv_buffer)
        writer.writerow([
            'CVE ID', 'Severidade', 'CVSS', 'Publicado em', 'Vendor', 'Produto', 'Patch Disponível', 'Assigner'
        ])

        def normalize_first(items, key_name='name'):
            if not items:
                return ''
            first = items[0]
            if isinstance(first, str):
                return first
            if isinstance(first, dict):
                return str(first.get(key_name, ''))
            # Tentativa de atributo .name
            return str(getattr(first, key_name, '') or '')

        for v in vulns:
            vendor = ''
            product = ''
            try:
                vendor = normalize_first(getattr(v, 'nvd_vendors_data', None))
            except Exception:
                vendor = ''
            try:
                product = normalize_first(getattr(v, 'nvd_products_data', None))
            except Exception:
                product = ''

            writer.writerow([
                v.cve_id,
                v.base_severity or '',
                v.cvss_score if v.cvss_score is not None else '',
                v.published_date.strftime('%Y-%m-%d') if v.published_date else '',
                vendor,
                product,
                'Sim' if getattr(v, 'patch_available', False) else 'Não',
                getattr(v, 'assigner', '') or ''
            ])

        csv_data = csv_buffer.getvalue()
        csv_buffer.close()

        filename = f"vulnerabilities_{(severity_filter or 'ALL').lower()}_{datetime.now().strftime('%Y-%m-%d')}" \
                   + (f"_{period_param}" if period_param in ['week','month'] else '') + ".csv"

        return Response(
            csv_data,
            mimetype='text/csv; charset=utf-8',
            headers={
                'Content-Disposition': f'attachment; filename="{filename}"'
            }
        )
    except Exception as e:
        logger.error(f"Erro ao exportar CSV de vulnerabilidades: {e}", exc_info=True)
        return jsonify({'error': 'Falha ao exportar CSV'}), 500

# Rota de teste temporária
@vuln_ui_bp.route('/debug-test')
@login_required
def test_vulnerabilities():
    """Rota de teste para verificar se as vulnerabilidades estão sendo passadas corretamente."""
    try:
        # Usar a mesma lógica do list_vulnerabilities_ui
        page = 1
        per_page = 20
        severity = None
        
        sql_query = """
        SELECT cve_id, description, base_severity, cvss_score, published_date, nvd_vendors_data 
        FROM vulnerabilities 
        """
        
        params = {}
        if severity and severity != 'all':
            sql_query += " WHERE base_severity = :severity"
            params['severity'] = severity.upper()
        
        sql_query += " ORDER BY published_date DESC LIMIT :limit OFFSET :offset"
        params['limit'] = per_page
        params['offset'] = (page - 1) * per_page
        
        result = db.session.execute(text(sql_query), params)
        vulnerabilities = result.fetchall()
        
        return render_template(
            'vulnerabilities/debug/test_vulnerabilities.html',
            vulnerabilities=vulnerabilities
        )
        
    except Exception as e:
        logger.error(f"Erro no teste de vulnerabilidades: {e}")
        return f"Erro: {e}"

@vuln_ui_bp.route('/debug-simple', strict_slashes=False)
@login_required
def debug_simple():
    """Rota de debug simples"""
    # Usar exatamente a mesma lógica do list_vulnerabilities_ui
    page = 1
    per_page = 20
    severity = None
    
    # Query SQL idêntica
    from sqlalchemy import text
    
    sql_query = """
    SELECT cve_id, description, published_date, base_severity, cvss_score, 
           patch_available, assigner, source_identifier, vuln_status,
           nvd_vendors_data, nvd_products_data
    FROM vulnerabilities 
    ORDER BY published_date DESC LIMIT :limit OFFSET :offset
    """
    
    params = {
        'limit': per_page,
        'offset': (page - 1) * per_page
    }
    
    result = db.session.execute(text(sql_query), params)
    vulnerabilities = result.fetchall()
    
    # Contar total para paginação
    count_sql = "SELECT COUNT(*) FROM vulnerabilities"
    count_result = db.session.execute(text(count_sql))
    total = count_result.scalar()
    
    # Criar MockPagination igual ao original
    class MockPagination:
        def __init__(self, items, page, per_page, total):
            self.items = items
            self.page = page
            self.per_page = per_page
            self.total = total
            self.pages = (total + per_page - 1) // per_page
            self.has_prev = page > 1
            self.has_next = page < self.pages
            self.prev_num = page - 1 if self.has_prev else None
            self.next_num = page + 1 if self.has_next else None

        def iter_pages(self, left_edge=2, left_current=2, right_current=3, right_edge=2):
            last = 0
            for num in range(1, self.pages + 1):
                if (
                    num <= left_edge
                    or (num >= self.page - left_current and num <= self.page + right_current)
                    or (num > self.pages - right_edge)
                ):
                    if last + 1 != num:
                        yield None
                    yield num
                    last = num
    
    pagination = MockPagination(vulnerabilities, page, per_page, total)
    
    return render_template(
        'vulnerabilities/debug/debug_simple.html',
        vulnerabilities=pagination.items,
        vulns=pagination.items,
        pagination=pagination
    )

# Error handlers poderiam ser registrados no app global, herdar de main.
