# controllers/vulnerability_controller.py

import re
import logging
from typing import Any, Dict
from flask import (
    Blueprint, request, flash, redirect, url_for,
    current_app, jsonify, abort
)
from flask_login import login_required
from sqlalchemy.exc import SQLAlchemyError
from werkzeug.exceptions import BadRequest, NotFound

from ..extensions.db import db
from ..models.vulnerability import Vulnerability
from ..models.enums import severity_levels
from ..services.vulnerability_service import VulnerabilityService
from ..schemas.vulnerability_schema import VulnerabilitySchema
from ..forms.vulnerability_form import VulnerabilityForm
from ..forms.common_form import DeleteForm
from ..utils.pagination import paginate_query

logger = logging.getLogger(__name__)

# Blueprints
vuln_ui_bp = Blueprint('vulnerability_ui', __name__, url_prefix='/vulnerabilities')
vuln_api_bp = Blueprint('vulnerability_api', __name__, url_prefix='/api/v1/vulnerabilities')

# Service and schemas
vuln_service     = VulnerabilityService(db.session)
vuln_schema      = VulnerabilitySchema()
vuln_list_schema = VulnerabilitySchema(many=True)

# Regex para validar CVE ID
CVE_PATTERN = re.compile(r'^CVE-\d{4}-\d+$', re.IGNORECASE)

# ──────────────────────────────────────────────────────────────────────────────
# UI Routes
# ──────────────────────────────────────────────────────────────────────────────

@vuln_ui_bp.route('/', methods=['GET'])
@login_required
def list_vulnerabilities_ui():
    """Lista vulnerabilidades com filtro de severidade e paginação."""
    page     = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', current_app.config.get('ITEMS_PER_PAGE', 20), type=int)
    severity = request.args.get('severity')

    if severity and severity not in severity_levels:
        flash(f"Severidade inválida: {severity}", 'warning')
        severity = None

    # Monta query e aplica paginação
    query      = vuln_service.session.query(Vulnerability)
    query      = vuln_service.apply_filters(query, severity)
    pagination = paginate_query(query.order_by(Vulnerability.published_date.desc()),
                                page, per_page, error_out=False)

    return render_template(
        'vulnerabilities/vulnerabilities.html',
        vulnerabilities=pagination.items,
        pagination=pagination,
        filters={'severity': severity}
    )

@vuln_ui_bp.route('/create', methods=['GET', 'POST'])
@login_required
def create_vulnerability_ui():
    """Formulário de criação de vulnerabilidade."""
    form = VulnerabilityForm()
    if form.validate_on_submit():
        try:
            vuln = Vulnerability(**form.data)
            db.session.add(vuln)
            db.session.commit()
            flash('Vulnerabilidade criada com sucesso.', 'success')
            return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))
        except SQLAlchemyError as e:
            db.session.rollback()
            logger.error("Erro criando vulnerabilidade: %s", e, exc_info=True)
            flash('Erro ao salvar vulnerabilidade.', 'danger')

    return render_template(
        'vulnerabilities/vulnerability_form.html',
        form=form, action='create'
    )

@vuln_ui_bp.route('/<string:cve_id>/edit', methods=['GET', 'POST'])
@login_required
def edit_vulnerability_ui(cve_id: str):
    """Formulário de edição de vulnerabilidade."""
    if not CVE_PATTERN.match(cve_id):
        abort(400, description="Formato de CVE inválido.")
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    form = VulnerabilityForm(obj=vuln)

    if form.validate_on_submit():
        try:
            for field, value in form.data.items():
                setattr(vuln, field, value)
            db.session.commit()
            flash('Vulnerabilidade atualizada com sucesso.', 'success')
            return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))
        except SQLAlchemyError as e:
            db.session.rollback()
            logger.error("Erro atualizando vulnerabilidade: %s", e, exc_info=True)
            flash('Erro ao atualizar.', 'danger')

    return render_template(
        'vulnerabilities/vulnerability_form.html',
        form=form, action='edit', cve_id=cve_id
    )

@vuln_ui_bp.route('/<string:cve_id>/delete', methods=['POST'])
@login_required
def delete_vulnerability_ui(cve_id: str):
    """Exclui vulnerabilidade após validação CSRF."""
    form = DeleteForm()
    if not form.validate_on_submit():
        abort(400, description="CSRF token inválido.")
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    try:
        db.session.delete(vuln)
        db.session.commit()
        flash('Vulnerabilidade removida.', 'success')
    except SQLAlchemyError as e:
        db.session.rollback()
        logger.error("Erro deletando vulnerabilidade: %s", e, exc_info=True)
        flash('Erro ao remover.', 'danger')
    return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))

@vuln_ui_bp.route('/<string:cve_id>/mitigate', methods=['POST'])
@login_required
def mitigate_vulnerability_ui(cve_id: str):
    """Marca vulnerabilidade como mitigada após validação CSRF."""
    form = DeleteForm()
    if not form.validate_on_submit():
        abort(400, description="CSRF token inválido.")
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    try:
        vuln.patch_available = True
        db.session.commit()
        flash(f"Vulnerabilidade {cve_id} mitigada.", 'success')
    except SQLAlchemyError as e:
        db.session.rollback()
        logger.error("Erro mitigando vulnerabilidade: %s", e, exc_info=True)
        flash('Erro ao mitigar.', 'danger')
    return redirect(url_for('vulnerability_ui.list_vulnerabilities_ui'))

# ──────────────────────────────────────────────────────────────────────────────
# API Routes
# ──────────────────────────────────────────────────────────────────────────────

@vuln_api_bp.route('', methods=['GET'])
@login_required
def list_vulnerabilities_api():
    """API: listagem paginada com filtros."""
    page     = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', current_app.config.get('ITEMS_PER_PAGE', 20), type=int)
    severity = request.args.get('severity')

    if severity and severity not in severity_levels:
        raise BadRequest(f"Severidade inválida: {severity}")

    query      = vuln_service.session.query(Vulnerability)
    query      = vuln_service.apply_filters(query, severity)
    pagination = paginate_query(query.order_by(Vulnerability.published_date.desc()),
                                page, per_page, error_out=False)

    return jsonify({
        **vuln_list_schema.dump(pagination.items),
        'meta': {
            'page':       pagination.page,
            'per_page':   pagination.per_page,
            'total':      pagination.total,
            'total_pages': pagination.pages
        }
    })

@vuln_api_bp.route('/<string:cve_id>', methods=['GET'])
@login_required
def get_vulnerability_api(cve_id: str):
    """API: detalhes de uma vulnerabilidade."""
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    return jsonify(vuln_schema.dump(vuln))

@vuln_api_bp.route('/<string:cve_id>', methods=['PATCH'])
@login_required
def update_vulnerability_api(cve_id: str):
    """API: atualização parcial via PATCH."""
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    data = request.get_json() or {}
    # Validação de campos permitidos
    allowed = {'description','published_date','last_modified','base_severity','cvss_score','patch_available','assigner'}
    invalid = set(data) - allowed
    if invalid:
        raise BadRequest(f"Campos inválidos: {invalid}")

    for k,v in data.items():
        setattr(vuln, k, v)
    db.session.commit()
    return jsonify(vuln_schema.dump(vuln))

@vuln_api_bp.route('/<string:cve_id>/mitigate', methods=['PATCH'])
@login_required
def mitigate_vulnerability_api(cve_id: str):
    """API: marca como mitigada."""
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    vuln.patch_available = True
    db.session.commit()
    return jsonify(vuln_schema.dump(vuln))

@vuln_api_bp.route('/<string:cve_id>', methods=['DELETE'])
@login_required
def delete_vulnerability_api(cve_id: str):
    """API: exclusão de vulnerabilidade."""
    vuln = vuln_service.get_vulnerability_by_cve_id(cve_id.upper())
    db.session.delete(vuln)
    db.session.commit()
    return jsonify({'message': f'CVE {cve_id} excluída.'}), 204

# Error handlers poderiam ser registrados no app global, herdar de main.
