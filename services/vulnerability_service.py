
"""
VulnerabilityService handles business logic for querying and managing vulnerability data.

This service provides methods to fetch paginated vulnerabilities, dashboard counts,
and individual vulnerability details, interacting with the database via SQLAlchemy.
"""

from typing import List, Dict, Optional, Tuple
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from sqlalchemy import func
from models.vulnerability import Vulnerability


class VulnerabilityService:
    """Service for managing vulnerability-related operations."""

    def __init__(self, session: Session):
        """
        Initialize the service with a database session.

        Args:
            session: SQLAlchemy session for database operations.
        """
        self.session = session

    def get_recent_paginated(self, page: int, per_page: int) -> Tuple[List[Vulnerability], int]:
        """
        Fetch a paginated list of recent vulnerabilities.

        Args:
            page: Page number for pagination (1-based).
            per_page: Number of items per page.

        Returns:
            Tuple containing the list of vulnerabilities and the total count.
        """
        try:
            from sqlalchemy.orm import joinedload
            query = self.session.query(Vulnerability).options(joinedload(Vulnerability.references)).order_by(Vulnerability.published_date.desc())
            total_count = query.count()
            offset = (page - 1) * per_page
            vulnerabilities = query.offset(offset).limit(per_page).all()
            return vulnerabilities, total_count
        except Exception as e:
            raise RuntimeError(f"Error fetching paginated vulnerabilities: {e}")

    def get_dashboard_counts(self) -> Dict[str, int]:
        """
        Retrieve counts of vulnerabilities by severity and total.

        Returns:
            Dictionary with counts for critical, high, medium, and total vulnerabilities.
        """
        try:
            counts = {
                'critical': self.session.query(Vulnerability).filter_by(base_severity='CRITICAL').count(),
                'high': self.session.query(Vulnerability).filter_by(base_severity='HIGH').count(),
                'medium': self.session.query(Vulnerability).filter_by(base_severity='MEDIUM').count(),
                'total': self.session.query(Vulnerability).count()
            }
            return counts
        except Exception as e:
            raise RuntimeError(f"Error fetching dashboard counts: {e}")

    def get_vulnerability_by_id(self, cve_id: str) -> Optional[Vulnerability]:
        """
        Fetch a single vulnerability by its CVE ID.

        Args:
            cve_id: The CVE ID of the vulnerability (e.g., 'CVE-2023-12345').

        Returns:
            The Vulnerability object if found, else None.
        """
        try:
            return self.session.query(Vulnerability).filter_by(cve_id=cve_id).first()
        except Exception as e:
            raise RuntimeError(f"Error fetching vulnerability by ID {cve_id}: {e}")
    
    def get_vulnerability_by_cve_id(self, cve_id: str) -> Optional[Vulnerability]:
        """
        Alias for get_vulnerability_by_id for backward compatibility.
        
        Args:
            cve_id: The CVE ID of the vulnerability (e.g., 'CVE-2023-12345').
            
        Returns:
            The Vulnerability object if found, else None.
        """
        return self.get_vulnerability_by_id(cve_id)

    def get_weekly_counts(self) -> Dict[str, int]:
        """
        Retrieve counts of vulnerabilities published in the last 7 days by severity.

        Returns:
            Dictionary with weekly counts for critical, high, medium, and total vulnerabilities.
        """
        try:
            # Calculate date 7 days ago
            week_ago = datetime.now() - timedelta(days=7)
            
            # Base query for vulnerabilities from last week
            base_query = self.session.query(Vulnerability).filter(
                Vulnerability.published_date >= week_ago
            )
            
            counts = {
                'critical': base_query.filter_by(base_severity='CRITICAL').count(),
                'high': base_query.filter_by(base_severity='HIGH').count(),
                'medium': base_query.filter_by(base_severity='MEDIUM').count(),
                'total': base_query.count()
            }
            return counts
        except Exception as e:
            raise RuntimeError(f"Error fetching weekly vulnerability counts: {e}")

    def get_vulnerability_analytics(self, cve_id: str) -> Dict:
        """
        Get comprehensive analytics data for a specific vulnerability.

        Args:
            cve_id: The CVE ID of the vulnerability.

        Returns:
            Dictionary containing analytics data including affected assets, timeline, etc.
        """
        try:
            vulnerability = self.get_vulnerability_by_id(cve_id)
            if not vulnerability:
                return {}

            # Get affected assets count
            from models.asset_vulnerability import AssetVulnerability
            affected_assets_count = self.session.query(AssetVulnerability).filter_by(
                vulnerability_id=vulnerability.cve_id
            ).count()

            # Get severity distribution for similar vulnerabilities
            similar_vulns = self.session.query(Vulnerability).filter(
                Vulnerability.base_severity == vulnerability.base_severity
            ).count()

            # Calculate risk score based on CVSS and affected assets
            risk_score = 0
            if vulnerability.cvss_score:
                risk_score = vulnerability.cvss_score * (1 + (affected_assets_count * 0.1))
                risk_score = min(risk_score, 10.0)  # Cap at 10.0

            analytics = {
                'vulnerability': vulnerability,
                'affected_assets_count': affected_assets_count,
                'similar_vulnerabilities_count': similar_vulns,
                'calculated_risk_score': round(risk_score, 1),
                'severity_level': vulnerability.base_severity,
                'cvss_score': vulnerability.cvss_score,
                'published_date': vulnerability.published_date,
                'last_modified': vulnerability.last_update
            }

            return analytics
        except Exception as e:
            raise RuntimeError(f"Error fetching vulnerability analytics for {cve_id}: {e}")

    def save_vulnerabilities_batch(self, vulnerabilities_data: List[Dict]) -> int:
        """
        Save a batch of vulnerabilities to the database.
        
        Args:
            vulnerabilities_data: List of dictionaries containing vulnerability data
            
        Returns:
            Number of vulnerabilities successfully saved
        """
        try:
            from models.cvss_metric import CVSSMetric
            saved_count = 0
            
            for vuln_data in vulnerabilities_data:
                # Check if vulnerability already exists
                existing_vuln = self.session.query(Vulnerability).filter_by(
                    cve_id=vuln_data['cve_id']
                ).first()
                
                if existing_vuln:
                    # Update existing vulnerability
                    for key, value in vuln_data.items():
                        if key not in ['cvss_metrics']:  # Skip metrics for now
                            setattr(existing_vuln, key, value)
                    vulnerability = existing_vuln
                else:
                    # Create new vulnerability
                    vuln_dict = {k: v for k, v in vuln_data.items() if k != 'cvss_metrics'}
                    vulnerability = Vulnerability(**vuln_dict)
                    self.session.add(vulnerability)
                
                # Handle CVSS metrics
                if 'cvss_metrics' in vuln_data and vuln_data['cvss_metrics']:
                    # Remove existing metrics for this vulnerability
                    self.session.query(CVSSMetric).filter_by(
                        vulnerability_id=vulnerability.cve_id
                    ).delete()
                    
                    # Add new metrics
                    for metric_data in vuln_data['cvss_metrics']:
                        metric_data['vulnerability_id'] = vulnerability.cve_id
                        metric = CVSSMetric(**metric_data)
                        self.session.add(metric)
                
                saved_count += 1
            
            self.session.commit()
            return saved_count
            
        except Exception as e:
            self.session.rollback()
            raise RuntimeError(f"Error saving vulnerabilities batch: {e}")
    
    def get_last_sync_time(self) -> Optional[datetime]:
        """
        Get the last synchronization time from sync metadata.
        
        Returns:
            Last sync time or None if no sync has been performed
        """
        try:
            from models.sync_metadata import SyncMetadata
            sync_record = self.session.query(SyncMetadata).filter_by(
                source='nvd'
            ).first()
            
            return sync_record.last_sync_time if sync_record else None
            
        except Exception as e:
            raise RuntimeError(f"Error fetching last sync time: {e}")